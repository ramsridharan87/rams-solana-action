{"version":3,"sources":["../src/dialect-cloud-api/data-service-api.ts","../package.json","../src/dialect-cloud-api/data-service-dapps-api.ts","../src/sdk/errors.ts","../src/address/addresses.interface.ts","../src/auth/auth.interface.ts","../src/auth/authentication-facade.ts","../src/auth/token-store.ts","../src/auth/token-provider.ts","../src/auth/token-parser.ts","../src/utils/bytes-utils.ts","../src/auth/token-validator.ts","../src/auth/token-generator.ts","../src/auth/default-token-generator.ts","../src/auth/ed25519/ed25519-token-body-parser.ts","../src/auth/ed25519/ed25519-token-validator.ts","../src/auth/ed25519/ed25519-public-key.ts","../src/auth/ed25519/ed25519-authentication-facade-factory.ts","../src/auth/ed25519/ed25519-token-signer.ts","../src/auth/ed25519/utils.ts","../src/dapp/dapp.interface.ts","../src/encryption/encryption-keys-store.ts","../src/encryption/encryption-keys-provider.ts","../src/messaging/messaging.interface.ts","../src/messaging/errors.ts","../src/dialect-cloud-api/data-service-dialects-api.ts","../src/internal/errors.ts","../src/dialect-cloud-api/data-service-errors.ts","../src/messaging/nonce-generator.ts","../src/messaging/ecdh-encryption.ts","../src/messaging/text-serde.ts","../src/sdk/constants.ts","../src/internal/messaging/data-service-messaging.ts","../src/internal/dapp/data-service-dapp-messages.ts","../src/internal/dapp/data-service-dapp-notification-subscriptions.ts","../src/internal/dapp/dapp-messages-facade.ts","../src/internal/dapp/dapp.ts","../src/utils/collection-utils.ts","../src/internal/dapp/dapp-addresses-facade.ts","../src/identity/identity.interface.ts","../src/internal/identity/identity-resolvers.ts","../src/internal/dapp/data-service-dapp-addresses.ts","../src/internal/wallet/data-service-wallets.ts","../src/internal/messaging/messaging-facade.ts","../src/internal/dapp/data-service-dapp-notification-types.ts","../src/dialect-cloud-api/data-service-wallet-notification-subscriptions-api.ts","../src/dialect-cloud-api/data-service-wallets-api.v0.ts","../src/dialect-cloud-api/data-service-wallet-dapp-addresses-api.ts","../src/dialect-cloud-api/data-service-wallet-addresses-api.ts","../src/dialect-cloud-api/data-service-push-notification-subscriptions-api.ts","../src/dialect-cloud-api/data-service-api-factory.ts","../src/dialect-cloud-api/data-service-dapp-notification-types-api.ts","../src/dialect-cloud-api/data-service-wallet-messages-api.ts","../src/dialect-cloud-api/data-service-dapp-notification-subscriptions-api.ts","../src/dialect-cloud-api/data-service-health-api.ts","../src/dialect-cloud-api/data-service-wallets-api.v1.ts","../src/internal/sdk/sdk-factory.ts","../src/sdk/sdk.interface.ts","../src/wallet/wallet.interface.ts","../src/dialect-cloud-api/smart-message-spec.dto.ts","../src/dialect-cloud-api/smart-message.dto.ts"],"sourcesContent":["import type { DataServiceDialectsApi } from './data-service-dialects-api';\nimport type { DataServiceWalletNotificationSubscriptionsApi } from './data-service-wallet-notification-subscriptions-api';\nimport type { DataServiceWalletsApiV0 } from './data-service-wallets-api.v0';\nimport type { DataServiceWalletDappAddressesApi } from './data-service-wallet-dapp-addresses-api';\nimport type { DataServiceWalletAddressesApi } from './data-service-wallet-addresses-api';\nimport type { Token } from '../auth/auth.interface';\nimport type { DataServiceDappsApi } from './data-service-dapps-api';\nimport type { DataServicePushNotificationSubscriptionsApi } from './data-service-push-notification-subscriptions-api';\nimport { nanoid } from 'nanoid';\nimport type { DataServiceDappNotificationTypesApi } from './data-service-dapp-notification-types-api';\nimport type { DataServiceWalletMessagesApi } from './data-service-wallet-messages-api';\nimport type { AxiosError } from 'axios';\nimport type { DataServiceDappNotificationSubscriptionsApi } from './data-service-dapp-notification-subscriptions-api';\nimport type { DataServiceHealthApi } from './data-service-health-api';\nimport { SDK_VERSION } from '../version';\n\nexport class DataServiceApi {\n  constructor(\n    readonly threads: DataServiceDialectsApi,\n    readonly dapps: DataServiceDappsApi,\n    readonly dappNotificationTypes: DataServiceDappNotificationTypesApi,\n    readonly dappNotificationSubscriptions: DataServiceDappNotificationSubscriptionsApi,\n    readonly walletsV0: DataServiceWalletsApiV0,\n    readonly walletAddresses: DataServiceWalletAddressesApi,\n    readonly walletDappAddresses: DataServiceWalletDappAddressesApi,\n    readonly walletMessages: DataServiceWalletMessagesApi,\n    readonly walletNotificationSubscriptions: DataServiceWalletNotificationSubscriptionsApi,\n    readonly pushNotificationSubscriptions: DataServicePushNotificationSubscriptionsApi,\n    readonly health: DataServiceHealthApi,\n  ) {}\n}\n\ninterface RawDataServiceApiError {\n  message: string;\n}\n\nexport type DataServiceApiClientError = NetworkError | DataServiceApiError;\n\nexport class NetworkError {}\n\nexport class DataServiceApiError {\n  constructor(\n    readonly error: string,\n    readonly statusCode: number,\n    readonly message?: string | null,\n    readonly requestId?: string | null,\n  ) {}\n}\n\nconst XRequestIdHeader = 'x-request-id';\nconst XClientNameHeader = 'x-client-name';\nconst XClientVersionHeader = 'x-client-version';\n\nexport function createHeaders(token?: Token) {\n  return {\n    ...(token && {\n      Authorization: `Bearer ${token.rawValue}`,\n    }),\n    [XRequestIdHeader]: nanoid(),\n    [XClientNameHeader]: 'dialect-sdk',\n    [XClientVersionHeader]: SDK_VERSION,\n  };\n}\n\nexport async function withReThrowingDataServiceError<T>(fn: Promise<T>) {\n  try {\n    return await fn;\n  } catch (e) {\n    console.error(e);\n    const err = e as AxiosError;\n    if (!err.response) {\n      throw new NetworkError();\n    }\n    const data = err.response.data as RawDataServiceApiError;\n    const requestId =\n      (err.config.headers &&\n        (err.config.headers[XRequestIdHeader] as string)) ??\n      null;\n    throw new DataServiceApiError(\n      err.response.statusText,\n      Number(err.response.status),\n      data.message,\n      requestId,\n    );\n  }\n}\n","{\n  \"name\": \"@dialectlabs/sdk\",\n  \"version\": \"1.9.4\",\n  \"type\": \"module\",\n  \"repository\": \"git@github.com:dialectlabs/sdk.git\",\n  \"author\": \"dialectlabs\",\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"clean\": \"rm -rf lib\",\n    \"lint\": \"eslint \\\"{src,test}/**/*.ts\\\" --fix\",\n    \"build\": \"tsup-node\",\n    \"dev\": \"tsup-node --watch\",\n    \"token:generate\": \"ts-node examples/generate-token.ts\",\n    \"test\": \"jest\",\n    \"format\": \"prettier --write \\\"src/**/*.ts\\\" \\\"test/**/*.ts\\\"\"\n  },\n  \"devDependencies\": {\n    \"@solana/wallet-adapter-base\": \"^0.9.15\",\n    \"@solana/web3.js\": \"^1.53.0\",\n    \"@types/bs58\": \"^4.0.1\",\n    \"@types/ed2curve\": \"^0.2.2\",\n    \"mockdate\": \"^3.0.5\"\n  },\n  \"dependencies\": {\n    \"@stablelib/base64\": \"^1.0.1\",\n    \"axios\": \"^0.27.2\",\n    \"bs58\": \"^5.0.0\",\n    \"ed2curve\": \"^0.3.0\",\n    \"js-sha3\": \"^0.8.0\",\n    \"nanoid\": \"^3.3.4\",\n    \"tweetnacl\": \"^1.0.3\"\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\nimport type { BlockchainType } from '../dapp/dapp.interface';\n\nexport interface DataServiceDappsApi {\n  create(command: Omit<CreateDappCommandDto, 'publicKey'>): Promise<DappDto>;\n\n  patch(command: PatchDappCommandDto): Promise<DappDto>;\n\n  findAll(query?: FindDappQueryDto): Promise<DappDto[]>;\n\n  find(dappAddress?: string): Promise<DappDto>;\n\n  findAllDappAddresses(): Promise<DappAddressDto[]>;\n\n  unicast(command: UnicastDappMessageCommandDto): Promise<void>;\n\n  multicast(command: MulticastDappMessageCommandDto): Promise<void>;\n\n  broadcast(command: BroadcastDappMessageCommandDto): Promise<void>;\n}\n\nexport class DataServiceDappsApiClient implements DataServiceDappsApi {\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async create(\n    command: Omit<CreateDappCommandDto, 'publicKey'>,\n  ): Promise<DappDto> {\n    const token = await this.tokenProvider.get();\n    const fullCommand: CreateDappCommandDto = {\n      ...command,\n      publicKey: token.body.sub,\n    };\n    return withReThrowingDataServiceError(\n      axios\n        .post<DappDto>(`${this.baseUrl}/api/v1/dapps`, fullCommand, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async patch(command: PatchDappCommandDto): Promise<DappDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .patch<DappDto>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async findAllDappAddresses(): Promise<DappAddressDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappAddressDto[]>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/dappAddresses`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async find(dappAddress?: string): Promise<DappDto> {\n    const token = await this.tokenProvider.get();\n    const dappAddressToFind = dappAddress || token.body.sub;\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappDto>(`${this.baseUrl}/api/v1/dapps/${dappAddressToFind}`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async broadcast(command: BroadcastDappMessageCommandDto): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/broadcast`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async multicast(command: MulticastDappMessageCommandDto): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/multicast`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async unicast(command: UnicastDappMessageCommandDto): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/unicast`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async findAll(query?: FindDappQueryDto): Promise<DappDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappDto[]>(`${this.baseUrl}/api/v1/dapps`, {\n          headers: createHeaders(token),\n          params: query,\n        })\n        .then((it) => it.data),\n    );\n  }\n}\n\nexport class DappDto {\n  readonly id!: string;\n  readonly publicKey!: string;\n  readonly name!: string;\n  readonly description?: string;\n  readonly websiteUrl?: string;\n  readonly avatarUrl?: string;\n  readonly heroUrl?: string;\n  readonly telegramBotUserName!: string;\n  readonly verified!: boolean;\n  readonly blockchainType!: BlockchainType;\n}\n\nexport class CreateDappCommandDto {\n  readonly name!: string;\n  readonly publicKey!: string;\n  readonly description?: string;\n  readonly websiteUrl?: string;\n  readonly avatarUrl?: string;\n  readonly heroUrl?: string;\n  readonly telegramBotConfiguration?: DappTelegramBotConfigurationDto;\n  readonly blockchainType?: string;\n}\n\nexport class PatchDappCommandDto {\n  readonly name?: string;\n  readonly description?: string | null;\n  readonly websiteUrl?: string | null;\n  readonly avatarUrl?: string | null;\n  readonly heroUrl?: string | null;\n}\n\nexport class DappTelegramBotConfigurationDto {\n  readonly token!: string;\n}\n\nexport class DappAddressDto {\n  readonly id!: string;\n  readonly enabled!: boolean;\n  readonly dapp!: DappDto;\n  readonly channelId?: string;\n  readonly address!: AddressDto;\n}\n\nexport class AddressDto {\n  readonly id!: string;\n  readonly type!: AddressTypeDto;\n  readonly verified!: boolean;\n  readonly value!: string;\n  readonly wallet!: WalletDto;\n}\n\nexport class WalletDto {\n  readonly id!: string;\n  readonly publicKey!: string;\n}\n\nexport enum AddressTypeDto {\n  Email = 'EMAIL',\n  PhoneNumber = 'PHONE_NUMBER',\n  Telegram = 'TELEGRAM',\n  Wallet = 'WALLET',\n}\n\n// start actions\nexport enum DappMessageActionTypeDto {\n  LINK = 'Link',\n  SMART_MESSAGE = 'SmartMessage',\n}\n\ninterface DappMessageActionBaseDto {\n  type: DappMessageActionTypeDto;\n}\n\nexport class DappMessageLinksActionDto implements DappMessageActionBaseDto {\n  type!: DappMessageActionTypeDto.LINK;\n  links!: DappMessageLinkAction[];\n}\n\nexport class DappMessageLinkAction {\n  label!: string;\n  url!: string;\n}\n\nexport class DappMessageSmartMessageActionDto\n  implements DappMessageActionBaseDto\n{\n  type!: DappMessageActionTypeDto.SMART_MESSAGE;\n  smartMessage!: SmartMessageDto;\n}\n\nexport class SmartMessageDto {\n  transactionServiceId!: string;\n  transactionParams!: Record<string, any>;\n}\n// end actions\n\nclass SendDappMessageCommandDto {\n  title?: string;\n  message!: string;\n  imageUrl?: string;\n  notificationTypeId?: string;\n  addressTypes?: AddressTypeDto[];\n  // tags?: string[];\n}\n\nexport class UnicastDappMessageCommandDto extends SendDappMessageCommandDto {\n  recipientPublicKey!: string;\n  actionsV2?: DappMessageLinksActionDto | DappMessageSmartMessageActionDto;\n}\n\nexport class MulticastDappMessageCommandDto extends SendDappMessageCommandDto {\n  recipientPublicKeys!: string[];\n  actionsV2?: DappMessageLinksActionDto;\n}\n\nexport class BroadcastDappMessageCommandDto extends SendDappMessageCommandDto {\n  actionsV2?: DappMessageLinksActionDto;\n}\n\nexport class FindDappQueryDto {\n  verified?: boolean;\n  blockchainType?: BlockchainType;\n}\n","export class DialectSdkError extends Error {\n  constructor(\n    readonly type: string,\n    readonly title: string,\n    readonly msg?: string,\n    readonly details?: any[],\n  ) {\n    super(msg);\n    this.msg = msg;\n    this.type = type;\n    this.title = title;\n    this.details = details;\n  }\n}\n\nexport class IllegalArgumentError extends DialectSdkError {\n  constructor(title: string, msg?: string, details?: any) {\n    super(IllegalArgumentError.name, title, msg, details);\n  }\n}\n\nexport class IllegalStateError extends DialectSdkError {\n  constructor(title: string, msg?: string, details?: any) {\n    super(IllegalStateError.name, title, msg, details);\n  }\n}\n\nexport class UnsupportedOperationError extends DialectSdkError {\n  constructor(title: string, msg?: string, details?: any) {\n    super(UnsupportedOperationError.name, title, msg, details);\n  }\n}\n\nexport class UnknownError extends DialectSdkError {\n  constructor(details?: any, msg?: string) {\n    super(\n      UnknownError.name,\n      'Error',\n      msg ?? 'Something went wrong. Please try again later.',\n      details,\n    );\n  }\n}\n\nexport class BusinessConstraintViolationError extends DialectSdkError {\n  constructor(msg?: string) {\n    super(BusinessConstraintViolationError.name, 'Error', msg);\n  }\n}\n\nexport class ResourceAlreadyExistsError extends DialectSdkError {\n  constructor(msg?: string) {\n    super(ResourceAlreadyExistsError.name, 'Error', msg);\n  }\n}\n\nexport class AuthenticationError extends DialectSdkError {\n  constructor(msg?: string) {\n    super(AuthenticationError.name, 'Error', msg);\n  }\n}\n\nexport class AuthorizationError extends DialectSdkError {\n  constructor(msg?: string) {\n    super(AuthorizationError.name, 'Error', msg);\n  }\n}\n\nexport class ResourceNotFoundError extends DialectSdkError {\n  constructor(msg?: string) {\n    super(ResourceNotFoundError.name, 'Error', msg);\n  }\n}\n\nexport abstract class IdentityError extends DialectSdkError {}\n","import { AddressTypeDto } from '../dialect-cloud-api/data-service-dapps-api';\nimport { IllegalArgumentError } from '../sdk/errors';\nimport type { Wallet } from '../wallet/wallet.interface';\n\nexport interface Address {\n  id: string;\n  type: AddressType;\n  verified: boolean;\n  value: string;\n  wallet: Wallet;\n}\n\nexport enum AddressType {\n  Email = 'EMAIL',\n  PhoneNumber = 'PHONE_NUMBER',\n  Telegram = 'TELEGRAM',\n  Wallet = 'WALLET',\n}\n\nconst addressTypeToAddressTypeDto: Record<AddressType, AddressTypeDto> = {\n  [AddressType.Email]: AddressTypeDto.Email,\n  [AddressType.PhoneNumber]: AddressTypeDto.PhoneNumber,\n  [AddressType.Telegram]: AddressTypeDto.Telegram,\n  [AddressType.Wallet]: AddressTypeDto.Wallet,\n};\n\nexport function toAddressTypeDto(type: AddressType): AddressTypeDto {\n  const addressTypeDto = addressTypeToAddressTypeDto[type];\n  if (!addressTypeDto) {\n    throw new IllegalArgumentError(`Unknown address type ${type}`);\n  }\n  return addressTypeDto;\n}\n\nconst addressTypeDtoToAddressType: Record<AddressTypeDto, AddressType> = {\n  [AddressTypeDto.Email]: AddressType.Email,\n  [AddressTypeDto.PhoneNumber]: AddressType.PhoneNumber,\n  [AddressTypeDto.Telegram]: AddressType.Telegram,\n  [AddressTypeDto.Wallet]: AddressType.Wallet,\n};\n\nexport function toAddressType(type: AddressTypeDto): AddressType {\n  const addressType = addressTypeDtoToAddressType[type];\n  if (!addressType) {\n    throw new IllegalArgumentError(`Unknown address type ${type}`);\n  }\n  return addressType;\n}\n\nexport interface DappAddress {\n  id: string;\n  dappId: string;\n  enabled: boolean;\n  channelId?: string | null;\n  address: Address;\n}\n","export type AccountAddress = string;\n\nexport abstract class PublicKey {\n  abstract toString(): string;\n\n  abstract toBytes(): Uint8Array;\n\n  equals(other: PublicKey) {\n    return this.toString() === other.toString();\n  }\n}\n\nexport interface Token {\n  rawValue: string;\n  header: TokenHeader;\n  body: TokenBody;\n  signature: Uint8Array;\n  base64Header: string;\n  base64Body: string;\n  base64Signature: string;\n}\n\nexport interface TokenHeader {\n  alg: string;\n  typ?: string;\n}\n\nexport interface TokenBody {\n  sub: string;\n  sub_jwk?: string;\n  iat?: number;\n  exp: number;\n}\n\nexport interface TokenSignerResult {\n  payload: Uint8Array;\n  signature: Uint8Array;\n}\n\nexport abstract class TokenSigner {\n  abstract alg: string;\n  abstract subject: AccountAddress;\n  abstract subjectPublicKey?: PublicKey;\n\n  abstract sign(payload: Uint8Array): Promise<TokenSignerResult>;\n}\n","import type { TokenGenerator } from './token-generator';\nimport type { TokenValidator } from './token-validator';\nimport type { TokenParser } from './token-parser';\nimport type {\n  AccountAddress,\n  Token,\n  TokenHeader,\n  TokenSigner,\n} from './auth.interface';\n\nexport class Authenticator {\n  constructor(\n    readonly parser: TokenParser,\n    readonly validator: TokenValidator,\n  ) {}\n\n  authenticate(token: string): Token | null {\n    const header = this.parser.parseHeader(token);\n    if (!this.validator.canValidate(header)) {\n      return null;\n    }\n    const parsedToken = this.parser.parse(token);\n    const isValid = this.validator.isValid(parsedToken);\n    if (!isValid) {\n      return null;\n    }\n    return parsedToken;\n  }\n}\n\nexport abstract class AuthenticationFacadeFactory {\n  abstract get(): AuthenticationFacade;\n}\n\nexport class AuthenticationFacade {\n  constructor(\n    readonly tokenSigner: TokenSigner,\n    readonly tokenGenerator: TokenGenerator,\n    readonly authenticator: Authenticator,\n  ) {}\n\n  type(): string {\n    return this.tokenSigner.alg;\n  }\n\n  subject(): AccountAddress {\n    return this.tokenSigner.subject;\n  }\n\n  generateToken(ttlSeconds: number) {\n    return this.tokenGenerator.generate(ttlSeconds);\n  }\n\n  parseToken(token: string) {\n    return this.authenticator.parser.parse(token);\n  }\n\n  canValidate(tokenHeader: TokenHeader) {\n    return this.authenticator.validator.canValidate(tokenHeader);\n  }\n\n  isValid(token: Token) {\n    return this.authenticator.validator.isValid(token);\n  }\n}\n","import type { AccountAddress } from './auth.interface';\n\nexport abstract class TokenStore {\n  static createInMemory(): TokenStore {\n    return new InMemoryTokenStore();\n  }\n\n  static createSessionStorage(): TokenStore {\n    return new SessionStorageTokenStore();\n  }\n\n  static createLocalStorage(): TokenStore {\n    return new LocalStorageTokenStore();\n  }\n\n  abstract get(subject: AccountAddress): string | null;\n\n  abstract delete(subject: AccountAddress): void;\n\n  abstract save(subject: AccountAddress, token: string): string;\n}\n\nclass InMemoryTokenStore extends TokenStore {\n  private tokens: Record<string, string> = {};\n\n  get(subject: AccountAddress): string | null {\n    return this.tokens[subject.toString()] ?? null;\n  }\n\n  save(subject: AccountAddress, token: string): string {\n    this.tokens[subject.toString()] = token;\n    return token;\n  }\n\n  delete(subject: AccountAddress): void {\n    delete this.tokens[subject.toString()];\n  }\n}\n\nclass SessionStorageTokenStore extends TokenStore {\n  get(subject: AccountAddress): string | null {\n    const key = createStorageKey(subject.toString());\n    return sessionStorage.getItem(key);\n  }\n\n  delete(subject: AccountAddress): void {\n    const key = createStorageKey(subject.toString());\n    sessionStorage.removeItem(key);\n  }\n\n  save(subject: AccountAddress, token: string): string {\n    sessionStorage.setItem(createStorageKey(subject.toString()), token);\n    return token;\n  }\n}\n\nclass LocalStorageTokenStore extends TokenStore {\n  get(subject: AccountAddress): string | null {\n    const key = createStorageKey(subject.toString());\n    return localStorage.getItem(key);\n  }\n\n  save(subject: AccountAddress, token: string): string {\n    localStorage.setItem(createStorageKey(subject.toString()), token);\n    return token;\n  }\n\n  delete(subject: AccountAddress): void {\n    localStorage.removeItem(createStorageKey(subject.toString()));\n  }\n}\n\nconst storageTokenKeyPrefix = 'dialect-auth-token';\n\nfunction createStorageKey(subject: string) {\n  return `${storageTokenKeyPrefix}-${subject}`;\n}\n","import type { AccountAddress, Token } from './auth.interface';\nimport { IllegalArgumentError } from '../sdk/errors';\nimport { TokenStore } from './token-store';\nimport type { TokenParser } from './token-parser';\nimport type { TokenValidator } from './token-validator';\nimport type { AuthenticationFacade } from './authentication-facade';\nimport type { TokenGenerator } from './token-generator';\nimport type { DataServiceWalletsApiClientV1 } from '../dialect-cloud-api/data-service-wallets-api.v1';\nimport type { WalletCreation } from '../sdk/sdk.interface';\n\nexport const DEFAULT_TOKEN_LIFETIME_SECONDS = 24 * 60 * 60; // 24 hours\nexport const MAX_TOKEN_LIFETIME_SECONDS = 3 * 30 * 24 * 60 * 60; // 3 months\n\nexport abstract class TokenProvider {\n  static create(\n    authenticationFacade: AuthenticationFacade,\n    dataServiceWalletsApiClientV1: DataServiceWalletsApiClientV1,\n    ttlSeconds = DEFAULT_TOKEN_LIFETIME_SECONDS,\n    tokenStore: TokenStore = TokenStore.createInMemory(),\n    walletCreation: WalletCreation = 'implicit',\n  ): TokenProvider {\n    const defaultTokenProvider = new DefaultTokenProvider(\n      ttlSeconds,\n      authenticationFacade.tokenGenerator,\n    );\n    return new CachedTokenProvider(\n      defaultTokenProvider,\n      tokenStore,\n      walletCreation,\n      authenticationFacade.authenticator.parser,\n      authenticationFacade.authenticator.validator,\n      authenticationFacade.subject(),\n      dataServiceWalletsApiClientV1,\n    );\n  }\n\n  abstract get(): Promise<Token>;\n}\n\nexport class DefaultTokenProvider extends TokenProvider {\n  constructor(\n    private readonly ttlSeconds: number,\n    private readonly tokenGenerator: TokenGenerator,\n  ) {\n    if (ttlSeconds > MAX_TOKEN_LIFETIME_SECONDS) {\n      throw new IllegalArgumentError(\n        `Token TTL ${ttlSeconds} must be <= max ${MAX_TOKEN_LIFETIME_SECONDS}`,\n      );\n    }\n    super();\n  }\n\n  get(): Promise<Token> {\n    return this.tokenGenerator.generate(this.ttlSeconds);\n  }\n}\n\nexport class CachedTokenProvider extends TokenProvider {\n  private readonly delegateGetPromises: Record<string, Promise<Token>> = {};\n\n  constructor(\n    private readonly delegate: TokenProvider,\n    private readonly tokenStore: TokenStore,\n    private readonly walletCreation: WalletCreation,\n    private readonly tokenParser: TokenParser,\n    private readonly tokenValidator: TokenValidator,\n    private readonly subject: AccountAddress,\n    private readonly dataServiceWalletsApiClientV1: DataServiceWalletsApiClientV1,\n  ) {\n    super();\n  }\n\n  async get(): Promise<Token> {\n    const existingToken = this.getCachedToken();\n    const subject = this.subject.toString();\n    if (existingToken && this.tokenValidator.isValid(existingToken)) {\n      return existingToken;\n    }\n    const existingDelegatePromise = this.delegateGetPromises[subject];\n    if (existingDelegatePromise) {\n      return existingDelegatePromise;\n    }\n\n    const delegatePromise = this.delegate.get().then(async (it) => {\n      this.tokenStore.save(this.subject, it.rawValue);\n      delete this.delegateGetPromises[subject];\n      const wallet: { publicKey: string } = {\n        publicKey: this.subject,\n      };\n      if (this.walletCreation === 'implicit') {\n        await this.dataServiceWalletsApiClientV1.upsertWallet(wallet, it);\n      }\n      return it;\n    });\n\n    // delete promise to refetch the token in case of failure\n    delegatePromise.catch((it) => {\n      delete this.delegateGetPromises[subject];\n    });\n\n    this.delegateGetPromises[subject] = delegatePromise;\n    return delegatePromise;\n  }\n\n  hasValidCachedToken() {\n    const cachedToken = this.getCachedToken();\n    if (!cachedToken) {\n      return false;\n    }\n    return this.tokenValidator.isValid(cachedToken);\n  }\n\n  private getCachedToken(): Token | null {\n    const rawToken = this.tokenStore.get(this.subject);\n    if (!rawToken) {\n      return null;\n    }\n    try {\n      return this.tokenParser.parse(rawToken);\n    } catch (e) {\n      this.tokenStore.delete(this.subject);\n      return null;\n    }\n  }\n}\n","import { decodeURLSafe } from '@stablelib/base64';\nimport type { Token, TokenBody, TokenHeader } from './auth.interface';\nimport { DialectSdkError } from '../sdk/errors';\nimport { jsonParseFromBase64 } from '../utils/bytes-utils';\n\nexport class TokenParsingError extends DialectSdkError {\n  constructor() {\n    super(TokenParsingError.name, 'Unable to parse jwt token');\n  }\n}\n\nexport class TokenStructureValidationError extends DialectSdkError {\n  constructor() {\n    super(TokenStructureValidationError.name, 'Invalid jwt token');\n  }\n}\n\nexport class TokenUnsupportedAlgError extends DialectSdkError {\n  constructor() {\n    super(TokenUnsupportedAlgError.name, 'Jwt token alg unsupported');\n  }\n}\n\nexport abstract class TokenBodyParser {\n  abstract parse(base64Body: string): TokenBody;\n}\n\nexport class TokenHeaderParser {\n  parse(token: string): TokenHeader {\n    const parts = token.split('.');\n    const header = parts[0];\n    if (!header) {\n      throw new TokenParsingError();\n    }\n    return jsonParseFromBase64(header);\n  }\n}\n\nexport class TokenParser {\n  private readonly tokenHeaderParser = new TokenHeaderParser();\n\n  constructor(private readonly bodyParser: TokenBodyParser) {}\n\n  parse(token: string): Token {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new TokenParsingError();\n    }\n    const [base64Header, base64Body, base64Signature] = parts;\n    if (!base64Header || !base64Body || !base64Signature) {\n      throw new TokenParsingError();\n    }\n    try {\n      const header = this.parseHeader(token);\n      const body = this.parseBody(base64Body);\n      const signature = decodeURLSafe(base64Signature);\n      return {\n        base64Header,\n        base64Body,\n        base64Signature,\n        rawValue: token,\n        header,\n        signature,\n        body,\n      };\n    } catch (e) {\n      console.error(e);\n      throw new TokenParsingError();\n    }\n  }\n\n  parseHeader(token: string) {\n    return this.tokenHeaderParser.parse(token);\n  }\n\n  private parseBody(base64Body: string): TokenBody {\n    const body: TokenBody = this.bodyParser.parse(base64Body);\n    if (!body.sub || !body.exp) {\n      throw new TokenStructureValidationError();\n    }\n    return body;\n  }\n}\n","import { decodeURLSafe, encodeURLSafe } from '@stablelib/base64';\n\nexport function bytesToBase64(bytes: Uint8Array): string {\n  return encodeURLSafe(bytes).replace(/=/g, '');\n}\n\nexport function bytesFromBase64(base64: string): Uint8Array {\n  return decodeURLSafe(base64);\n}\n\nexport function jsonStringifyToBase64<T>(t: T): string {\n  const json = JSON.stringify(t);\n  const byteArray = new TextEncoder().encode(json);\n  return bytesToBase64(byteArray);\n}\n\nexport function jsonParseFromBase64<T>(serialized: string): T {\n  const byteArray = decodeURLSafe(serialized);\n  const json = new TextDecoder().decode(byteArray);\n  return JSON.parse(json) as T;\n}\n","import type { Token, TokenHeader } from './auth.interface';\n\nexport abstract class TokenValidator {\n  isValid(token: Token): boolean {\n    if (!this.canValidate(token.header)) {\n      return false;\n    }\n    if (!this.isSignatureValid(token)) {\n      return false;\n    }\n    if (this.isExpired(token)) {\n      return false;\n    }\n    return this.performExtraValidation(token);\n  }\n\n  abstract canValidate(tokenHeader: TokenHeader): boolean;\n\n  abstract isSignatureValid(token: Token): boolean;\n\n  protected performExtraValidation(token: Token): boolean {\n    return true;\n  }\n\n  private isExpired(token: Token) {\n    const nowUtcSeconds = new Date().getTime() / 1000;\n    const delta = 10;\n    return nowUtcSeconds + delta > token.body.exp;\n  }\n}\n","import { bytesToBase64 } from '../utils/bytes-utils';\nimport type {\n  Token,\n  TokenBody,\n  TokenHeader,\n  TokenSigner,\n} from './auth.interface';\n\nexport abstract class TokenGenerator {\n  constructor(protected readonly signer: TokenSigner) {}\n\n  abstract generate(ttlSeconds: number): Promise<Token>;\n\n  protected header(): TokenHeader {\n    return {\n      alg: this.signer.alg,\n      typ: 'JWT',\n    };\n  }\n\n  protected body(ttlSeconds: number): TokenBody {\n    const nowUtcSeconds = new Date().getTime() / 1000;\n    const body: TokenBody = {\n      sub: this.signer.subject,\n      sub_jwk: this.signer.subjectPublicKey?.toString(),\n      iat: Math.round(nowUtcSeconds),\n      exp: Math.round(nowUtcSeconds + ttlSeconds),\n    };\n    return body;\n  }\n\n  protected async sign(\n    base64Header: string,\n    base64Body: string,\n    signer: TokenSigner,\n  ) {\n    const signingPayload = new TextEncoder().encode(\n      base64Header + '.' + base64Body,\n    );\n    const { payload: signedPayload, signature } = await signer.sign(\n      signingPayload,\n    );\n    const base64Signature = bytesToBase64(signature);\n    return { signedPayload, signature, base64Signature };\n  }\n}\n","import type { Token } from './auth.interface';\nimport { jsonStringifyToBase64 } from '../utils/bytes-utils';\nimport { TokenGenerator } from './token-generator';\n\nexport class DefaultTokenGenerator extends TokenGenerator {\n  override async generate(ttlSeconds: number): Promise<Token> {\n    const header = this.header();\n    const base64Header = jsonStringifyToBase64(header);\n\n    const body = this.body(ttlSeconds);\n    const base64Body = jsonStringifyToBase64(body);\n\n    const { signature, base64Signature } = await this.sign(\n      base64Header,\n      base64Body,\n      this.signer,\n    );\n\n    const rawValue = `${base64Header}.${base64Body}.${base64Signature}`;\n    return {\n      rawValue,\n      body,\n      header,\n      signature,\n      base64Signature,\n      base64Body,\n      base64Header,\n    };\n  }\n}\n","import { TokenBodyParser } from '../token-parser';\nimport type { TokenBody } from '../auth.interface';\nimport { jsonParseFromBase64 } from '../../utils/bytes-utils';\n\nexport class Ed25519TokenBodyParser extends TokenBodyParser {\n  parse(base64Body: string): TokenBody {\n    return jsonParseFromBase64(base64Body);\n  }\n}\n","import nacl from 'tweetnacl';\nimport { TokenValidator } from '../token-validator';\nimport type { Token, TokenHeader } from '../auth.interface';\nimport { Ed25519PublicKey } from './ed25519-public-key';\n\nexport class Ed25519TokenValidator extends TokenValidator {\n  canValidate(tokenHeader: TokenHeader): boolean {\n    return tokenHeader.alg === 'ed25519';\n  }\n\n  isSignatureValid(token: Token): boolean {\n    const signedPayload = token.base64Header + '.' + token.base64Body;\n    const signingPayload = new TextEncoder().encode(signedPayload);\n    return nacl.sign.detached.verify(\n      signingPayload,\n      token.signature,\n      new Ed25519PublicKey(token.body.sub_jwk ?? token.body.sub).toBytes(),\n    );\n  }\n}\n","import { PublicKey } from '../auth.interface';\nimport bs58 from 'bs58';\n\nexport type Ed25519PublicKeyInitData = string | Uint8Array;\n\nexport class Ed25519PublicKey extends PublicKey {\n  private readonly value: Uint8Array;\n\n  constructor(value: Ed25519PublicKeyInitData) {\n    super();\n    if (typeof value === 'string' && value.startsWith('0x')) {\n      // oof\n      const enc = new TextEncoder();\n      this.value = enc.encode(value);\n    } else if (typeof value === 'string') {\n      this.value = bs58.decode(value);\n    } else {\n      this.value = value;\n    }\n  }\n\n  toBytes(): Uint8Array {\n    return this.value;\n  }\n\n  toString(): string {\n    return bs58.encode(this.value);\n  }\n}\n","import {\n  AuthenticationFacade,\n  AuthenticationFacadeFactory,\n  Authenticator,\n} from '../authentication-facade';\nimport { DefaultTokenGenerator } from '../default-token-generator';\nimport { TokenParser } from '../token-parser';\nimport { Ed25519TokenBodyParser } from './ed25519-token-body-parser';\nimport { Ed25519TokenValidator } from './ed25519-token-validator';\nimport type { Ed25519TokenSigner } from './ed25519-token-signer';\n\nexport class Ed25519AuthenticationFacadeFactory extends AuthenticationFacadeFactory {\n  constructor(private readonly tokenSigner: Ed25519TokenSigner) {\n    super();\n  }\n\n  get(): AuthenticationFacade {\n    return new AuthenticationFacade(\n      this.tokenSigner,\n      new DefaultTokenGenerator(this.tokenSigner),\n      Ed25519AuthenticationFacadeFactory.createAuthenticator(),\n    );\n  }\n\n  static createAuthenticator(): Authenticator {\n    return new Authenticator(\n      new TokenParser(new Ed25519TokenBodyParser()),\n      new Ed25519TokenValidator(),\n    );\n  }\n}\n","import type {\n  AccountAddress,\n  PublicKey,\n  TokenSigner,\n  TokenSignerResult,\n} from '../auth.interface';\nimport nacl from 'tweetnacl';\nimport type { SignKeyPair } from 'tweetnacl';\nimport { Ed25519PublicKey } from './ed25519-public-key';\nimport { generateEd25519Keypair } from './utils';\n\nexport class Ed25519TokenSigner implements TokenSigner {\n  readonly alg = 'ed25519';\n\n  constructor(\n    readonly keypair: SignKeyPair = generateEd25519Keypair(),\n    readonly subjectPublicKey: PublicKey = new Ed25519PublicKey(\n      keypair.publicKey,\n    ),\n    readonly subject: AccountAddress = new Ed25519PublicKey(\n      keypair.publicKey,\n    ).toString(),\n  ) {}\n\n  async sign(payload: Uint8Array): Promise<TokenSignerResult> {\n    const signature = nacl.sign.detached(payload, this.keypair.secretKey);\n    return {\n      signature,\n      payload,\n    };\n  }\n}\n","import nacl from 'tweetnacl';\n\nexport function generateEd25519Keypair() {\n  return nacl.sign.keyPair.fromSeed(Uint8Array.from(nacl.randomBytes(32)));\n}\n","import type { AddressType, DappAddress } from '../address/addresses.interface';\nimport type {\n  NotificationConfig,\n  NotificationSubscription,\n  NotificationType,\n} from '../wallet/wallet.interface';\nimport type { AccountAddress } from '../auth/auth.interface';\n\nexport interface Dapps {\n  create(command: CreateDappCommand): Promise<Dapp>;\n\n  patch(command: PatchDappCommand): Promise<Dapp>;\n\n  find(query?: FindOneDappQuery): Promise<Dapp | null>;\n\n  findAll(query?: FindDappQuery): Promise<ReadOnlyDapp[]>;\n}\n\nexport enum BlockchainType {\n  SOLANA = 'SOLANA',\n  APTOS = 'APTOS',\n  EVM = 'EVM',\n}\n\nexport interface Dapp {\n  id: string;\n  address: AccountAddress;\n  name: string;\n  description?: string;\n  websiteUrl?: string;\n  avatarUrl?: string;\n  heroUrl?: string;\n  verified: boolean;\n  telegramUsername: string;\n  blockchainType: BlockchainType;\n  dappAddresses: DappAddresses;\n  messages: DappMessages;\n  notificationTypes: DappNotificationTypes;\n  notificationSubscriptions: DappNotificationSubscriptions;\n}\n\nexport type ReadOnlyDapp = Omit<\n  Dapp,\n  | 'dappAddresses'\n  | 'messages'\n  | 'notificationTypes'\n  | 'notificationSubscriptions'\n>;\n\nexport interface DappAddresses {\n  findAll(): Promise<DappAddress[]>;\n}\n\nexport interface DappMessages {\n  send(command: SendDappMessageCommand): Promise<void>;\n}\n\nexport interface CreateDappCommand {\n  name: string;\n  description?: string;\n  websiteUrl?: string;\n  avatarUrl?: string;\n  heroUrl?: string;\n  telegramBotConfiguration?: DappTelegramBotConfiguration;\n  blockchainType: BlockchainType;\n}\n\nexport interface PatchDappCommand {\n  name?: string;\n  description?: string | null;\n  websiteUrl?: string | null;\n  avatarUrl?: string | null;\n  heroUrl?: string | null;\n}\n\nexport interface DappTelegramBotConfiguration {\n  token: string;\n}\n\nexport interface FindOneDappQuery {\n  address?: AccountAddress;\n}\n\nexport interface FindDappQuery {\n  verified?: boolean;\n  blockchainType?: BlockchainType;\n}\n\nexport enum DappMessageActionType {\n  LINK = 'Link',\n  SMART_MESSAGE = 'SmartMessage',\n}\n\ninterface DappMessageActionBase {\n  type: DappMessageActionType;\n}\n\nexport interface DappMessageLinksAction extends DappMessageActionBase {\n  type: DappMessageActionType.LINK;\n  links: [DappMessageLinkAction];\n}\nexport interface DappMessageLinkAction {\n  label: string;\n  url: string;\n}\n\nexport interface DappMessageSmartMessageAction extends DappMessageActionBase {\n  type: DappMessageActionType.SMART_MESSAGE;\n  smartMessage: SmartMessage;\n}\n\nexport interface SmartMessage {\n  transactionServiceId: string;\n  transactionParams: SmartMessageParams;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface SmartMessageParams {}\n\nexport interface SendDappMessageCommandBase {\n  message: string;\n  title?: string;\n  imageUrl?: string;\n  notificationTypeId?: string;\n  addressTypes?: AddressType[];\n  // tags?: string[];\n}\n\nexport interface BroadcastDappMessageCommand\n  extends SendDappMessageCommandBase {\n  actionsV2?: DappMessageLinksAction;\n}\n\nexport interface UnicastDappMessageCommand extends SendDappMessageCommandBase {\n  recipient: AccountAddress;\n  actionsV2?: DappMessageLinksAction | DappMessageSmartMessageAction;\n}\n\nexport interface MulticastDappMessageCommand\n  extends SendDappMessageCommandBase {\n  recipients: AccountAddress[];\n  actionsV2?: DappMessageLinksAction;\n}\n\nexport type SendDappMessageCommand =\n  | BroadcastDappMessageCommand\n  | UnicastDappMessageCommand\n  | MulticastDappMessageCommand;\n\nexport interface DappNotificationTypes {\n  create(command: CreateNotificationTypeCommand): Promise<NotificationType>;\n\n  findAll(): Promise<NotificationType[]>;\n\n  find(id: string): Promise<NotificationType>;\n\n  patch(\n    id: string,\n    command: PatchNotificationTypeCommand,\n  ): Promise<NotificationType>;\n\n  delete(id: string): Promise<void>;\n}\n\nexport interface CreateNotificationTypeCommand {\n  name: string;\n  humanReadableId: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags?: string[];\n  defaultConfig: NotificationConfig;\n}\n\nexport interface PatchNotificationTypeCommand {\n  name?: string;\n  humanReadableId?: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags?: string[];\n  defaultConfig?: NotificationConfig;\n}\n\nexport interface DappNotificationSubscriptions {\n  findAll(): Promise<DappNotificationSubscription[]>;\n}\n\nexport class DappNotificationSubscription {\n  notificationType!: NotificationType;\n  subscriptions!: NotificationSubscription[];\n}\n","import type { DiffeHellmanKeys } from './encryption.interface';\nimport type { AccountAddress } from '../auth/auth.interface';\n\nexport abstract class EncryptionKeysStore {\n  static createInMemory(): EncryptionKeysStore {\n    return new InmemoryEncryptionKeysStore();\n  }\n\n  static createSessionStorage(): EncryptionKeysStore {\n    return new SessionStorageEncryptionKeysStore();\n  }\n\n  static createLocalStorage(): EncryptionKeysStore {\n    return new LocalStorageEncryptionKeysStore();\n  }\n\n  abstract get(subject: AccountAddress): DiffeHellmanKeys | null;\n\n  abstract save(\n    subject: AccountAddress,\n    keys: DiffeHellmanKeys,\n  ): DiffeHellmanKeys;\n}\n\nclass InmemoryEncryptionKeysStore extends EncryptionKeysStore {\n  private keys: Record<AccountAddress, DiffeHellmanKeys> = {};\n\n  get(subject: AccountAddress): DiffeHellmanKeys | null {\n    return this.keys[subject.toString()] ?? null;\n  }\n\n  save(subject: AccountAddress, keys: DiffeHellmanKeys): DiffeHellmanKeys {\n    this.keys[subject.toString()] = keys;\n    return keys;\n  }\n}\n\nclass SessionStorageEncryptionKeysStore extends EncryptionKeysStore {\n  get(subject: AccountAddress): DiffeHellmanKeys | null {\n    const key = createStorageKey(subject.toString());\n    try {\n      const keys = sessionStorage.getItem(key);\n      if (!keys) {\n        return null;\n      }\n      return deserializeDiffeHellmanKeys(keys);\n    } catch {\n      sessionStorage.removeItem(key);\n      return null;\n    }\n  }\n\n  save(subject: AccountAddress, keys: DiffeHellmanKeys): DiffeHellmanKeys {\n    sessionStorage.setItem(\n      createStorageKey(subject.toString()),\n      serializeDiffeHellmanKeys(keys),\n    );\n    return keys;\n  }\n}\n\nclass LocalStorageEncryptionKeysStore extends EncryptionKeysStore {\n  get(subject: AccountAddress): DiffeHellmanKeys | null {\n    const key = createStorageKey(subject.toString());\n    try {\n      const keys = localStorage.getItem(key);\n      if (!keys) {\n        return null;\n      }\n      return deserializeDiffeHellmanKeys(keys) as DiffeHellmanKeys;\n    } catch {\n      localStorage.removeItem(key);\n      return null;\n    }\n  }\n\n  save(subject: AccountAddress, keys: DiffeHellmanKeys): DiffeHellmanKeys {\n    localStorage.setItem(\n      createStorageKey(subject.toString()),\n      serializeDiffeHellmanKeys(keys),\n    );\n    return keys;\n  }\n}\n\n// #region json storage\n\nconst storageEncryptionKeysPrefix = 'dialect-encryption-keys';\n\nfunction createStorageKey(subject: string) {\n  return `${storageEncryptionKeysPrefix}-${subject}`;\n}\n\ninterface DiffeHellmanKeysSerializable {\n  version: 1;\n  keys: {\n    publicKey: number[];\n    secretKey: number[];\n  };\n}\n\nexport function serializeDiffeHellmanKeys(keys: DiffeHellmanKeys): string {\n  const toSerialize: DiffeHellmanKeysSerializable = {\n    version: 1,\n    keys: {\n      publicKey: Array.from(keys.publicKey),\n      secretKey: Array.from(keys.secretKey),\n    },\n  };\n\n  return JSON.stringify(toSerialize);\n}\n\nexport function deserializeDiffeHellmanKeys(data: string): DiffeHellmanKeys {\n  const deserialized = JSON.parse(data) as DiffeHellmanKeysSerializable;\n  return {\n    publicKey: Uint8Array.from(deserialized.keys.publicKey),\n    secretKey: Uint8Array.from(deserialized.keys.secretKey),\n  };\n}\n\n// #endregion\n","import { UnsupportedOperationError } from '../sdk/errors';\nimport { EncryptionKeysStore } from './encryption-keys-store';\nimport type { DiffeHellmanKeys } from './encryption.interface';\nimport type { AccountAddress } from '../auth/auth.interface';\n\nexport abstract class EncryptionKeysProvider {\n  static create(\n    delegate: EncryptionKeysProvider,\n    encryptionKeysStore: EncryptionKeysStore = EncryptionKeysStore.createInMemory(),\n  ): EncryptionKeysProvider {\n    return new CachedEncryptionKeysProvider(delegate, encryptionKeysStore);\n  }\n\n  abstract isAvailable(): boolean;\n\n  abstract getFailSafe(\n    subject: AccountAddress,\n  ): Promise<DiffeHellmanKeys | null>;\n\n  abstract getFailFast(subject: AccountAddress): Promise<DiffeHellmanKeys>;\n}\n\nclass CachedEncryptionKeysProvider extends EncryptionKeysProvider {\n  private readonly delegateGetPromises: Record<\n    AccountAddress,\n    Promise<DiffeHellmanKeys | null>\n  > = {};\n\n  constructor(\n    private readonly delegate: EncryptionKeysProvider,\n    private readonly encryptionKeysStore: EncryptionKeysStore,\n  ) {\n    super();\n  }\n\n  isAvailable(): boolean {\n    return this.delegate.isAvailable();\n  }\n\n  async getFailSafe(subject: AccountAddress): Promise<DiffeHellmanKeys | null> {\n    const existingKeys = this.encryptionKeysStore.get(subject);\n    if (existingKeys) {\n      delete this.delegateGetPromises[subject.toString()];\n      return existingKeys;\n    }\n    const existingDelegatePromise =\n      this.delegateGetPromises[subject.toString()];\n    if (existingDelegatePromise) {\n      return existingDelegatePromise;\n    }\n    const delegatePromise = this.delegate\n      .getFailSafe(subject)\n      .then((it) => it && this.encryptionKeysStore.save(subject, it));\n\n    // delete promise to refetch the token in case of failure\n    delegatePromise.catch(() => {\n      delete this.delegateGetPromises[subject.toString()];\n    });\n\n    this.delegateGetPromises[subject.toString()] = delegatePromise;\n    return delegatePromise;\n  }\n\n  async getFailFast(subject: AccountAddress): Promise<DiffeHellmanKeys> {\n    return this.getFailSafe(subject).then((keys) => {\n      if (!keys) {\n        throw new UnsupportedOperationError(\n          'Encryption not supported',\n          'Wallet does not support encryption, please use wallet-adapter that supports diffieHellman() operation.',\n        );\n      }\n      return keys;\n    });\n  }\n}\n","import type { AccountAddress } from '../auth/auth.interface';\nimport type { SmartMessageDto } from '../dialect-cloud-api/smart-message.dto';\n\nexport interface Messaging {\n  type: string;\n\n  findAll(): Promise<Thread[]>;\n\n  create(command: CreateThreadCommand): Promise<Thread>;\n\n  find(query: FindThreadQuery): Promise<Thread | null>;\n\n  findSummary(\n    query: FindThreadByOtherMemberQuery,\n  ): Promise<ThreadSummary | null>;\n\n  findSummaryAll(): Promise<ThreadsGeneralSummary | null>;\n}\n\nexport interface ThreadsGeneralSummary {\n  unreadMessagesCount: number;\n}\n\nexport interface ThreadSummary {\n  id: ThreadId;\n  me: ThreadMemberSummary;\n}\n\nexport interface ThreadMemberSummary {\n  address: AccountAddress;\n  hasUnreadMessages: boolean;\n  unreadMessagesCount: number;\n}\n\nexport interface SendMessageCommand {\n  text: string;\n  deduplicationId?: string;\n}\n\nexport interface MessageAction {\n  label: string;\n  url: string;\n}\n\nexport interface MessageMetadata {\n  title?: string;\n  // tags?: string[];\n  actions?: MessageAction[];\n  smartMessage?: SmartMessageDto;\n  notificationTypeId?: string;\n  notificationTypeHumanReadableId?: string;\n}\n\nexport interface ThreadMessage {\n  id: string;\n  text: string;\n  timestamp: Date;\n  author: ThreadMember;\n  metadata?: MessageMetadata;\n  deduplicationId?: string;\n}\n\nexport interface CreateThreadCommand {\n  me: Omit<ThreadMember, 'address' | 'lastReadMessageTimestamp'>;\n  otherMembers: Omit<ThreadMember, 'lastReadMessageTimestamp'>[];\n  encrypted: boolean;\n  type?: string;\n}\n\nexport interface AddMembersCommand {\n  members: Omit<ThreadMember, 'lastReadMessageTimestamp'>[];\n}\n\nexport type FindThreadQuery =\n  | FindThreadByIdQuery\n  | FindThreadByOtherMemberQuery;\n\nexport interface FindThreadByIdQuery {\n  id: ThreadId;\n}\n\nexport interface FindThreadByOtherMemberQuery {\n  otherMembers: AccountAddress[];\n}\n\nexport interface FindThreadSummaryByMembers {\n  me: AccountAddress;\n  otherMembers: AccountAddress[];\n}\n\nexport interface ThreadIdProps {\n  address: AccountAddress;\n  type?: string;\n}\n\nexport class ThreadId {\n  readonly address!: AccountAddress;\n  readonly type?: string;\n\n  constructor({ address, type }: ThreadIdProps) {\n    this.address = address;\n    this.type = type;\n  }\n\n  public equals(other: ThreadId): boolean {\n    return this.address == other.address && this.type === other.type;\n  }\n\n  public toString(): string {\n    return this.type\n      ? this.type.toString() + ':' + this.address.toString()\n      : this.address.toString();\n  }\n}\n\nexport interface Thread {\n  id: ThreadId;\n  me: ThreadMember;\n  otherMembers: ThreadMember[];\n  encryptionEnabled: boolean;\n  canBeDecrypted: boolean;\n  type: string;\n  updatedAt: Date;\n  lastMessage: ThreadMessage | null;\n  name?: string;\n\n  messages(): Promise<ThreadMessage[]>;\n\n  send(command: SendMessageCommand): Promise<void>;\n\n  delete(): Promise<void>;\n\n  markAsRead(): Promise<void>;\n\n  addMembers(command: AddMembersCommand): Promise<void>;\n\n  removeMember(address: AccountAddress): Promise<void>;\n\n  rename(name: string): Promise<void>;\n}\n\nexport interface ThreadMember {\n  address: AccountAddress;\n  scopes: ThreadMemberScope[];\n  // lastReadMessageTimestamp: Date;\n}\n\nexport enum ThreadMemberScope {\n  WRITE = 'WRITE',\n  ADMIN = 'ADMIN',\n}\n","import { DialectSdkError } from '../sdk/errors';\n\nexport abstract class MessagingError extends DialectSdkError {}\n\nexport class ThreadAlreadyExistsError extends MessagingError {\n  constructor() {\n    super(\n      ThreadAlreadyExistsError.name,\n      'Error',\n      'You already have chat with this address',\n    );\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\nimport type { SmartMessageDto } from './smart-message.dto';\nexport interface DataServiceDialectsApi {\n  create(command: CreateDialectCommand): Promise<DialectAccountDto>;\n\n  findAll(): Promise<DialectAccountDto[]>;\n\n  find(dialectId: string): Promise<DialectAccountDto>;\n\n  findByMembers(\n    query: FindDialectByMembersQueryDto,\n  ): Promise<DialectAccountDto>;\n\n  delete(dialectId: string): Promise<void>;\n\n  sendMessage(dialectId: string, command: SendMessageCommand): Promise<void>;\n\n  getMessages(dialectId: string): Promise<MessagesDto>;\n\n  findSummary(query: FindDialectByMembersQueryDto): Promise<DialectSummaryDto>;\n\n  findSummaryAll(query: FindDialectsSummaryDto): Promise<DialectsSummaryDto>;\n\n  patch(\n    dialectId: string,\n    command: PatchDialectCommand,\n  ): Promise<DialectAccountDto>;\n\n  addMembers(dialectId: string, members: AddMembersCommand): Promise<void>;\n\n  removeMember(dialectId: string, memberAddress: string): Promise<void>;\n\n  markAsRead(dialectId: string): Promise<void>;\n}\n\nexport class DataServiceDialectsApiClient implements DataServiceDialectsApi {\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async markAsRead(dialectId: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v2/dialects/${dialectId}/markAsRead`,\n          {},\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async create(command: CreateDialectCommand): Promise<DialectAccountDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<DialectAccountDto>(`${this.baseUrl}/api/v2/dialects`, command, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async findAll(): Promise<DialectAccountDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectAccountDto[]>(`${this.baseUrl}/api/v2/dialects`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async find(id: string): Promise<DialectAccountDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectAccountDto>(`${this.baseUrl}/api/v2/dialects/${id}`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async findByMembers(\n    query: FindDialectByMembersQueryDto,\n  ): Promise<DialectAccountDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectAccountDto>(\n          `${this.baseUrl}/api/v2/dialects/search/byMembers`,\n          {\n            headers: createHeaders(token),\n            params: query,\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async delete(id: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .delete<void>(`${this.baseUrl}/api/v2/dialects/${id}`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async patch(\n    id: string,\n    command: PatchDialectCommand,\n  ): Promise<DialectAccountDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .patch<DialectAccountDto>(\n          `${this.baseUrl}/api/v2/dialects/${id}`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async sendMessage(id: string, command: SendMessageCommand): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(`${this.baseUrl}/api/v2/dialects/${id}/messages`, command, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async getMessages(id: string): Promise<MessagesDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<MessagesDto>(`${this.baseUrl}/api/v2/dialects/${id}/messages`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  findSummary(query: FindDialectByMembersQueryDto): Promise<DialectSummaryDto> {\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectSummaryDto>(`${this.baseUrl}/api/v2/dialects/summary`, {\n          headers: createHeaders(),\n          ...(query && { params: query }),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  findSummaryAll(query: FindDialectsSummaryDto): Promise<DialectsSummaryDto> {\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectsSummaryDto>(\n          `${this.baseUrl}/api/v2/dialects/summary/all`,\n          {\n            headers: createHeaders(),\n            params: query,\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async addMembers(\n    dialectId: string,\n    members: AddMembersCommand,\n  ): Promise<void> {\n    const token = await this.tokenProvider.get();\n    await withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v2/dialects/${dialectId}/members`,\n          members,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async removeMember(dialectId: string, memberAddress: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    await withReThrowingDataServiceError(\n      axios\n        .delete<void>(\n          `${this.baseUrl}/api/v2/dialects/${dialectId}/members/${memberAddress}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n\nexport interface CreateDialectCommand {\n  readonly members: PostMemberDto[];\n  readonly encrypted: boolean;\n}\n\nexport interface AddMembersCommand {\n  readonly members: PostMemberDto[];\n}\n\nexport interface PostMemberDto {\n  readonly address: string;\n  readonly scopes: MemberScopeDto[];\n}\n\nexport interface DialectAccountDto {\n  readonly id: string;\n  readonly dialect: DialectDto;\n}\n\nexport interface DialectDto {\n  readonly members: MemberDto[];\n  readonly lastMessage?: MessageDto;\n  readonly updatedAt: number;\n  readonly encrypted: boolean;\n  readonly groupName?: string;\n}\n\nexport interface MemberDto {\n  readonly address: string;\n  readonly scopes: MemberScopeDto[];\n  readonly lastReadMessageTimestamp: number;\n}\n\nexport enum MemberScopeDto {\n  ADMIN = 'ADMIN',\n  WRITE = 'WRITE',\n}\n\nexport class MessageActionDto {\n  label!: string;\n  url!: string;\n}\nexport class MessageMetadataDto {\n  title?: string;\n  tags?: string[];\n  actions?: MessageActionDto[];\n  smartMessage?: SmartMessageDto;\n  notificationTypeId?: string;\n}\n\nexport interface MessageDto {\n  readonly id: string;\n  readonly owner: string;\n  readonly text: number[];\n  readonly timestamp: number;\n  readonly deduplicationId?: string;\n  readonly metadata?: MessageMetadataDto;\n}\n\nexport interface MessagesDto {\n  readonly messages: MessageDto[];\n}\n\nexport interface SendMessageCommand {\n  readonly text: number[];\n  readonly deduplicationId?: string;\n}\n\nexport interface PatchDialectCommand {\n  readonly groupName: string;\n}\n\nexport interface DialectSummaryDto {\n  readonly id: string;\n  readonly memberSummaries: MemberSummaryDto[];\n}\n\nexport interface DialectsSummaryDto {\n  readonly unreadMessagesCount: number;\n}\n\nexport interface MemberSummaryDto {\n  readonly address: string;\n  readonly hasUnreadMessages: boolean;\n  readonly unreadMessagesCount: number;\n}\n\nexport interface FindDialectByMembersQueryDto {\n  readonly memberAddresses: string[];\n}\n\nexport interface FindDialectsSummaryDto {\n  readonly address: string;\n}\n","import { DialectSdkError } from '../sdk/errors';\n\nexport abstract class DialectCloudError extends DialectSdkError {}\n\nexport class DialectCloudUnreachableError extends DialectCloudError {\n  constructor(details?: any[]) {\n    super(\n      DialectCloudUnreachableError.name,\n      'Lost connection to Dialect Cloud',\n      'Having problems reaching Dialect Cloud. Please try again later.',\n      details,\n    );\n  }\n}\n","import {\n  AuthenticationError,\n  AuthorizationError,\n  BusinessConstraintViolationError,\n  DialectSdkError,\n  IllegalArgumentError,\n  ResourceAlreadyExistsError,\n  ResourceNotFoundError,\n  UnknownError,\n} from '../sdk/errors';\nimport { DataServiceApiError, NetworkError } from './data-service-api';\nimport { DialectCloudUnreachableError } from '../internal/errors';\n\nexport async function withErrorParsing<T>(\n  promise: Promise<T>,\n  onResourceAlreadyExists: (e: DataServiceApiError) => DialectSdkError = (e) =>\n    new ResourceAlreadyExistsError(createMessage(e)),\n): Promise<T> {\n  try {\n    return await promise;\n  } catch (e) {\n    if (e instanceof NetworkError) {\n      throw new DialectCloudUnreachableError([e]);\n    }\n    if (e instanceof DataServiceApiError) {\n      if (e.statusCode === 400) {\n        console.error(e);\n        throw new IllegalArgumentError(createMessage(e));\n      }\n      if (e.statusCode === 401) {\n        throw new AuthenticationError(createMessage(e));\n      }\n      if (e.statusCode === 403) {\n        throw new AuthorizationError(createMessage(e));\n      }\n      if (e.statusCode === 404) {\n        throw new ResourceNotFoundError(createMessage(e));\n      }\n      if (e.statusCode === 409) {\n        throw onResourceAlreadyExists(e);\n      }\n      if (e.statusCode === 422) {\n        throw new BusinessConstraintViolationError(createMessage(e));\n      }\n      console.error(e);\n      throw new UnknownError([e], createMessage(e));\n    }\n    console.error(e);\n    throw new UnknownError([e]);\n  }\n}\n\nfunction createMessage(e: DataServiceApiError) {\n  return `${e.message ?? e.error}`;\n}\n","import nacl from 'tweetnacl';\n\nexport const NONCE_SIZE_BYTES = 24;\n\n/**\n * Generates 24 byte nonce from message counter.\n * Sender and receiver should keep a counter of messages and increment it for each message.\n */\nexport function generateNonce(messageCounter: number): Uint8Array {\n  const nonce = new Uint8Array(Array(NONCE_SIZE_BYTES).fill(0));\n  let messageCounterModule = Math.abs(messageCounter);\n  let nonceByteIndex = 0;\n  while (messageCounterModule) {\n    nonce[nonceByteIndex++] = messageCounterModule % 10;\n    messageCounterModule = Math.floor(messageCounterModule / 10);\n  }\n  return nonce.reverse();\n}\n\nexport function generateRandomNonceWithPrefix(memberId: number) {\n  return new Uint8Array([memberId, ...nacl.randomBytes(NONCE_SIZE_BYTES - 1)]);\n}\n","import ed2curve from 'ed2curve';\nimport nacl from 'tweetnacl';\n\nexport const ENCRYPTION_OVERHEAD_BYTES = 16;\n\nexport class IncorrectPublicKeyFormatError extends Error {\n  constructor() {\n    super('IncorrectPublicKeyFormatError');\n  }\n}\n\nexport class AuthenticationFailedError extends Error {\n  constructor() {\n    super('Authentication failed during decryption attempt');\n  }\n}\n\nexport type Curve25519Key = Uint8Array;\n\nexport type Curve25519KeyPair = {\n  publicKey: Curve25519Key;\n  secretKey: Curve25519Key;\n};\n\nexport type Ed25519Key = Uint8Array;\n\nexport type Ed25519KeyPair = {\n  publicKey: Curve25519Key;\n  secretKey: Curve25519Key;\n};\n\nexport function ed25519KeyPairToCurve25519({\n  publicKey,\n  secretKey,\n}: Ed25519KeyPair): Curve25519KeyPair {\n  const curve25519KeyPair = ed2curve.convertKeyPair({\n    publicKey,\n    secretKey,\n  });\n  if (!curve25519KeyPair) {\n    throw new IncorrectPublicKeyFormatError();\n  }\n  return curve25519KeyPair;\n}\n\nexport function ed25519PublicKeyToCurve25519(key: Ed25519Key): Curve25519Key {\n  const curve25519PublicKey = ed2curve.convertPublicKey(key);\n  if (!curve25519PublicKey) {\n    throw new IncorrectPublicKeyFormatError();\n  }\n  return curve25519PublicKey;\n}\n\nexport function ecdhEncrypt(\n  payload: Uint8Array,\n  { secretKey, publicKey }: Curve25519KeyPair,\n  otherPartyPublicKey: Ed25519Key,\n  nonce: Uint8Array,\n): Uint8Array {\n  return nacl.box(\n    payload,\n    nonce,\n    ed25519PublicKeyToCurve25519(otherPartyPublicKey),\n    secretKey,\n  );\n}\n\nexport function ecdhDecrypt(\n  payload: Uint8Array,\n  { secretKey, publicKey }: Curve25519KeyPair,\n  otherPartyPublicKey: Ed25519Key,\n  nonce: Uint8Array,\n): Uint8Array {\n  const decrypted = nacl.box.open(\n    payload,\n    nonce,\n    ed25519PublicKeyToCurve25519(otherPartyPublicKey),\n    secretKey,\n  );\n  if (!decrypted) {\n    throw new AuthenticationFailedError();\n  }\n  return decrypted;\n}\n","import {\n  generateRandomNonceWithPrefix,\n  NONCE_SIZE_BYTES,\n} from './nonce-generator';\nimport {\n  Curve25519KeyPair,\n  ecdhDecrypt,\n  ecdhEncrypt,\n  Ed25519Key,\n} from './ecdh-encryption';\nimport type { PublicKey } from '../auth/auth.interface';\nimport { Ed25519PublicKey } from '../auth/ed25519/ed25519-public-key';\n\nexport interface TextSerde {\n  serialize(text: string): Uint8Array;\n\n  deserialize(bytes: Uint8Array): string;\n}\n\nexport class EncryptedTextSerde implements TextSerde {\n  private readonly unencryptedTextSerde: UnencryptedTextSerde =\n    new UnencryptedTextSerde();\n\n  constructor(\n    private readonly encryptionProps: EncryptionProps,\n    private readonly members: PublicKey[],\n  ) {}\n\n  deserialize(bytes: Uint8Array): string {\n    const encryptionNonce = bytes.slice(0, NONCE_SIZE_BYTES);\n    const encryptedText = bytes.slice(NONCE_SIZE_BYTES, bytes.length);\n    const otherMember = this.findOtherMember(\n      new Ed25519PublicKey(this.encryptionProps.ed25519PublicKey),\n    );\n    const encodedText = ecdhDecrypt(\n      encryptedText,\n      this.encryptionProps.diffieHellmanKeyPair,\n      otherMember.toBytes(),\n      encryptionNonce,\n    );\n    return this.unencryptedTextSerde.deserialize(encodedText);\n  }\n\n  serialize(text: string): Uint8Array {\n    const publicKey = new Ed25519PublicKey(\n      this.encryptionProps.ed25519PublicKey,\n    );\n    const senderMemberIdx = this.findMemberIdx(publicKey);\n    const textBytes = this.unencryptedTextSerde.serialize(text);\n    const otherMember = this.findOtherMember(publicKey);\n    const encryptionNonce = generateRandomNonceWithPrefix(senderMemberIdx);\n    const encryptedText = ecdhEncrypt(\n      textBytes,\n      this.encryptionProps.diffieHellmanKeyPair,\n      otherMember.toBytes(),\n      encryptionNonce,\n    );\n    return new Uint8Array([...encryptionNonce, ...encryptedText]);\n  }\n\n  private findMemberIdx(member: PublicKey) {\n    const memberIdx = this.members.findIndex((it) => it.equals(member));\n    if (memberIdx === -1) {\n      throw new Error('Expected to have other member');\n    }\n    return memberIdx;\n  }\n\n  private findOtherMember(member: PublicKey) {\n    const otherMember = this.members.find((it) => !it.equals(member));\n    if (!otherMember) {\n      throw new Error('Expected to have other member');\n    }\n    return otherMember;\n  }\n}\n\nexport class UnencryptedTextSerde implements TextSerde {\n  deserialize(bytes: Uint8Array): string {\n    return new TextDecoder().decode(bytes);\n  }\n\n  serialize(text: string): Uint8Array {\n    return new TextEncoder().encode(text);\n  }\n}\n\nexport interface EncryptionProps {\n  diffieHellmanKeyPair: Curve25519KeyPair;\n  ed25519PublicKey: Ed25519Key;\n}\n","export const DIALECT_API_TYPE_DIALECT_CLOUD = 'dialect-cloud';\n","import type {\n  AddMembersCommand,\n  CreateThreadCommand,\n  FindThreadByIdQuery,\n  FindThreadByOtherMemberQuery,\n  FindThreadQuery,\n  Messaging,\n  SendMessageCommand,\n  Thread,\n  ThreadMember,\n  ThreadMemberSummary,\n  ThreadMessage,\n  ThreadsGeneralSummary,\n  ThreadSummary,\n} from '../../messaging/messaging.interface';\nimport {\n  ThreadId,\n  ThreadMemberScope,\n} from '../../messaging/messaging.interface';\nimport type {\n  DataServiceDialectsApi,\n  DialectAccountDto,\n  DialectDto,\n} from '../../dialect-cloud-api/data-service-dialects-api';\nimport { MemberScopeDto } from '../../dialect-cloud-api/data-service-dialects-api';\nimport type { DataServiceApiClientError } from '../../dialect-cloud-api/data-service-api';\nimport {\n  IllegalStateError,\n  ResourceNotFoundError,\n  UnsupportedOperationError,\n} from '../../sdk/errors';\nimport type { EncryptionKeysProvider } from '../../encryption/encryption-keys-provider';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\nimport { ThreadAlreadyExistsError } from '../../messaging/errors';\nimport type { AccountAddress } from '../../auth/auth.interface';\nimport { Ed25519PublicKey } from '../../auth/ed25519/ed25519-public-key';\nimport type { EncryptionProps, TextSerde } from '../../messaging/text-serde';\nimport {\n  EncryptedTextSerde,\n  UnencryptedTextSerde,\n} from '../../messaging/text-serde';\nimport { DIALECT_API_TYPE_DIALECT_CLOUD } from '../../sdk/constants';\n\nexport class DataServiceMessaging implements Messaging {\n  readonly type = DIALECT_API_TYPE_DIALECT_CLOUD;\n\n  constructor(\n    private readonly me: AccountAddress,\n    private readonly dataServiceDialectsApi: DataServiceDialectsApi,\n    private readonly encryptionKeysProvider: EncryptionKeysProvider,\n  ) {}\n\n  async create(command: CreateThreadCommand): Promise<Thread> {\n    const otherMembers = requireAtLeastOneMember(command.otherMembers);\n    if (command.encrypted && otherMembers.length >= 2) {\n      throw new UnsupportedOperationError(\n        'Unsupported operation',\n        'Encryption not supported in group chats',\n      );\n    }\n    command.encrypted && (await this.checkEncryptionSupported());\n    const dialectAccountDto = await withErrorParsing(\n      this.dataServiceDialectsApi.create({\n        encrypted: command.encrypted,\n        members: [\n          {\n            address: this.me,\n            scopes: toDataServiceScopes(command.me.scopes),\n          },\n          ...otherMembers.map((e) => ({\n            address: e.address,\n            scopes: toDataServiceScopes(e.scopes),\n          })),\n        ],\n      }),\n      () => new ThreadAlreadyExistsError(),\n    );\n    return this.toDataServiceThread(dialectAccountDto);\n  }\n\n  async find(query: FindThreadQuery): Promise<Thread | null> {\n    const dialectAccountDto = await this.findInternal(query);\n    return dialectAccountDto && this.toDataServiceThread(dialectAccountDto);\n  }\n\n  async findAll(): Promise<Thread[]> {\n    const dialectAccountDtos = await withErrorParsing(\n      this.dataServiceDialectsApi.findAll(),\n    );\n    return Promise.all(\n      dialectAccountDtos.map((it) => this.toDataServiceThread(it)),\n    );\n  }\n\n  async findSummary(\n    query: FindThreadByOtherMemberQuery,\n  ): Promise<ThreadSummary | null> {\n    try {\n      const dialectSummaryDto = await withErrorParsing(\n        this.dataServiceDialectsApi.findSummary({\n          memberAddresses: [\n            this.me.toString(),\n            ...query.otherMembers.map((it) => it.toString()),\n          ],\n        }),\n      );\n      const meMember = dialectSummaryDto.memberSummaries.find(\n        (it) => it.address === this.me,\n      );\n      if (!meMember) {\n        throw new IllegalStateError(\n          `Cannot resolve member from given list: ${dialectSummaryDto.memberSummaries.map(\n            (it) => it.address,\n          )} and provided member public key ${this.me.toString()}`,\n        );\n      }\n      const meMemberSummary: ThreadMemberSummary = {\n        address: meMember.address,\n        hasUnreadMessages: meMember.hasUnreadMessages,\n        unreadMessagesCount: meMember.unreadMessagesCount,\n      };\n      return {\n        id: new ThreadId({\n          address: dialectSummaryDto.id,\n          type: this.type,\n        }),\n        me: meMemberSummary,\n      };\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n\n  async findSummaryAll(): Promise<ThreadsGeneralSummary> {\n    return await withErrorParsing(\n      this.dataServiceDialectsApi.findSummaryAll({\n        address: this.me,\n      }),\n    );\n  }\n\n  private checkEncryptionSupported() {\n    return this.encryptionKeysProvider.getFailFast(this.me);\n  }\n\n  private async toDataServiceThread(dialectAccountDto: DialectAccountDto) {\n    const { id, dialect } = dialectAccountDto;\n    const meMember = findMember(this.me, dialect);\n    const otherMembers = findOtherMembers(this.me, dialect);\n    if (!meMember || !otherMembers.length) {\n      throw new IllegalStateError(\n        `Cannot resolve members from given list: ${dialect.members.map(\n          (it) => it.address,\n        )} and wallet public key ${this.me.toString()}`,\n      );\n    }\n    const { serde, canBeDecrypted } = await this.createTextSerde(dialect);\n    const otherThreadMembers: ThreadMember[] = otherMembers.map((member) => ({\n      address: member.address,\n      scopes: fromDataServiceScopes(member.scopes),\n      // lastReadMessageTimestamp: new Date(), // TODO: implement\n    }));\n    const otherMembersPks = Object.fromEntries(\n      otherThreadMembers.map((member) => [member.address.toString(), member]),\n    );\n\n    const thisThreadMember: ThreadMember = {\n      address: meMember.address,\n      scopes: fromDataServiceScopes(meMember.scopes),\n      // lastReadMessageTimestamp: new Date(), // TODO: implement\n    };\n    const lastMessage = dialect.lastMessage ?? null;\n    let lastThreadMessage: ThreadMessage | null = null;\n    if (lastMessage != null) {\n      lastThreadMessage = {\n        id: lastMessage.id,\n        text: serde.deserialize(new Uint8Array(lastMessage.text)),\n        timestamp: new Date(lastMessage.timestamp),\n        author:\n          lastMessage.owner === this.me\n            ? thisThreadMember\n            : otherMembersPks[lastMessage.owner]!,\n        deduplicationId: lastMessage.deduplicationId,\n        metadata: lastMessage.metadata,\n      };\n    }\n\n    return new DataServiceThread(\n      this.dataServiceDialectsApi,\n      serde,\n      this.encryptionKeysProvider,\n      id,\n      thisThreadMember,\n      otherThreadMembers,\n      otherMembersPks,\n      dialect.encrypted,\n      canBeDecrypted,\n      new Date(dialect.updatedAt),\n      lastThreadMessage,\n      dialect.groupName,\n    );\n  }\n\n  private async createTextSerde(dialect: DialectDto): Promise<{\n    serde: TextSerde;\n    canBeDecrypted: boolean;\n  }> {\n    if (!dialect.encrypted) {\n      return {\n        serde: new UnencryptedTextSerde(),\n        canBeDecrypted: true,\n      };\n    }\n    const diffieHellmanKeyPair = await this.encryptionKeysProvider.getFailSafe(\n      this.me,\n    );\n    const encryptionProps: EncryptionProps | null = diffieHellmanKeyPair && {\n      diffieHellmanKeyPair,\n      ed25519PublicKey: new Ed25519PublicKey(this.me).toBytes(),\n    };\n    if (!encryptionProps) {\n      return {\n        serde: new UnencryptedTextSerde(),\n        canBeDecrypted: false,\n      };\n    }\n    return {\n      serde: new EncryptedTextSerde(\n        encryptionProps,\n        dialect.members.map((it) => new Ed25519PublicKey(it.address)),\n      ),\n      canBeDecrypted: true,\n    };\n  }\n\n  private findInternal(\n    query: FindThreadByIdQuery | FindThreadByOtherMemberQuery,\n  ) {\n    if ('id' in query) {\n      return this.findById(query);\n    }\n    return this.findByOtherMember(query);\n  }\n\n  private async findById(query: FindThreadByIdQuery) {\n    try {\n      return await withErrorParsing(\n        this.dataServiceDialectsApi.find(query.id.address.toString()),\n      );\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n\n  private async findByOtherMember(query: FindThreadByOtherMemberQuery) {\n    const otherMembers = requireAtLeastOneMember(query.otherMembers);\n    try {\n      return await withErrorParsing(\n        this.dataServiceDialectsApi.findByMembers({\n          memberAddresses: otherMembers.map((member) => member.toString()),\n        }),\n      );\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n}\n\nexport class DataServiceThread implements Thread {\n  readonly type = DIALECT_API_TYPE_DIALECT_CLOUD;\n  readonly id: ThreadId;\n\n  constructor(\n    private readonly dataServiceDialectsApi: DataServiceDialectsApi,\n    private readonly textSerde: TextSerde,\n    private readonly encryptionKeysProvider: EncryptionKeysProvider,\n    private readonly address: AccountAddress,\n    readonly me: ThreadMember,\n    readonly otherMembers: ThreadMember[],\n    private readonly otherMembersPks: Record<string, ThreadMember>,\n    readonly encryptionEnabled: boolean,\n    readonly canBeDecrypted: boolean,\n    public updatedAt: Date,\n    public lastMessage: ThreadMessage | null,\n    public name?: string,\n  ) {\n    this.id = new ThreadId({\n      type: this.type,\n      address,\n    });\n  }\n\n  async delete(): Promise<void> {\n    await withErrorParsing(\n      this.dataServiceDialectsApi.delete(this.address.toString()),\n    );\n  }\n\n  async messages(): Promise<ThreadMessage[]> {\n    const { dialect } = await withErrorParsing(\n      this.dataServiceDialectsApi.find(this.address.toString()),\n    );\n    this.updatedAt = new Date(dialect.updatedAt);\n    if (this.encryptionEnabledButCannotBeUsed()) {\n      return [];\n    }\n    const { messages } = await withErrorParsing(\n      this.dataServiceDialectsApi.getMessages(this.address.toString()),\n    );\n    const threadMessages: ThreadMessage[] = messages.map((it) => ({\n      id: it.id,\n      author:\n        it.owner === this.me.address.toString()\n          ? this.me\n          : this.otherMembersPks[it.owner]!,\n      timestamp: new Date(it.timestamp),\n      text: this.textSerde.deserialize(new Uint8Array(it.text)),\n      deduplicationId: it.deduplicationId,\n      metadata: it.metadata,\n    }));\n    this.lastMessage = threadMessages[0] ?? null;\n    return threadMessages;\n  }\n\n  async send(command: SendMessageCommand): Promise<void> {\n    if (this.encryptionEnabledButCannotBeUsed()) {\n      throw new UnsupportedOperationError(\n        'Encryption not supported',\n        'Please use encryption keys provider that supports encryption.',\n      );\n    }\n    await withErrorParsing(\n      this.dataServiceDialectsApi.sendMessage(this.address.toString(), {\n        text: Array.from(this.textSerde.serialize(command.text)),\n        deduplicationId: command.deduplicationId,\n      }),\n    );\n  }\n\n  async markAsRead(): Promise<void> {\n    await withErrorParsing(\n      this.dataServiceDialectsApi.markAsRead(this.id.address.toString()),\n    );\n  }\n\n  async addMembers(command: AddMembersCommand): Promise<void> {\n    const members = requireAtLeastOneMember(command.members);\n    await withErrorParsing(\n      this.dataServiceDialectsApi.addMembers(this.id.address.toString(), {\n        members: members.map((e) => ({\n          address: e.address,\n          scopes: toDataServiceScopes(e.scopes),\n        })),\n      }),\n      () => new ThreadAlreadyExistsError(),\n    );\n  }\n\n  async removeMember(address: AccountAddress): Promise<void> {\n    await withErrorParsing(\n      this.dataServiceDialectsApi.removeMember(\n        this.id.address.toString(),\n        address,\n      ),\n      () => new ThreadAlreadyExistsError(),\n    );\n  }\n\n  async rename(name: string): Promise<void> {\n    await withErrorParsing(\n      this.dataServiceDialectsApi.patch(this.id.address.toString(), {\n        groupName: name,\n      }),\n    );\n  }\n\n  private encryptionEnabledButCannotBeUsed() {\n    return this.encryptionEnabled && !this.canBeDecrypted;\n  }\n}\n\nfunction fromDataServiceScopes(scopes: MemberScopeDto[]) {\n  return scopes.map((it) => ThreadMemberScope[it]);\n}\n\nfunction toDataServiceScopes(scopes: ThreadMemberScope[]) {\n  return scopes.map((it) => MemberScopeDto[it]);\n}\n\nfunction findMember(memberPk: AccountAddress, dialect: DialectDto) {\n  return dialect.members.find((it) => memberPk === it.address) ?? null;\n}\n\nfunction findOtherMembers(memberPk: AccountAddress, dialect: DialectDto) {\n  return dialect.members.filter((it) => memberPk !== it.address);\n}\n\nfunction requireAtLeastOneMember<T>(members: T[]) {\n  if (members.length < 1) {\n    throw new UnsupportedOperationError(\n      'Unsupported operation',\n      'At least one member should be specified',\n    );\n  }\n  return members;\n}\n","import {\n  type BroadcastDappMessageCommand,\n  DappMessageActionType,\n  type DappMessageLinksAction,\n  type DappMessages,\n  type DappMessageSmartMessageAction,\n  type MulticastDappMessageCommand,\n  type SendDappMessageCommand,\n  type UnicastDappMessageCommand,\n} from '../../dapp/dapp.interface';\nimport { toAddressTypeDto } from '../../address/addresses.interface';\nimport {\n  DappMessageActionTypeDto,\n  DappMessageLinksActionDto,\n  DappMessageSmartMessageActionDto,\n  type DataServiceDappsApi,\n} from '../../dialect-cloud-api/data-service-dapps-api';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\n\nexport class DataServiceDappMessages implements DappMessages {\n  constructor(private readonly api: DataServiceDappsApi) {\n  }\n\n  async send(command: SendDappMessageCommand): Promise<void> {\n    if (command.addressTypes?.length === 0) {\n      return;\n    }\n    if ('recipient' in command) {\n      return this.unicast(command);\n    }\n    if ('recipients' in command) {\n      return this.multicast(command);\n    }\n    return this.broadcast(command);\n  }\n\n  private async unicast(command: UnicastDappMessageCommand) {\n\n\n    const actionsV2Dto = this.getActionsV2DtoForUnicast(command.actionsV2);\n    return withErrorParsing(\n      this.api.unicast({\n        message: command.message,\n        title: command.title,\n        imageUrl: command.imageUrl,\n        notificationTypeId: command.notificationTypeId,\n        recipientPublicKey: command.recipient.toString(),\n        addressTypes: command?.addressTypes?.map((addr) =>\n          toAddressTypeDto(addr),\n        ),\n        actionsV2: actionsV2Dto,\n      }),\n    );\n  }\n\n  private getActionsV2DtoForUnicast(actions?: DappMessageLinksAction | DappMessageSmartMessageAction): DappMessageLinksActionDto | DappMessageSmartMessageActionDto | undefined {\n    if (!actions?.type) {\n      return;\n    }\n    if (actions.type === DappMessageActionType.LINK) {\n      return {\n        type: DappMessageActionTypeDto.LINK,\n        links: actions.links.map((link) => ({\n          label: link.label,\n          url: link.url,\n        })),\n      };\n    }\n    if (actions.type === DappMessageActionType.SMART_MESSAGE) {\n      return {\n        type: DappMessageActionTypeDto.SMART_MESSAGE,\n        smartMessage: {\n          transactionServiceId: actions.smartMessage.transactionServiceId,\n          transactionParams: actions.smartMessage.transactionParams,\n        },\n      };\n    }\n  }\n\n  private async multicast(command: MulticastDappMessageCommand) {\n    if (command.recipients.length === 0) {\n      return;\n    }\n    return withErrorParsing(\n      this.api.multicast({\n        message: command.message,\n        title: command.title,\n        imageUrl: command.imageUrl,\n        actionsV2: this.getActionsV2DtoForLinks(command.actionsV2),\n        notificationTypeId: command.notificationTypeId,\n        recipientPublicKeys: command.recipients.map((it) => it.toString()),\n        addressTypes: command?.addressTypes?.map((addr) =>\n          toAddressTypeDto(addr),\n        ),\n      }),\n    );\n  }\n\n  private async broadcast(command: BroadcastDappMessageCommand) {\n    return withErrorParsing(\n      this.api.broadcast({\n        message: command.message,\n        title: command.title,\n        imageUrl: command.imageUrl,\n        actionsV2: this.getActionsV2DtoForLinks(command.actionsV2),\n        notificationTypeId: command.notificationTypeId,\n        addressTypes: command?.addressTypes?.map((addr) =>\n          toAddressTypeDto(addr),\n        ),\n      }),\n    );\n  }\n\n  private getActionsV2DtoForLinks(actions?: DappMessageLinksAction): DappMessageLinksActionDto | undefined {\n    if (!actions?.type) {\n      return;\n    }\n    return {\n      type: DappMessageActionTypeDto.LINK,\n      links: actions.links.map((link) => ({\n        label: link.label,\n        url: link.url,\n      })),\n    };\n  }\n}\n","import type {\n  DappNotificationSubscription,\n  DappNotificationSubscriptions,\n} from '../../dapp/dapp.interface';\nimport type { DataServiceDappNotificationSubscriptionsApi } from '../../dialect-cloud-api/data-service-dapp-notification-subscriptions-api';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\n\nexport class DataServiceDappNotificationSubscriptions\n  implements DappNotificationSubscriptions\n{\n  constructor(\n    private readonly api: DataServiceDappNotificationSubscriptionsApi,\n  ) {}\n\n  async findAll(): Promise<DappNotificationSubscription[]> {\n    const dtos = await withErrorParsing(this.api.findAll());\n    return dtos.map((it) => ({\n      ...it,\n      subscriptions: it.subscriptions.map((it) => ({\n        ...it,\n        wallet: {\n          ...it.wallet,\n          address: it.wallet.publicKey,\n        },\n      })),\n    }));\n  }\n}\n","import type {\n  DappMessages,\n  SendDappMessageCommand,\n} from '../../dapp/dapp.interface';\nimport { DialectSdkError, IllegalArgumentError } from '../../sdk/errors';\n\nexport class DappMessagesFacade implements DappMessages {\n  constructor(private readonly dappMessageBackends: DappMessages[]) {\n    if (dappMessageBackends.length < 1) {\n      throw new IllegalArgumentError(\n        'Expected to have at least one dapp message backend.',\n      );\n    }\n  }\n\n  async send(command: SendDappMessageCommand): Promise<void> {\n    const allSettled = await Promise.allSettled(\n      this.dappMessageBackends.map((it) => it.send(command)),\n    );\n    const errors = allSettled\n      .filter((it) => it.status === 'rejected')\n      .map((it) => it as PromiseRejectedResult)\n      .map((it) => it.reason as DialectSdkError);\n    if (errors.length > 0) {\n      console.error(\n        `Error during sending dapp messages: ${errors.map((it) =>\n          JSON.stringify(it),\n        )}`,\n      );\n    }\n    const fulfilled = allSettled.filter((it) => it.status === 'fulfilled');\n    if (errors.length > 0 && fulfilled.length === 0) {\n      const error: DialectSdkError = {\n        ...errors[0]!,\n        details: errors,\n      };\n      throw error;\n    }\n  }\n}\n","import type { DataServiceApiClientError } from '../../dialect-cloud-api/data-service-api';\nimport type {\n  DappDto,\n  DataServiceDappsApi,\n} from '../../dialect-cloud-api/data-service-dapps-api';\nimport { ResourceNotFoundError } from '../../sdk/errors';\nimport type {\n  BlockchainType,\n  CreateDappCommand,\n  Dapp,\n  DappAddresses,\n  DappMessages,\n  DappNotificationSubscriptions,\n  DappNotificationTypes,\n  Dapps,\n  FindDappQuery,\n  FindOneDappQuery,\n  PatchDappCommand,\n  ReadOnlyDapp,\n} from '../../dapp/dapp.interface';\nimport type { DataServiceDappNotificationTypes } from './data-service-dapp-notification-types';\nimport type { DataServiceDappNotificationSubscriptions } from './data-service-dapp-notification-subscriptions';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\nimport type { AccountAddress } from '../../auth/auth.interface';\n\nexport class DappsImpl implements Dapps {\n  constructor(\n    private readonly dappAddresses: DappAddresses,\n    private readonly dappMessages: DappMessages,\n    private readonly notificationTypes: DataServiceDappNotificationTypes,\n    private readonly notificationSubscriptions: DataServiceDappNotificationSubscriptions,\n    private readonly dappsApi: DataServiceDappsApi,\n  ) {}\n\n  async find(query?: FindOneDappQuery): Promise<Dapp | null> {\n    try {\n      const dappDto = await withErrorParsing(\n        this.dappsApi.find(query?.address),\n      );\n      return this.toDapp(dappDto);\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n\n  private toDapp(dappDto: DappDto) {\n    return new DappImpl(\n      dappDto.id,\n      dappDto.publicKey,\n      dappDto.name,\n      dappDto.verified,\n      dappDto.telegramBotUserName,\n      dappDto.blockchainType,\n      this.dappAddresses,\n      this.dappMessages,\n      this.notificationTypes,\n      this.notificationSubscriptions,\n      dappDto.description,\n      dappDto.websiteUrl,\n      dappDto.avatarUrl,\n      dappDto.heroUrl,\n    );\n  }\n\n  async findAll(query?: FindDappQuery): Promise<ReadOnlyDapp[]> {\n    const dappDtos = await withErrorParsing(this.dappsApi.findAll(query));\n    return dappDtos.map((it) => ({\n      id: it.id,\n      address: it.publicKey,\n      name: it.name,\n      description: it.description,\n      websiteUrl: it.websiteUrl,\n      avatarUrl: it.avatarUrl,\n      heroUrl: it.heroUrl,\n      verified: it.verified,\n      telegramUsername: it.telegramBotUserName,\n      blockchainType: it.blockchainType,\n    }));\n  }\n\n  async create(command: CreateDappCommand): Promise<Dapp> {\n    const dappDto = await withErrorParsing(\n      this.dappsApi.create({\n        name: command.name,\n        description: command.description,\n        websiteUrl: command.websiteUrl,\n        avatarUrl: command.avatarUrl,\n        heroUrl: command.heroUrl,\n        telegramBotConfiguration: command.telegramBotConfiguration,\n        blockchainType: command.blockchainType,\n      }),\n    );\n    return this.toDapp(dappDto);\n  }\n\n  async patch(command: PatchDappCommand): Promise<Dapp> {\n    const dappDto = await withErrorParsing(\n      this.dappsApi.patch({\n        name: command.name,\n        description: command.description,\n        websiteUrl: command.websiteUrl,\n        avatarUrl: command.avatarUrl,\n        heroUrl: command.heroUrl,\n      }),\n    );\n    return this.toDapp(dappDto);\n  }\n}\n\nexport class DappImpl implements Dapp {\n  constructor(\n    readonly id: string,\n    readonly address: AccountAddress,\n    readonly name: string,\n    readonly verified: boolean,\n    readonly telegramUsername: string,\n    readonly blockchainType: BlockchainType,\n    readonly dappAddresses: DappAddresses,\n    readonly messages: DappMessages,\n    readonly notificationTypes: DappNotificationTypes,\n    readonly notificationSubscriptions: DappNotificationSubscriptions,\n    readonly description?: string,\n    readonly websiteUrl?: string,\n    readonly avatarUrl?: string,\n    readonly heroUrl?: string,\n  ) {}\n}\n","export function groupBy<T, K extends keyof any>(arr: T[], key: (i: T) => K) {\n  return arr.reduce((groups, item) => {\n    (groups[key(item)] ||= []).push(item);\n    return groups;\n  }, {} as Record<K, T[]>);\n}\n","import type { DappAddress } from '../../address/addresses.interface';\nimport { AddressType } from '../../address/addresses.interface';\nimport { DialectSdkError, IllegalArgumentError } from '../../sdk/errors';\nimport type { DappAddresses } from '../../dapp/dapp.interface';\nimport { groupBy } from '../../utils/collection-utils';\n\nexport class DappAddressesFacade implements DappAddresses {\n  constructor(private readonly dappAddressesBackends: DappAddresses[]) {\n    if (dappAddressesBackends.length < 1) {\n      throw new IllegalArgumentError(\n        'Expected to have at least one dapp addresses backend.',\n      );\n    }\n  }\n\n  private static dedupleWalletAddresses(walletAddresses: DappAddress[]) {\n    const walletPublicKeyToWalletAddresses = groupBy(walletAddresses, (it) =>\n      it.address.wallet.address.toString(),\n    );\n    const deduplicatedWalletAddresses: DappAddress[] = Object.entries(\n      walletPublicKeyToWalletAddresses,\n    ).map(([walletPublicKey, walletDappAddresses]) =>\n      walletDappAddresses.reduce((prev, curr) => ({\n        id: prev.id,\n        enabled: prev.enabled && curr.enabled,\n        dappId: prev.dappId,\n        address: {\n          id: prev.id,\n          value: walletPublicKey,\n          verified: true,\n          type: prev.address.type,\n          wallet: {\n            address: walletPublicKey,\n          },\n        },\n      })),\n    );\n    return deduplicatedWalletAddresses;\n  }\n\n  async findAll(): Promise<DappAddress[]> {\n    const allSettled = await Promise.allSettled(\n      this.dappAddressesBackends.map((it) => it.findAll()),\n    );\n    const errors = allSettled\n      .filter((it) => it.status === 'rejected')\n      .map((it) => it as PromiseRejectedResult)\n      .map((it) => it.reason as DialectSdkError);\n    if (errors.length > 0) {\n      console.error(\n        `Error during finding dapp addresses: ${errors.map((it) =>\n          JSON.stringify(it),\n        )}`,\n      );\n    }\n    const fulfilled = allSettled.filter((it) => it.status === 'fulfilled');\n    if (errors.length > 0 && fulfilled.length === 0) {\n      const error: DialectSdkError = {\n        ...errors[0]!,\n        details: errors,\n      };\n      throw error;\n    }\n    const allDappAddresses = fulfilled\n      .map((it) => it as PromiseFulfilledResult<DappAddress[]>)\n      .map((it) => it.value)\n      .flat();\n    const walletAddresses = allDappAddresses.filter(\n      (it) => it.address.type === AddressType.Wallet,\n    );\n    const deduplicatedWalletAddresses =\n      DappAddressesFacade.dedupleWalletAddresses(walletAddresses);\n    const nonWalletAddresses = allDappAddresses.filter(\n      (it) => it.address.type !== AddressType.Wallet,\n    );\n    return Promise.resolve([\n      ...nonWalletAddresses,\n      ...deduplicatedWalletAddresses,\n    ]);\n  }\n}\n","import type { AccountAddress } from '../auth/auth.interface';\n\nexport interface Identity {\n  type: string;\n  address: AccountAddress;\n  name: string;\n  additionals?: {\n    avatarUrl?: string;\n    link?: string;\n    displayName?: string;\n    [key: string]: any;\n  };\n}\n\nexport abstract class IdentityResolver {\n  abstract resolve(address: AccountAddress): Promise<Identity | null>;\n\n  abstract resolveReverse(domainName: string): Promise<Identity | null>;\n\n  abstract get type(): string;\n}\n","import { Identity, IdentityResolver } from '../../identity/identity.interface';\nimport type { AccountAddress } from '../../auth/auth.interface';\n\nexport class FirstFoundIdentityResolver extends IdentityResolver {\n  constructor(private readonly resolvers: IdentityResolver[]) {\n    super();\n  }\n\n  get type(): string {\n    return 'DIALECT_FIRST_FOUND_IDENTITY_RESOLVER';\n  }\n\n  async resolve(address: AccountAddress): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    for await (const resolver of this.resolvers) {\n      try {\n        const identity = await resolver.resolve(address);\n        if (identity) {\n          return identity;\n        }\n      } catch (e) {\n        console.error(\n          `error resolving identity at ${resolver.type} for account address ${address}`,\n          e,\n        );\n      }\n    }\n    return null;\n  }\n\n  async resolveReverse(domainName: string): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    for await (const resolver of this.resolvers) {\n      try {\n        const reverseIdentity = await resolver.resolveReverse(domainName);\n        if (reverseIdentity) {\n          return reverseIdentity;\n        }\n      } catch (e) {\n        console.error(\n          `error resolving identity at ${resolver.type} for name ${domainName}`,\n          e,\n        );\n      }\n    }\n    return null;\n  }\n}\n\nexport class FirstFoundFastIdentityResolver extends IdentityResolver {\n  constructor(private readonly resolvers: IdentityResolver[]) {\n    super();\n  }\n\n  get type(): string {\n    return 'DIALECT_FIRST_FOUND_FAST_IDENTITY_RESOLVER';\n  }\n\n  async resolve(address: AccountAddress): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    try {\n      const any = await Promise.any(\n        this.resolvers.map((it) => it.resolve(address)),\n      );\n      return any;\n    } catch (e) {\n      console.error(\n        `error resolving identity for account address ${address.toString()}`,\n        e,\n      );\n    }\n\n    return null;\n  }\n\n  async resolveReverse(domainName: string): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    try {\n      const any = await Promise.any(\n        this.resolvers.map((it) => it.resolveReverse(domainName)),\n      );\n      return any;\n    } catch (e) {\n      console.error(`error resolving identity for name ${domainName}`, e);\n    }\n\n    return null;\n  }\n}\n\nexport class AggregateSequentialIdentityResolver extends IdentityResolver {\n  constructor(private readonly resolvers: IdentityResolver[]) {\n    super();\n  }\n\n  get type(): string {\n    return 'DIALECT_AGGREGATED_SEQUENTIAL_IDENTITY_RESOLVER';\n  }\n\n  async resolve(address: AccountAddress): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    try {\n      const allSettled = await Promise.allSettled(\n        this.resolvers.map((it) => it.resolve(address)),\n      );\n      const resolved = allSettled.filter(\n        (it) => it.status === 'fulfilled' && it.value !== null,\n      );\n      const aggregated = resolved\n        .map((it) => it as PromiseFulfilledResult<Identity>)\n        .map((it) => it.value)\n        .reduce(\n          (prev, curr) => {\n            return {\n              ...curr,\n              ...prev,\n              additionals: { ...curr.additionals, ...prev.additionals },\n            };\n          },\n          {\n            type: this.type,\n            address: address,\n          } as Identity,\n        );\n\n      if (!aggregated || !aggregated.name) {\n        return null;\n      }\n\n      return aggregated;\n    } catch (e) {\n      console.error(\n        `error resolving identity for account address ${address.toString()}`,\n        e,\n      );\n    }\n\n    return null;\n  }\n\n  async resolveReverse(domainName: string): Promise<Identity | null> {\n    if (!this.resolvers.length) {\n      return null;\n    }\n    try {\n      const allSettled = await Promise.allSettled(\n        this.resolvers.map((it) => it.resolveReverse(domainName)),\n      );\n      const resolved = allSettled.filter((it) => it.status === 'fulfilled');\n      const aggregated = resolved\n        .map((it) => it as PromiseFulfilledResult<Identity>)\n        .map((it) => it.value)\n        .reduce(\n          (prev, curr) => {\n            return { ...curr, ...prev };\n          },\n          {\n            type: 'DIALECT_AGGREGATED_IDENTITY',\n            name: domainName,\n          } as Identity,\n        );\n\n      if (!aggregated || !aggregated.address) {\n        return null;\n      }\n\n      return aggregated;\n    } catch (e) {\n      console.error(`error resolving identity for name ${domainName}`, e);\n    }\n\n    return null;\n  }\n}\n","import type { DappAddress } from '../../address/addresses.interface';\nimport { toAddressType } from '../../address/addresses.interface';\nimport type { DappAddresses } from '../../dapp/dapp.interface';\nimport type {\n  DappAddressDto,\n  DataServiceDappsApi,\n} from '../../dialect-cloud-api/data-service-dapps-api';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\n\nexport class DataServiceDappAddresses implements DappAddresses {\n  constructor(private readonly dataServiceDappsApi: DataServiceDappsApi) {}\n\n  async findAll(): Promise<DappAddress[]> {\n    const dappAddressesDtos = await withErrorParsing(\n      this.dataServiceDappsApi.findAllDappAddresses(),\n    );\n    return dappAddressesDtos.map((it) => toDappAddress(it));\n  }\n}\n\nexport function toDappAddress(dto: DappAddressDto) {\n  const dapp: DappAddress = {\n    id: dto.id,\n    enabled: dto.enabled,\n    channelId: dto.channelId,\n    dappId: dto.dapp.id,\n    address: {\n      id: dto.address.id,\n      type: toAddressType(dto.address.type),\n      value: dto.address.value,\n      verified: dto.address.verified,\n      wallet: {\n        address: dto.address.wallet.publicKey,\n      },\n    },\n  };\n  return dapp;\n}\n","import type { Address, DappAddress } from '../../address/addresses.interface';\nimport {\n  toAddressType,\n  toAddressTypeDto,\n} from '../../address/addresses.interface';\nimport { toDappAddress } from '../dapp/data-service-dapp-addresses';\nimport type {\n  CreateAddressCommand,\n  CreateDappAddressCommand,\n  DappMessage,\n  DeleteAddressCommand,\n  DeleteDappAddressCommand,\n  FindAddressQuery,\n  FindDappAddressesQuery,\n  FindDappAddressQuery,\n  FindDappMessageQuery,\n  FindDappMessagesSummaryQuery,\n  FindNotificationSubscriptionQuery,\n  MarkDappMessagesAsReadCommand,\n  PartialUpdateAddressCommand,\n  PartialUpdateDappAddressCommand,\n  ResendVerificationCodeCommand,\n  UpsertNotificationSubscriptionCommand,\n  UpsertPushNotificationSubscriptionCommand,\n  VerifyAddressCommand,\n  WalletAddresses,\n  WalletDappAddresses,\n  WalletMessages,\n  WalletNotificationSubscription,\n  WalletNotificationSubscriptions,\n  WalletPushNotificationSubscription,\n  WalletPushNotificationSubscriptions,\n  Wallets,\n} from '../../wallet/wallet.interface';\nimport type { DataServiceWalletAddressesApi } from '../../dialect-cloud-api/data-service-wallet-addresses-api';\nimport type { DataServiceApiClientError } from '../../dialect-cloud-api/data-service-api';\nimport type { DataServiceWalletMessagesApi } from '../../dialect-cloud-api/data-service-wallet-messages-api';\nimport type {\n  DataServiceWalletNotificationSubscriptionsApi,\n  WalletNotificationSubscriptionDto,\n} from '../../dialect-cloud-api/data-service-wallet-notification-subscriptions-api';\nimport type { DataServiceWalletDappAddressesApi } from '../../dialect-cloud-api/data-service-wallet-dapp-addresses-api';\nimport type { AddressDto } from '../../dialect-cloud-api/data-service-dapps-api';\nimport { ResourceNotFoundError } from '../../sdk/errors';\nimport type { DataServicePushNotificationSubscriptionsApi } from '../../dialect-cloud-api/data-service-push-notification-subscriptions-api';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\nimport type { AccountAddress } from '../../auth/auth.interface';\nimport type { TextSerde } from '../../messaging/text-serde';\nimport { UnencryptedTextSerde } from '../../messaging/text-serde';\nimport type { ThreadsGeneralSummary } from '../../messaging/messaging.interface';\n\nexport class DataServiceWallets implements Wallets {\n  addresses: WalletAddresses;\n  dappAddresses: WalletDappAddresses;\n  messages: WalletMessages;\n  notificationSubscriptions: WalletNotificationSubscriptions;\n  pushNotificationSubscriptions: WalletPushNotificationSubscriptions;\n\n  constructor(\n    readonly address: AccountAddress,\n    private readonly dataServiceWalletAddressesApi: DataServiceWalletAddressesApi,\n    private readonly dataServiceWalletDappAddressesApi: DataServiceWalletDappAddressesApi,\n    private readonly dataServiceWalletMessagesApi: DataServiceWalletMessagesApi,\n    private readonly dataServiceWalletNotificationSubscriptionsApi: DataServiceWalletNotificationSubscriptionsApi,\n    private readonly dataServicePushWalletNotificationSubscriptionsApi: DataServicePushNotificationSubscriptionsApi,\n  ) {\n    this.addresses = new DataServiceWalletAddresses(\n      dataServiceWalletAddressesApi,\n    );\n    this.dappAddresses = new DataServiceWalletDappAddresses(\n      dataServiceWalletDappAddressesApi,\n    );\n    this.messages = new DataServiceWalletMessages(dataServiceWalletMessagesApi);\n    this.notificationSubscriptions =\n      new DataServiceWalletNotificationSubscriptions(\n        dataServiceWalletNotificationSubscriptionsApi,\n      );\n    this.pushNotificationSubscriptions =\n      new DataServiceWalletPushNotificationSubscriptions(\n        dataServicePushWalletNotificationSubscriptionsApi,\n      );\n  }\n}\n\nexport class DataServiceWalletAddresses implements WalletAddresses {\n  constructor(private readonly api: DataServiceWalletAddressesApi) {}\n\n  async create(command: CreateAddressCommand): Promise<Address> {\n    const created = await withErrorParsing(\n      this.api.create({\n        value: command.value,\n        type: toAddressTypeDto(command.type),\n      }),\n    );\n    return toAddress(created);\n  }\n\n  async delete(command: DeleteAddressCommand): Promise<void> {\n    return withErrorParsing(this.api.delete(command.addressId));\n  }\n\n  async find(query: FindAddressQuery): Promise<Address | null> {\n    try {\n      const addressDto = await withErrorParsing(this.api.find(query.addressId));\n      return toAddress(addressDto);\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n\n  async findAll(): Promise<Address[]> {\n    const addressDtos = await withErrorParsing(this.api.findAll());\n    return addressDtos.map((it) => toAddress(it));\n  }\n\n  resendVerificationCode(\n    command: ResendVerificationCodeCommand,\n  ): Promise<void> {\n    return withErrorParsing(this.api.resendVerificationCode(command.addressId));\n  }\n\n  async update(command: PartialUpdateAddressCommand): Promise<Address> {\n    const patched = await withErrorParsing(\n      this.api.patch(command.addressId, {\n        value: command.value,\n      }),\n    );\n    return toAddress(patched);\n  }\n\n  async verify(command: VerifyAddressCommand): Promise<Address> {\n    const verified = await withErrorParsing(\n      this.api.verify(command.addressId, {\n        code: command.code,\n      }),\n    );\n    return toAddress(verified);\n  }\n}\n\nexport class DataServiceWalletDappAddresses implements WalletDappAddresses {\n  constructor(private readonly api: DataServiceWalletDappAddressesApi) {}\n\n  async create(command: CreateDappAddressCommand): Promise<DappAddress> {\n    const created = await withErrorParsing(\n      this.api.create({\n        addressId: command.addressId,\n        dappPublicKey: command.dappAccountAddress.toString(),\n        enabled: command.enabled,\n      }),\n    );\n    return toDappAddress(created);\n  }\n\n  delete(command: DeleteDappAddressCommand): Promise<void> {\n    return withErrorParsing(this.api.delete(command.dappAddressId));\n  }\n\n  async find(query: FindDappAddressQuery): Promise<DappAddress | null> {\n    try {\n      const found = await withErrorParsing(this.api.find(query.dappAddressId));\n      return toDappAddress(found);\n    } catch (e) {\n      const err = e as DataServiceApiClientError;\n      if (err instanceof ResourceNotFoundError) return null;\n      throw e;\n    }\n  }\n\n  async findAll(query?: FindDappAddressesQuery): Promise<DappAddress[]> {\n    const found = await withErrorParsing(\n      this.api.findAll(\n        query && {\n          addressIds: query.addressIds,\n          dappPublicKey: query.dappAccountAddress?.toString(),\n        },\n      ),\n    );\n    return found.map((it) => toDappAddress(it));\n  }\n\n  async update(command: PartialUpdateDappAddressCommand): Promise<DappAddress> {\n    const found = await withErrorParsing(\n      this.api.patch(command.dappAddressId, {\n        enabled: command.enabled,\n      }),\n    );\n    return toDappAddress(found);\n  }\n}\n\nexport class DataServiceWalletMessages implements WalletMessages {\n  private readonly textSerde: TextSerde = new UnencryptedTextSerde();\n\n  constructor(private readonly api: DataServiceWalletMessagesApi) {}\n\n  async findAllFromDapps(query?: FindDappMessageQuery): Promise<DappMessage[]> {\n    const dappMessages = await withErrorParsing(\n      this.api.findAllDappMessages({\n        skip: query?.skip,\n        take: query?.take,\n        dappVerified: query?.dappVerified,\n      }),\n    );\n    return dappMessages.map((it) => ({\n      author: it.owner,\n      timestamp: new Date(it.timestamp),\n      text: this.textSerde.deserialize(new Uint8Array(it.text)),\n      id: it.id,\n      metadata: it.metadata,\n    }));\n  }\n\n  async dappMessagesSummary(\n    query?: FindDappMessagesSummaryQuery,\n  ): Promise<ThreadsGeneralSummary> {\n    const summaryDto = await withErrorParsing(\n      this.api.dappMessagesSummary({\n        dappVerified: query?.dappVerified,\n      }),\n    );\n    return {\n      unreadMessagesCount: summaryDto.unreadMessagesCount,\n    };\n  }\n\n  async markAllDappMessagesAsRead(\n    command?: MarkDappMessagesAsReadCommand,\n  ): Promise<void> {\n    await withErrorParsing(\n      this.api.markAllDappMessagesAsRead({\n        dappVerified: command?.dappVerified,\n      }),\n    );\n  }\n}\n\nfunction toAddress(addressDto: AddressDto): Address {\n  return {\n    id: addressDto.id,\n    value: addressDto.value,\n    verified: addressDto.verified,\n    type: toAddressType(addressDto.type),\n    wallet: {\n      address: addressDto.wallet.publicKey,\n    },\n  };\n}\n\nexport class DataServiceWalletNotificationSubscriptions\n  implements WalletNotificationSubscriptions\n{\n  constructor(\n    private readonly api: DataServiceWalletNotificationSubscriptionsApi,\n  ) {}\n\n  async findAll(\n    query: FindNotificationSubscriptionQuery,\n  ): Promise<WalletNotificationSubscription[]> {\n    const dtos = await withErrorParsing(\n      this.api.findAll({\n        dappPublicKey: query?.dappAccountAddress?.toString(),\n      }),\n    );\n    return dtos.map(fromNotificationSubscriptionDto);\n  }\n\n  async upsert(\n    command: UpsertNotificationSubscriptionCommand,\n  ): Promise<WalletNotificationSubscription> {\n    const dto = await withErrorParsing(this.api.upsert(command));\n    return fromNotificationSubscriptionDto(dto);\n  }\n}\n\nfunction fromNotificationSubscriptionDto(\n  dto: WalletNotificationSubscriptionDto,\n): WalletNotificationSubscription {\n  return {\n    notificationType: dto.notificationType,\n    subscription: {\n      wallet: {\n        address: dto.subscription.wallet.publicKey,\n      },\n      config: dto.subscription.config,\n    },\n  };\n}\n\nexport class DataServiceWalletPushNotificationSubscriptions\n  implements WalletPushNotificationSubscriptions\n{\n  constructor(\n    private readonly api: DataServicePushNotificationSubscriptionsApi,\n  ) {}\n\n  async delete(physicalId: string): Promise<void> {\n    await withErrorParsing(this.api.delete(physicalId));\n  }\n\n  async upsert(\n    command: UpsertPushNotificationSubscriptionCommand,\n  ): Promise<WalletPushNotificationSubscription> {\n    const dto = await this.api.upsert(command);\n    return {\n      ...dto,\n      walletAddress: dto.walletPublicKey,\n    };\n  }\n\n  async get(physicalId: string): Promise<WalletPushNotificationSubscription> {\n    const dto = await this.api.get(physicalId);\n    return {\n      ...dto,\n      walletAddress: dto.walletPublicKey,\n    };\n  }\n}\n","import type {\n  CreateThreadCommand,\n  FindThreadByOtherMemberQuery,\n  FindThreadQuery,\n  Messaging,\n  Thread,\n  ThreadsGeneralSummary,\n  ThreadSummary,\n} from '../../messaging/messaging.interface';\nimport {\n  DialectSdkError,\n  IllegalArgumentError,\n  IllegalStateError,\n} from '../../sdk/errors';\n\nexport class MessagingFacade implements Messaging {\n  readonly type = 'messaging-facade';\n\n  constructor(private readonly delegates: Messaging[]) {\n    if (delegates.length < 1) {\n      throw new IllegalArgumentError(\n        'Expected to have at least on messaging backend.',\n      );\n    }\n  }\n\n  create(command: CreateThreadCommand): Promise<Thread> {\n    const messaging = this.getPreferableMessaging(command.type);\n    return messaging.create(command);\n  }\n\n  async find(query: FindThreadQuery): Promise<Thread | null> {\n    if ('id' in query && query.id.type) {\n      const messaging = this.lookUpMessagingBackend(query.id.type);\n      return messaging.find(query);\n    }\n    for (const messaging of this.delegates) {\n      try {\n        const thread = await messaging.find(query);\n        if (thread) {\n          return thread;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return null;\n  }\n\n  async findAll(): Promise<Thread[]> {\n    const allSettled = await Promise.allSettled(\n      this.delegates.map((messaging) => messaging.findAll()),\n    );\n    const errors = allSettled\n      .filter((it) => it.status === 'rejected')\n      .map((it) => it as PromiseRejectedResult)\n      .map((it) => it.reason as DialectSdkError);\n    if (errors.length > 0) {\n      console.error(\n        `Error during finding dialects: ${errors.map((it) =>\n          JSON.stringify(it),\n        )}`,\n      );\n    }\n    const fulfilled = allSettled.filter((it) => it.status === 'fulfilled');\n    if (errors.length > 0 && fulfilled.length === 0) {\n      const error: DialectSdkError = {\n        ...errors[0]!,\n        details: errors,\n      };\n      throw error;\n    }\n    return fulfilled\n      .map((it) => it as PromiseFulfilledResult<Thread[]>)\n      .map((it) => it.value)\n      .flat()\n      .sort((t1, t2) => t2.updatedAt.getTime() - t1.updatedAt.getTime());\n  }\n\n  async findSummary(\n    query: FindThreadByOtherMemberQuery,\n  ): Promise<ThreadSummary | null> {\n    for (const messaging of this.delegates) {\n      try {\n        const thread = await messaging.findSummary(query);\n        if (thread) {\n          return thread;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return null;\n  }\n\n  async findSummaryAll(): Promise<ThreadsGeneralSummary | null> {\n    for (const messaging of this.delegates) {\n      try {\n        const summary = await messaging.findSummaryAll();\n        if (summary) {\n          return summary;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return null;\n  }\n\n  private getPreferableMessaging(type?: string) {\n    if (type) {\n      return this.lookUpMessagingBackend(type);\n    }\n    return this.getFirstAccordingToPriority();\n  }\n\n  private lookUpMessagingBackend(type: string) {\n    const messagingBackend = this.delegates.find(({ type: t }) => type === t);\n    if (!messagingBackend) {\n      throw new IllegalArgumentError(\n        `Backend ${type} is not configured in sdk.`,\n      );\n    }\n    return messagingBackend;\n  }\n\n  private getFirstAccordingToPriority() {\n    const messaging = this.delegates[0];\n    if (!messaging) {\n      throw new IllegalStateError('Should not happen.');\n    }\n    return messaging;\n  }\n}\n","import type { DataServiceDappNotificationTypesApi } from '../../dialect-cloud-api/data-service-dapp-notification-types-api';\nimport type {\n  CreateNotificationTypeCommand,\n  DappNotificationTypes,\n  PatchNotificationTypeCommand,\n} from '../../dapp/dapp.interface';\nimport type { NotificationType } from '../../wallet/wallet.interface';\nimport { withErrorParsing } from '../../dialect-cloud-api/data-service-errors';\n\nexport class DataServiceDappNotificationTypes implements DappNotificationTypes {\n  constructor(private readonly api: DataServiceDappNotificationTypesApi) {}\n\n  async create(\n    command: CreateNotificationTypeCommand,\n  ): Promise<NotificationType> {\n    const dto = await withErrorParsing(this.api.create(command));\n    return {\n      ...dto,\n    };\n  }\n\n  async delete(id: string): Promise<void> {\n    await withErrorParsing(this.api.delete(id));\n  }\n\n  async find(id: string): Promise<NotificationType> {\n    const dto = await withErrorParsing(this.api.find(id));\n    return {\n      ...dto,\n    };\n  }\n\n  async findAll(): Promise<NotificationType[]> {\n    const dtos = await withErrorParsing(this.api.findAll());\n    return dtos.map((it) => ({\n      ...it,\n    }));\n  }\n\n  async patch(\n    id: string,\n    command: PatchNotificationTypeCommand,\n  ): Promise<NotificationType> {\n    const dto = await withErrorParsing(this.api.patch(id, command));\n    return {\n      ...dto,\n    };\n  }\n}\n","import type { WalletDto } from './data-service-dapps-api';\nimport type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\n\nexport interface FindNotificationSubscriptionQueryDto {\n  readonly dappPublicKey: string;\n}\n\nexport interface WalletNotificationSubscriptionDto {\n  notificationType: NotificationTypeDto;\n  subscription: NotificationSubscriptionDto;\n}\n\nexport class NotificationSubscriptionDto {\n  wallet!: WalletDto;\n  config!: NotificationConfigDto;\n}\n\nexport interface NotificationTypeDto {\n  id: string;\n  name: string;\n  humanReadableId: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags: string[];\n  defaultConfig: NotificationConfigDto;\n  dappId: string;\n}\n\nexport interface NotificationConfigDto {\n  enabled: boolean;\n}\n\nexport interface UpsertNotificationSubscriptionCommandDto {\n  readonly notificationTypeId: string;\n  readonly config: NotificationConfigDto;\n}\n\nexport interface DataServiceWalletNotificationSubscriptionsApi {\n  findAll(\n    query: FindNotificationSubscriptionQueryDto,\n  ): Promise<WalletNotificationSubscriptionDto[]>;\n\n  upsert(\n    command: UpsertNotificationSubscriptionCommandDto,\n  ): Promise<WalletNotificationSubscriptionDto>;\n}\n\nexport class DataServiceWalletNotificationSubscriptionsApiClient\n  implements DataServiceWalletNotificationSubscriptionsApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async findAll(\n    query: FindNotificationSubscriptionQueryDto,\n  ): Promise<WalletNotificationSubscriptionDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<WalletNotificationSubscriptionDto[]>(\n          `${this.baseUrl}/api/v1/wallets/me/notificationSubscriptions`,\n          {\n            headers: createHeaders(token),\n            params: query,\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async upsert(\n    command: UpsertNotificationSubscriptionCommandDto,\n  ): Promise<WalletNotificationSubscriptionDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<WalletNotificationSubscriptionDto>(\n          `${this.baseUrl}/api/v1/wallets/me/notificationSubscriptions`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n","import axios from 'axios';\nimport type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\n\nexport type AddressTypeV0 = 'email' | 'sms' | 'telegram' | 'wallet';\n\nexport interface CreateAddressCommandV0 {\n  type: string;\n  value: string;\n  enabled: boolean;\n}\n\nexport interface DeleteAddressCommandV0 {\n  id: string;\n}\n\nexport interface DappAddressDtoV0 {\n  id: string;\n  type: AddressTypeV0;\n  verified: boolean;\n  addressId: string;\n  dapp: string;\n  enabled: boolean;\n  value: string;\n}\n\nexport interface DataServiceWalletsApiV0 {\n  createDappAddress(\n    command: CreateAddressCommandV0,\n    dapp: string,\n  ): Promise<DappAddressDtoV0>;\n\n  deleteDappAddress(command: DeleteAddressCommandV0): Promise<void>;\n\n  findAllDappAddresses(dappPublicKey: string): Promise<DappAddressDtoV0[]>;\n}\n\nexport class DataServiceWalletsApiClientV0 implements DataServiceWalletsApiV0 {\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async createDappAddress(\n    command: CreateAddressCommandV0,\n    dapp: string,\n  ): Promise<DappAddressDtoV0> {\n    const token = await this.tokenProvider.get();\n    const headers = createHeaders(token);\n    return withReThrowingDataServiceError(\n      axios\n        .post<DappAddressDtoV0>(\n          `${this.baseUrl}/v0/wallets/${token.body.sub}/dapps/${dapp}/addresses`,\n          command,\n          {\n            headers: headers,\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async deleteDappAddress(command: DeleteAddressCommandV0): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .delete(\n          `${this.baseUrl}/v0/wallets/${token.body.sub}/addresses/${command.id}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async findAllDappAddresses(dapp: string): Promise<DappAddressDtoV0[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappAddressDtoV0[]>(\n          `${this.baseUrl}/v0/wallets/${token.body.sub}/dapps/${dapp}/addresses`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n","import axios from 'axios';\nimport type { DappAddressDto } from './data-service-dapps-api';\nimport type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\n\nexport interface DataServiceWalletDappAddressesApi {\n  create(command: CreateDappAddressCommandDto): Promise<DappAddressDto>;\n\n  patch(\n    dappAddressId: string,\n    command: PartialUpdateDappAddressCommandDto,\n  ): Promise<DappAddressDto>;\n\n  delete(dappAddressId: string): Promise<void>;\n\n  find(dappAddressId: string): Promise<DappAddressDto>;\n\n  findAll(query?: FindDappAddressesQuery): Promise<DappAddressDto[]>;\n}\n\nexport interface CreateDappAddressCommandDto {\n  readonly dappPublicKey: string;\n  readonly addressId: string;\n  readonly enabled: boolean;\n}\n\nexport interface PartialUpdateDappAddressCommandDto {\n  readonly enabled?: boolean;\n}\n\nexport interface FindDappAddressesQuery {\n  readonly dappPublicKey?: string;\n  readonly addressIds?: string[];\n}\n\nexport class DataServiceWalletDappAddressesApiClient\n  implements DataServiceWalletDappAddressesApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async create(command: CreateDappAddressCommandDto): Promise<DappAddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<DappAddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/dappAddresses`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async delete(dappAddressId: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .delete<void>(\n          `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async find(dappAddressId: string): Promise<DappAddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappAddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async findAll(query?: FindDappAddressesQuery): Promise<DappAddressDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappAddressDto[]>(\n          `${this.baseUrl}/api/v1/wallets/me/dappAddresses`,\n          {\n            headers: createHeaders(token),\n            ...(query && { params: query }),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async patch(\n    dappAddressId: string,\n    command: PartialUpdateDappAddressCommandDto,\n  ): Promise<DappAddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .patch<DappAddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport type { AddressDto, AddressTypeDto } from './data-service-dapps-api';\nimport axios from 'axios';\n\nexport interface DataServiceWalletAddressesApi {\n  create(command: CreateAddressCommandDto): Promise<AddressDto>;\n\n  patch(\n    addressId: string,\n    command: PatchAddressCommandDto,\n  ): Promise<AddressDto>;\n\n  delete(addressId: string): Promise<void>;\n\n  find(addressId: string): Promise<AddressDto>;\n\n  findAll(): Promise<AddressDto[]>;\n\n  verify(\n    addressId: string,\n    command: VerifyAddressCommandDto,\n  ): Promise<AddressDto>;\n\n  resendVerificationCode(addressId: string): Promise<void>;\n}\n\nexport interface CreateAddressCommandDto {\n  readonly value: string;\n  readonly type: AddressTypeDto;\n}\n\nexport interface PatchAddressCommandDto {\n  readonly value?: string;\n}\n\nexport interface VerifyAddressCommandDto {\n  readonly code: string;\n}\n\nexport class DataServiceWalletAddressesApiClient\n  implements DataServiceWalletAddressesApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async create(command: CreateAddressCommandDto): Promise<AddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<AddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async patch(\n    addressId: string,\n    command: PatchAddressCommandDto,\n  ): Promise<AddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .patch<AddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async delete(addressId: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .delete<AddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async find(addressId: string): Promise<AddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<AddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async findAll(): Promise<AddressDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<AddressDto[]>(`${this.baseUrl}/api/v1/wallets/me/addresses`, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async resendVerificationCode(addressId: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return await withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}/resendVerificationCode`,\n          {},\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async verify(\n    addressId: string,\n    command: VerifyAddressCommandDto,\n  ): Promise<AddressDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<AddressDto>(\n          `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}/verify`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\n\nexport interface DataServicePushNotificationSubscriptionsApi {\n  delete(physicalId: string): Promise<void>;\n\n  upsert(\n    command: UpsertPushNotificationSubscriptionCommandDto,\n  ): Promise<PushNotificationSubscriptionDto>;\n\n  get(physicalId: string): Promise<PushNotificationSubscriptionDto>;\n}\n\nexport class DataServicePushNotificationSubscriptionsApiClient\n  implements DataServicePushNotificationSubscriptionsApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async get(physicalId: string): Promise<PushNotificationSubscriptionDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<PushNotificationSubscriptionDto>(\n          `${this.baseUrl}/api/v1/pushNotificationSubscriptions/${physicalId}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async delete(physicalId: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios.delete(\n        `${this.baseUrl}/api/v1/pushNotificationSubscriptions/${physicalId}`,\n        {\n          headers: createHeaders(token),\n        },\n      ),\n    );\n  }\n\n  async upsert(\n    command: UpsertPushNotificationSubscriptionCommandDto,\n  ): Promise<PushNotificationSubscriptionDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<PushNotificationSubscriptionDto>(\n          `${this.baseUrl}/api/v1/pushNotificationSubscriptions`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n\nexport class PushNotificationSubscriptionDto {\n  walletPublicKey!: string; // e.g. 'abdo094feCZt9bAbPWtJk7ntv24vDYGPmyS7swp7DY5h'\n  physicalId!: string; // e.g. 'FCDBD8EF-62FC-4ECB-B2F5-92C9E79AC7F9' | 'dd96dec43fb81c97'\n  token!: string;\n}\n\nexport class UpsertPushNotificationSubscriptionCommandDto {\n  physicalId!: string;\n  token!: string;\n}\n","import {\n  DataServiceDialectsApi,\n  DataServiceDialectsApiClient,\n} from './data-service-dialects-api';\nimport {\n  DataServiceWalletNotificationSubscriptionsApi,\n  DataServiceWalletNotificationSubscriptionsApiClient,\n} from './data-service-wallet-notification-subscriptions-api';\nimport type { DataServiceWalletsApiV0 } from './data-service-wallets-api.v0';\nimport { DataServiceWalletsApiClientV0 } from './data-service-wallets-api.v0';\nimport type { DataServiceWalletDappAddressesApi } from './data-service-wallet-dapp-addresses-api';\nimport { DataServiceWalletDappAddressesApiClient } from './data-service-wallet-dapp-addresses-api';\nimport type { DataServiceWalletAddressesApi } from './data-service-wallet-addresses-api';\nimport { DataServiceWalletAddressesApiClient } from './data-service-wallet-addresses-api';\nimport type { Token } from '../auth/auth.interface';\nimport type { DataServiceDappsApi } from './data-service-dapps-api';\nimport { DataServiceDappsApiClient } from './data-service-dapps-api';\nimport {\n  DataServicePushNotificationSubscriptionsApi,\n  DataServicePushNotificationSubscriptionsApiClient,\n} from './data-service-push-notification-subscriptions-api';\nimport { nanoid } from 'nanoid';\nimport type { TokenProvider } from '../auth/token-provider';\nimport {\n  DataServiceDappNotificationTypesApi,\n  DataServiceDappNotificationTypesApiClient,\n} from './data-service-dapp-notification-types-api';\nimport {\n  DataServiceWalletMessagesApi,\n  DataServiceWalletMessagesApiClient,\n} from './data-service-wallet-messages-api';\nimport type { AxiosError } from 'axios';\nimport type { DataServiceDappNotificationSubscriptionsApi } from './data-service-dapp-notification-subscriptions-api';\nimport { DataServiceDappNotificationSubscriptionsApiClient } from './data-service-dapp-notification-subscriptions-api';\nimport type { DataServiceHealthApi } from './data-service-health-api';\nimport { DataServiceHealthApiClient } from './data-service-health-api';\nimport { SDK_VERSION } from '../version';\nimport { DataServiceApi } from './data-service-api';\n\nexport class DataServiceApiFactory {\n  static create(baseUrl: string, tokenProvider: TokenProvider) {\n    const dialectsApi = new DataServiceDialectsApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const dappsApiClient = new DataServiceDappsApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const dappNotificationTypes = new DataServiceDappNotificationTypesApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const dappNotificationSubscriptions =\n      new DataServiceDappNotificationSubscriptionsApiClient(\n        baseUrl,\n        tokenProvider,\n      );\n    const walletsApiV0 = new DataServiceWalletsApiClientV0(\n      baseUrl,\n      tokenProvider,\n    );\n    const walletAddressesApi = new DataServiceWalletAddressesApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const walletDappAddressesApi = new DataServiceWalletDappAddressesApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const walletDappMessagesApi = new DataServiceWalletMessagesApiClient(\n      baseUrl,\n      tokenProvider,\n    );\n    const walletNotificationSubscriptions =\n      new DataServiceWalletNotificationSubscriptionsApiClient(\n        baseUrl,\n        tokenProvider,\n      );\n    const pushNotificationSubscriptions =\n      new DataServicePushNotificationSubscriptionsApiClient(\n        baseUrl,\n        tokenProvider,\n      );\n    const health = new DataServiceHealthApiClient(baseUrl);\n\n    return new DataServiceApi(\n      dialectsApi,\n      dappsApiClient,\n      dappNotificationTypes,\n      dappNotificationSubscriptions,\n      walletsApiV0,\n      walletAddressesApi,\n      walletDappAddressesApi,\n      walletDappMessagesApi,\n      walletNotificationSubscriptions,\n      pushNotificationSubscriptions,\n      health,\n    );\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport type {\n  NotificationConfigDto,\n  NotificationTypeDto,\n} from './data-service-wallet-notification-subscriptions-api';\nimport axios from 'axios';\n\nexport interface DataServiceDappNotificationTypesApi {\n  create(\n    command: CreateNotificationTypeCommandDto,\n  ): Promise<NotificationTypeDto>;\n\n  findAll(): Promise<NotificationTypeDto[]>;\n\n  find(id: string): Promise<NotificationTypeDto>;\n\n  patch(\n    id: string,\n    command: PatchNotificationTypeCommandDto,\n  ): Promise<NotificationTypeDto>;\n\n  delete(id: string): Promise<void>;\n}\n\nexport class DataServiceDappNotificationTypesApiClient\n  implements DataServiceDappNotificationTypesApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async create(\n    command: CreateNotificationTypeCommandDto,\n  ): Promise<NotificationTypeDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<NotificationTypeDto>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async delete(id: string): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .delete<void>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then(),\n    );\n  }\n\n  async find(id: string): Promise<NotificationTypeDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<NotificationTypeDto>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async findAll(): Promise<NotificationTypeDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<NotificationTypeDto[]>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async patch(\n    id: string,\n    command: PatchNotificationTypeCommandDto,\n  ): Promise<NotificationTypeDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .patch<NotificationTypeDto>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n\nexport interface PatchNotificationTypeCommandDto {\n  name?: string;\n  humanReadableId?: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags?: string[];\n  defaultConfig?: NotificationConfigDto;\n}\n\nexport interface CreateNotificationTypeCommandDto {\n  name: string;\n  humanReadableId: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags?: string[];\n  defaultConfig: NotificationConfigDto;\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport type {\n  DialectsSummaryDto,\n  MessageDto,\n} from './data-service-dialects-api';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\n\nexport interface DataServiceWalletMessagesApi {\n  findAllDappMessages(\n    query?: FindWalletMessagesQueryDto,\n  ): Promise<MessageDto[]>;\n\n  dappMessagesSummary(\n    query?: FindDappMessagesSummaryQueryDto,\n  ): Promise<DialectsSummaryDto>;\n\n  markAllDappMessagesAsRead(\n    command?: MarkDappMessagesAsReadCommandDto,\n  ): Promise<void>;\n}\n\nexport interface FindDappMessagesSummaryQueryDto {\n  readonly dappVerified?: boolean;\n}\n\nexport interface FindWalletMessagesQueryDto {\n  readonly skip?: number;\n  readonly take?: number;\n  readonly dappVerified?: boolean;\n}\n\nexport interface MarkDappMessagesAsReadCommandDto {\n  readonly dappVerified?: boolean;\n}\n\nexport class DataServiceWalletMessagesApiClient\n  implements DataServiceWalletMessagesApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async findAllDappMessages(\n    query?: FindWalletMessagesQueryDto,\n  ): Promise<MessageDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<MessageDto[]>(`${this.baseUrl}/api/v1/wallets/me/dappMessages`, {\n          headers: createHeaders(token),\n          ...(query && { params: query }),\n        })\n        .then((it) => it.data),\n    );\n  }\n\n  async dappMessagesSummary(\n    query?: FindDappMessagesSummaryQueryDto,\n  ): Promise<DialectsSummaryDto> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DialectsSummaryDto>(\n          `${this.baseUrl}/api/v1/wallets/me/dappMessages/summary`,\n          {\n            headers: createHeaders(token),\n            ...(query && { params: query }),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n\n  async markAllDappMessagesAsRead(\n    command?: MarkDappMessagesAsReadCommandDto,\n  ): Promise<void> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .post<void>(\n          `${this.baseUrl}/api/v1/wallets/me/dappMessages/markAsRead`,\n          command,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport axios from 'axios';\nimport type {\n  NotificationSubscriptionDto,\n  NotificationTypeDto,\n} from './data-service-wallet-notification-subscriptions-api';\n\nexport interface DataServiceDappNotificationSubscriptionsApi {\n  findAll(): Promise<DappNotificationSubscriptionDto[]>;\n}\n\nexport class DataServiceDappNotificationSubscriptionsApiClient\n  implements DataServiceDappNotificationSubscriptionsApi\n{\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenProvider: TokenProvider,\n  ) {}\n\n  async findAll(): Promise<DappNotificationSubscriptionDto[]> {\n    const token = await this.tokenProvider.get();\n    return withReThrowingDataServiceError(\n      axios\n        .get<DappNotificationSubscriptionDto[]>(\n          `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationSubscriptions`,\n          {\n            headers: createHeaders(token),\n          },\n        )\n        .then((it) => it.data),\n    );\n  }\n}\n\nexport class DappNotificationSubscriptionDto {\n  notificationType!: NotificationTypeDto;\n  subscriptions!: NotificationSubscriptionDto[];\n}\n","import axios from 'axios';\nimport { withReThrowingDataServiceError } from './data-service-api';\n\nexport declare type HealthCheckStatusDto = 'error' | 'ok' | 'shutting_down';\nexport declare type HealthIndicatorStatusDto = 'up' | 'down';\nexport declare type HealthIndicatorResultDto = {\n  [key: string]: {\n    status: HealthIndicatorStatusDto;\n    [optionalKeys: string]: any;\n  };\n};\n\nexport interface HealthCheckResultDto {\n  readonly status: HealthCheckStatusDto;\n  readonly info?: HealthIndicatorResultDto;\n  readonly error?: HealthIndicatorResultDto;\n  readonly details: HealthIndicatorResultDto;\n}\n\nexport interface DataServiceHealthApi {\n  healthCheck(): Promise<HealthCheckResultDto>;\n}\n\nexport class DataServiceHealthApiClient implements DataServiceHealthApi {\n  constructor(private readonly baseUrl: string) {}\n\n  healthCheck(): Promise<HealthCheckResultDto> {\n    return withReThrowingDataServiceError(\n      axios\n        .get<HealthCheckResultDto>(`${this.baseUrl}/api/v1/health`)\n        .then((it) => it.data),\n    );\n  }\n}\n","import type { Token } from '../auth/auth.interface';\nimport {\n  createHeaders,\n  withReThrowingDataServiceError,\n} from './data-service-api';\nimport type { WalletDto } from './data-service-dapps-api';\nimport axios from 'axios';\n\nexport interface DataServiceWalletsApiV1 {\n  upsertWallet(wallet: { publicKey: string }, token: Token): Promise<WalletDto>;\n}\n\nexport class DataServiceWalletsApiClientV1 implements DataServiceWalletsApiV1 {\n  constructor(private readonly baseUrl: string) {}\n\n  async upsertWallet(\n    wallet: { publicKey: string },\n    token: Token,\n  ): Promise<WalletDto> {\n    return withReThrowingDataServiceError(\n      axios\n        .post<WalletDto>(`${this.baseUrl}/api/v1/wallets/me/`, wallet, {\n          headers: createHeaders(token),\n        })\n        .then((it) => it.data),\n    );\n  }\n}\n","import { DataServiceDappMessages } from '../dapp/data-service-dapp-messages';\nimport type {\n  BlockchainSdk,\n  BlockchainSdkFactory,\n  Config,\n  ConfigProps,\n  DialectCloudConfig,\n  DialectSdk,\n  DialectSdkInfo,\n  IdentityConfig,\n} from '../../sdk/sdk.interface';\nimport type { IdentityResolver } from '../../identity/identity.interface';\nimport {\n  CachedTokenProvider,\n  DEFAULT_TOKEN_LIFETIME_SECONDS,\n  DefaultTokenProvider,\n  TokenProvider,\n} from '../../auth/token-provider';\nimport type { Wallets } from '../../wallet/wallet.interface';\nimport type {\n  DappAddresses,\n  DappMessages,\n  Dapps,\n} from '../../dapp/dapp.interface';\nimport { DataServiceDappNotificationSubscriptions } from '../dapp/data-service-dapp-notification-subscriptions';\nimport { DappMessagesFacade } from '../dapp/dapp-messages-facade';\nimport { DappsImpl } from '../dapp/dapp';\nimport { TokenStore } from '../../auth/token-store';\nimport { DappAddressesFacade } from '../dapp/dapp-addresses-facade';\nimport {\n  AggregateSequentialIdentityResolver,\n  FirstFoundFastIdentityResolver,\n  FirstFoundIdentityResolver,\n} from '../identity/identity-resolvers';\nimport { DataServiceWallets } from '../wallet/data-service-wallets';\nimport { EncryptionKeysStore } from '../../encryption/encryption-keys-store';\nimport { DataServiceMessaging } from '../messaging/data-service-messaging';\nimport { MessagingFacade } from '../messaging/messaging-facade';\nimport { IllegalArgumentError } from '../../sdk/errors';\nimport { DataServiceDappAddresses } from '../dapp/data-service-dapp-addresses';\nimport { DataServiceDappNotificationTypes } from '../dapp/data-service-dapp-notification-types';\nimport type { Messaging } from '../../messaging/messaging.interface';\nimport type { EncryptionKeysProvider } from '../../encryption/encryption-keys-provider';\nimport { DataServiceApiFactory } from '../../dialect-cloud-api/data-service-api-factory';\nimport type { DataServiceApi } from '../../dialect-cloud-api/data-service-api';\nimport { DataServiceWalletsApiClientV1 } from '../../dialect-cloud-api/data-service-wallets-api.v1';\nimport { isBoolean } from '../../utils/typecheck';\n\nexport class InternalDialectSdk<ChainSdk extends BlockchainSdk>\n  implements DialectSdk<ChainSdk>\n{\n  constructor(\n    readonly config: Config,\n    readonly threads: Messaging,\n    readonly dapps: Dapps,\n    readonly wallet: Wallets,\n    readonly identity: IdentityResolver,\n    readonly tokenProvider: CachedTokenProvider,\n    readonly encryptionKeysProvider: EncryptionKeysProvider,\n    readonly blockchainSdk: ChainSdk,\n  ) {}\n\n  get info(): DialectSdkInfo {\n    return {\n      supportsEndToEndEncryption: this.encryptionKeysProvider.isAvailable(),\n      hasValidAuthentication: this.tokenProvider.hasValidCachedToken(),\n    };\n  }\n}\n\nexport class DialectSdkFactory<ChainSdk extends BlockchainSdk> {\n  constructor(\n    private readonly config: ConfigProps,\n    private readonly blockchainFactory: BlockchainSdkFactory<ChainSdk>,\n  ) {}\n\n  private static logConfiguration(config: Config) {\n    if (config.environment !== 'production') {\n      console.log(\n        `Initializing Dialect SDK using configuration:\n  Dialect cloud settings:\n    URL: ${config.dialectCloud.url}\n  `,\n      );\n    }\n  }\n\n  create(): DialectSdk<ChainSdk> {\n    const config: Config = this.initializeConfig();\n    DialectSdkFactory.logConfiguration(config);\n    const blockchainSdk = this.blockchainFactory.create(config);\n    const tokenProvider = this.initializeTokenProvider(config, blockchainSdk);\n    const dataServiceApi = this.initializeDataServiceApi(\n      config.dialectCloud,\n      tokenProvider,\n    );\n    const messaging = this.initializeMessagingApi(\n      dataServiceApi,\n      blockchainSdk,\n    );\n    const dapps = this.initializeDappApi(dataServiceApi, blockchainSdk);\n    const wallet = new DataServiceWallets(\n      blockchainSdk.authenticationFacade.subject(),\n      dataServiceApi.walletAddresses,\n      dataServiceApi.walletDappAddresses,\n      dataServiceApi.walletMessages,\n      dataServiceApi.walletNotificationSubscriptions,\n      dataServiceApi.pushNotificationSubscriptions,\n    );\n    const identity = this.createIdentityResolver(config.identity);\n    return new InternalDialectSdk(\n      config,\n      messaging,\n      dapps,\n      wallet,\n      identity,\n      tokenProvider,\n      blockchainSdk.encryptionKeysProvider,\n      blockchainSdk,\n    );\n  }\n\n  private initializeTokenProvider(\n    config: Config,\n    { authenticationFacade }: BlockchainSdk,\n  ): CachedTokenProvider {\n    const defaultTokenProvider = new DefaultTokenProvider(\n      config.dialectCloud.tokenLifetimeMinutes * 60,\n      authenticationFacade.tokenGenerator,\n    );\n    const dataServiceWalletsApiV1 = new DataServiceWalletsApiClientV1(\n      config.dialectCloud.url,\n    );\n    return new CachedTokenProvider(\n      defaultTokenProvider,\n      config.dialectCloud.tokenStore,\n      config.dialectCloud.walletCreation,\n      authenticationFacade.authenticator.parser,\n      authenticationFacade.authenticator.validator,\n      authenticationFacade.subject(),\n      dataServiceWalletsApiV1,\n    );\n  }\n\n  private initializeDataServiceApi(\n    config: DialectCloudConfig,\n    tokenProvider: TokenProvider,\n  ) {\n    return DataServiceApiFactory.create(config.url, tokenProvider);\n  }\n\n  private initializeMessagingApi(\n    dataServiceApi: DataServiceApi,\n    blockchainSdk: BlockchainSdk,\n  ): Messaging {\n    const messagings: Messaging[] = [];\n    const dataServiceMessaging = new DataServiceMessaging(\n      blockchainSdk.authenticationFacade.subject(),\n      dataServiceApi.threads,\n      blockchainSdk.encryptionKeysProvider,\n    );\n    messagings.push(dataServiceMessaging);\n    if (blockchainSdk.messaging) {\n      messagings.push(blockchainSdk.messaging);\n    }\n    return new MessagingFacade(messagings);\n  }\n\n  private initializeDappApi(\n    dataServiceApi: DataServiceApi,\n    blockchainSdk: BlockchainSdk,\n  ): Dapps {\n    const dappAddresses = this.createDappAddresses(\n      dataServiceApi,\n      blockchainSdk,\n    );\n    const dappNotificationTypes = new DataServiceDappNotificationTypes(\n      dataServiceApi.dappNotificationTypes,\n    );\n    const dappNotificationSubscriptions =\n      new DataServiceDappNotificationSubscriptions(\n        dataServiceApi.dappNotificationSubscriptions,\n      );\n    const dappMessages = this.createDappMessages(dataServiceApi, blockchainSdk);\n    return new DappsImpl(\n      dappAddresses,\n      dappMessages,\n      dappNotificationTypes,\n      dappNotificationSubscriptions,\n      dataServiceApi.dapps,\n    );\n  }\n\n  private createDappAddresses(\n    dataServiceApi: DataServiceApi,\n    blockchainSdk: BlockchainSdk,\n  ): DappAddresses {\n    const dappAddresses: DappAddresses[] = [];\n    const dataServiceDappAddresses = new DataServiceDappAddresses(\n      dataServiceApi.dapps,\n    );\n    dappAddresses.push(dataServiceDappAddresses);\n    if (blockchainSdk.dappAddresses) {\n      dappAddresses.push(blockchainSdk.dappAddresses);\n    }\n    return new DappAddressesFacade(dappAddresses);\n  }\n\n  private createDappMessages(\n    dataServiceApi: DataServiceApi,\n    blockchainSdk: BlockchainSdk,\n  ): DappMessages {\n    const dappMessages: DappMessages[] = [];\n    const dataServiceDappMessages = new DataServiceDappMessages(\n      dataServiceApi.dapps,\n    );\n    dappMessages.push(dataServiceDappMessages);\n    if (blockchainSdk.dappMessages) {\n      dappMessages.push(blockchainSdk.dappMessages);\n    }\n    return new DappMessagesFacade(dappMessages);\n  }\n\n  private createIdentityResolver(config: IdentityConfig): IdentityResolver {\n    if (config.strategy === 'first-found') {\n      return new FirstFoundIdentityResolver(config.resolvers);\n    }\n    if (config.strategy === 'first-found-fast') {\n      return new FirstFoundFastIdentityResolver(config.resolvers);\n    }\n    if (config.strategy === 'aggregate-sequential') {\n      return new AggregateSequentialIdentityResolver(config.resolvers);\n    }\n\n    throw new IllegalArgumentError(\n      `Unknown identity strategy ${config.strategy}`,\n    );\n  }\n\n  private initializeConfig(): Config {\n    const environment = this.config.environment ?? 'production';\n    const encryptionKeysStore = this.createEncryptionKeysStore();\n    const identity = this.createIdentityConfig();\n    return {\n      environment,\n      dialectCloud: this.initializeDialectCloudConfig(),\n      encryptionKeysStore,\n      identity,\n    };\n  }\n\n  private createEncryptionKeysStore() {\n    const encryptionKeysStoreConfig = this.config.encryptionKeysStore;\n    if (\n      encryptionKeysStoreConfig &&\n      encryptionKeysStoreConfig instanceof EncryptionKeysStore\n    ) {\n      return encryptionKeysStoreConfig;\n    }\n    if (encryptionKeysStoreConfig === 'in-memory') {\n      return EncryptionKeysStore.createInMemory();\n    }\n    if (encryptionKeysStoreConfig === 'session-storage') {\n      return EncryptionKeysStore.createSessionStorage();\n    }\n    if (encryptionKeysStoreConfig === 'local-storage') {\n      return EncryptionKeysStore.createLocalStorage();\n    }\n    return EncryptionKeysStore.createInMemory();\n  }\n\n  private initializeDialectCloudConfig(): DialectCloudConfig {\n    const baseConfig: DialectCloudConfig = {\n      environment: 'production',\n      url: 'https://dialectapi.to',\n      tokenStore: this.createTokenStore(),\n      tokenLifetimeMinutes: this.createTokenLifetime(),\n      walletCreation: 'implicit',\n    };\n    const environment = this.config.environment;\n    if (environment) {\n      baseConfig.environment = environment;\n    }\n    if (environment === 'production') {\n      baseConfig.url = 'https://dialectapi.to';\n    }\n    if (environment === 'development') {\n      baseConfig.url = 'https://dev.dialectapi.to';\n    }\n    if (environment === 'local-development') {\n      baseConfig.url = 'http://localhost:8080';\n    }\n    const dialectCloudEnvironment = this.config.dialectCloud?.environment;\n    if (dialectCloudEnvironment) {\n      baseConfig.environment = dialectCloudEnvironment;\n    }\n    if (dialectCloudEnvironment === 'production') {\n      baseConfig.url = 'https://dialectapi.to';\n    }\n    if (dialectCloudEnvironment === 'development') {\n      baseConfig.url = 'https://dev.dialectapi.to';\n    }\n    if (dialectCloudEnvironment === 'local-development') {\n      baseConfig.url = 'http://localhost:8080';\n    }\n    if (this.config.dialectCloud?.url) {\n      baseConfig.url = this.config.dialectCloud.url;\n    }\n\n    if (this.config.dialectCloud?.walletCreation) {\n      baseConfig.walletCreation = this.config.dialectCloud.walletCreation;\n    }\n    return baseConfig;\n  }\n\n  private createTokenLifetime() {\n    return (\n      this.config.dialectCloud?.tokenLifetimeMinutes ??\n      DEFAULT_TOKEN_LIFETIME_SECONDS / 60\n    );\n  }\n\n  private createTokenStore() {\n    const tokenStoreConfig = this.config.dialectCloud?.tokenStore;\n    if (tokenStoreConfig && tokenStoreConfig instanceof TokenStore) {\n      return tokenStoreConfig;\n    }\n    if (tokenStoreConfig === 'in-memory') {\n      return TokenStore.createInMemory();\n    }\n    if (tokenStoreConfig === 'session-storage') {\n      return TokenStore.createSessionStorage();\n    }\n    if (tokenStoreConfig === 'local-storage') {\n      return TokenStore.createLocalStorage();\n    }\n    return TokenStore.createInMemory();\n  }\n\n  private createIdentityConfig(): IdentityConfig {\n    const identityConfig: IdentityConfig = {\n      strategy: 'first-found',\n      resolvers: [],\n    };\n\n    if (!this.config.identity) {\n      return identityConfig;\n    }\n\n    if (this.config.identity.strategy) {\n      identityConfig.strategy = this.config.identity.strategy;\n    }\n\n    if (this.config.identity.resolvers) {\n      identityConfig.resolvers = this.config.identity.resolvers;\n    }\n\n    return identityConfig;\n  }\n}\n","import type { TokenProvider } from '../auth/token-provider';\nimport type { Wallets } from '../wallet/wallet.interface';\nimport type { EncryptionKeysStore } from '../encryption/encryption-keys-store';\nimport type { Messaging } from '../messaging/messaging.interface';\nimport type {\n  DappAddresses,\n  DappMessages,\n  Dapps,\n} from '../dapp/dapp.interface';\nimport type { IdentityResolver } from '../identity/identity.interface';\nimport type { TokenStore } from '../auth/token-store';\nimport { DialectSdkFactory } from '../internal/sdk/sdk-factory';\nimport type { AuthenticationFacade } from '../auth/authentication-facade';\nimport type { EncryptionKeysProvider } from '../encryption/encryption-keys-provider';\n\nexport abstract class Dialect {\n  static sdk<ChainSdk extends BlockchainSdk>(\n    configProps: ConfigProps,\n    blockchainSdkFactory: BlockchainSdkFactory<ChainSdk>,\n  ): DialectSdk<ChainSdk> {\n    return new DialectSdkFactory(configProps, blockchainSdkFactory).create();\n  }\n}\n\nexport interface ConfigProps {\n  environment?: Environment;\n  dialectCloud?: DialectCloudConfigProps;\n  encryptionKeysStore?: EncryptionKeysStoreType | EncryptionKeysStore;\n  identity?: IdentityConfigProps;\n}\n\nexport interface BlockchainSdkFactory<ChainSdk extends BlockchainSdk> {\n  create(config: Config): ChainSdk;\n}\n\nexport abstract class BlockchainSdk {\n  readonly type!: string;\n  readonly info!: BlockChainSdkInfo;\n  readonly authenticationFacade!: AuthenticationFacade;\n  readonly encryptionKeysProvider!: EncryptionKeysProvider;\n  readonly messaging?: Messaging;\n  readonly dappMessages?: DappMessages;\n  readonly dappAddresses?: DappAddresses;\n}\n\nexport interface BlockChainSdkInfo {\n  supportsOnChainMessaging: boolean;\n}\n\nexport abstract class DialectSdk<ChainSdk extends BlockchainSdk> {\n  readonly info!: DialectSdkInfo;\n  readonly config!: Config;\n  readonly threads!: Messaging;\n  readonly dapps!: Dapps;\n  readonly wallet!: Wallets;\n  readonly identity!: IdentityResolver;\n  readonly tokenProvider!: TokenProvider;\n  readonly encryptionKeysProvider!: EncryptionKeysProvider;\n  readonly blockchainSdk!: ChainSdk;\n}\n\nexport interface DialectSdkInfo {\n  supportsEndToEndEncryption: boolean;\n  hasValidAuthentication: boolean;\n}\n\nexport type Environment = 'production' | 'development' | 'local-development';\nexport type TokenStoreType = 'in-memory' | 'session-storage' | 'local-storage';\nexport type EncryptionKeysStoreType =\n  | 'in-memory'\n  | 'session-storage'\n  | 'local-storage';\n\nexport type WalletCreation = 'none' | 'implicit';\n\nexport interface DialectCloudConfigProps {\n  environment?: DialectCloudEnvironment;\n  url?: string;\n  tokenStore?: TokenStoreType | TokenStore;\n  tokenLifetimeMinutes?: number;\n  walletCreation?: WalletCreation;\n}\n\nexport type DialectCloudEnvironment =\n  | 'production'\n  | 'development'\n  | 'local-development';\n\ntype IdentityResolveStrategy =\n  | 'first-found'\n  | 'first-found-fast'\n  | 'aggregate-sequential';\n\nexport interface IdentityConfigProps {\n  strategy?: IdentityResolveStrategy;\n  resolvers?: IdentityResolver[];\n}\n\nexport interface Config extends ConfigProps {\n  environment: Environment;\n  dialectCloud: DialectCloudConfig;\n  encryptionKeysStore: EncryptionKeysStore;\n  identity: IdentityConfig;\n}\n\nexport interface DialectCloudConfig extends DialectCloudConfigProps {\n  environment: DialectCloudEnvironment;\n  url: string;\n  tokenStore: TokenStore;\n  tokenLifetimeMinutes: number;\n  walletCreation: WalletCreation;\n}\n\nexport interface IdentityConfig extends IdentityConfigProps {\n  strategy: IdentityResolveStrategy;\n  resolvers: IdentityResolver[];\n}\n","import type {\n  Address,\n  AddressType,\n  DappAddress,\n} from '../address/addresses.interface';\nimport type { AccountAddress } from '../auth/auth.interface';\nimport type {\n  MessageMetadata,\n  ThreadsGeneralSummary,\n} from '../messaging/messaging.interface';\n\nexport interface Wallets {\n  readonly address: AccountAddress;\n  readonly addresses: WalletAddresses;\n  readonly dappAddresses: WalletDappAddresses;\n  readonly messages: WalletMessages;\n  readonly notificationSubscriptions: WalletNotificationSubscriptions;\n  readonly pushNotificationSubscriptions: WalletPushNotificationSubscriptions;\n}\n\nexport interface Wallet {\n  readonly address: AccountAddress;\n}\n\nexport interface WalletAddresses {\n  create(command: CreateAddressCommand): Promise<Address>;\n\n  update(command: PartialUpdateAddressCommand): Promise<Address>;\n\n  delete(command: DeleteAddressCommand): Promise<void>;\n\n  find(query: FindAddressQuery): Promise<Address | null>;\n\n  findAll(): Promise<Address[]>;\n\n  verify(command: VerifyAddressCommand): Promise<Address>;\n\n  resendVerificationCode(command: ResendVerificationCodeCommand): Promise<void>;\n}\n\nexport interface CreateAddressCommand {\n  readonly value: string;\n  readonly type: AddressType;\n}\n\nexport interface PartialUpdateAddressCommand {\n  readonly addressId: string;\n  readonly value?: string;\n}\n\nexport interface FindAddressQuery {\n  readonly addressId: string;\n}\n\nexport interface DeleteAddressCommand {\n  readonly addressId: string;\n}\n\nexport interface VerifyAddressCommand {\n  readonly addressId: string;\n  readonly code: string;\n}\n\nexport interface ResendVerificationCodeCommand {\n  readonly addressId: string;\n}\n\nexport interface WalletDappAddresses {\n  create(command: CreateDappAddressCommand): Promise<DappAddress>;\n\n  update(command: PartialUpdateDappAddressCommand): Promise<DappAddress>;\n\n  delete(command: DeleteDappAddressCommand): Promise<void>;\n\n  find(query: FindDappAddressQuery): Promise<DappAddress | null>;\n\n  findAll(query?: FindDappAddressesQuery): Promise<DappAddress[]>;\n}\n\nexport interface CreateDappAddressCommand {\n  readonly dappAccountAddress: AccountAddress;\n  readonly addressId: string;\n  readonly enabled: boolean;\n}\n\nexport interface PartialUpdateDappAddressCommand {\n  readonly dappAddressId: string;\n  readonly enabled?: boolean;\n}\n\nexport interface FindDappAddressQuery {\n  readonly dappAddressId: string;\n}\n\nexport interface FindDappAddressesQuery {\n  readonly addressIds?: string[];\n  readonly dappAccountAddress?: AccountAddress;\n}\n\nexport interface DeleteDappAddressCommand {\n  readonly dappAddressId: string;\n}\n\nexport interface FindDappMessagesSummaryQuery {\n  readonly dappVerified?: boolean;\n}\n\nexport interface WalletMessages {\n  findAllFromDapps(query?: FindDappMessageQuery): Promise<DappMessage[]>;\n  dappMessagesSummary(\n    query?: FindDappMessagesSummaryQuery,\n  ): Promise<ThreadsGeneralSummary>;\n  markAllDappMessagesAsRead(\n    command?: MarkDappMessagesAsReadCommand,\n  ): Promise<void>;\n}\n\nexport interface DappMessage {\n  id: string;\n  text: string;\n  timestamp: Date;\n  author: AccountAddress;\n  metadata?: Pick<MessageMetadata, 'title' | 'actions'>;\n}\n\nexport interface FindDappMessageQuery {\n  readonly skip?: number;\n  readonly take?: number;\n  readonly dappVerified?: boolean;\n}\n\nexport interface MarkDappMessagesAsReadCommand {\n  readonly dappVerified?: boolean;\n}\n\nexport interface WalletNotificationSubscriptions {\n  findAll(\n    query: FindNotificationSubscriptionQuery,\n  ): Promise<WalletNotificationSubscription[]>;\n\n  upsert(\n    command: UpsertNotificationSubscriptionCommand,\n  ): Promise<WalletNotificationSubscription>;\n}\n\nexport interface WalletPushNotificationSubscriptions {\n  delete(physicalId: string): Promise<void>;\n\n  upsert(\n    command: UpsertPushNotificationSubscriptionCommand,\n  ): Promise<WalletPushNotificationSubscription>;\n\n  get(physicalId: string): Promise<WalletPushNotificationSubscription>;\n}\n\nexport interface FindNotificationSubscriptionQuery {\n  readonly dappAccountAddress: AccountAddress;\n}\n\nexport interface WalletNotificationSubscription {\n  notificationType: NotificationType;\n  subscription: NotificationSubscription;\n}\n\nexport interface WalletPushNotificationSubscription {\n  walletAddress: string;\n  physicalId: string;\n  token: string;\n}\n\nexport class NotificationSubscription {\n  wallet!: Wallet;\n  config!: NotificationConfig;\n}\n\nexport interface NotificationType {\n  id: string;\n  name: string;\n  humanReadableId: string;\n  trigger?: string;\n  orderingPriority?: number;\n  tags: string[];\n  defaultConfig: NotificationConfig;\n  dappId: string;\n}\n\nexport interface NotificationConfig {\n  enabled: boolean;\n}\n\nexport interface UpsertNotificationSubscriptionCommand {\n  readonly notificationTypeId: string;\n  readonly config: NotificationConfig;\n}\n\nexport interface UpsertPushNotificationSubscriptionCommand {\n  readonly physicalId: string;\n  readonly token: string;\n}\n","export enum SmartMessageStateDto {\n  Created = 'CREATED',\n  ReadyForExecution = 'READY_FOR_EXECUTION',\n  Executing = 'EXECUTING',\n  Succeeded = 'SUCCEEDED',\n  Failed = 'FAILED',\n  Canceled = 'CANCELED',\n}\n\nexport enum ActionType {\n  SignTransaction = 'SIGN_TRANSACTION',\n  OpenLink = 'OPEN_LINK',\n  Cancel = 'CANCEL', // cancel without a transaction, in other words a noop\n}\n\nexport class SmartMessageButtonLayoutElementDto {\n  type!: 'button';\n  text!: string;\n  action!: SmartMessageSpecActionDto;\n}\n\nexport class SmartMessageLabelLayoutElementDto {\n  type!: 'label';\n  text!: string;\n}\n\nexport class SmartMessageSpecOpenLinkActionDto {\n  type!: ActionType.OpenLink;\n  link!: string;\n}\n\nexport class SmartMessageSpecSignTransactionActionDto {\n  humanReadableId!: string;\n  type!: ActionType.SignTransaction;\n}\n\nexport class SmartMessageSpecCancelActionDto {\n  humanReadableId!: string;\n  type!: ActionType.Cancel;\n}\n\nexport type SmartMessageSpecActionDto =\n  | SmartMessageSpecOpenLinkActionDto\n  | SmartMessageSpecSignTransactionActionDto\n  | SmartMessageSpecCancelActionDto;\n\nexport type SmartMessageLayoutElementDto =\n  | SmartMessageButtonLayoutElementDto\n  | SmartMessageLabelLayoutElementDto;\n\nexport class SmartMessageLayoutDto {\n  icon!: string | null;\n  description!: string | null;\n  header!: string | null;\n  subheader!: string | null;\n  elements!: SmartMessageLayoutElementDto[][];\n}\n\nexport class SmartMessageContentDto {\n  state!: SmartMessageStateDto;\n  layout!: SmartMessageLayoutDto;\n}\n\nexport class SmartMessagePreviewParamsDto {\n  state!: SmartMessageStateDto;\n}\n\nexport class SmartMessageSystemParamsDto {\n  state!: SmartMessageStateDto;\n  workflowStateHumanReadableId!: string;\n  createdByWalletAddress!: string;\n  principalWalletAddress!: string;\n  updatedByWalletAddress!: string;\n}\n\nexport class CreateSmartMessageTransactionCommandDto {\n  account!: string;\n  actionHumanReadableId!: string;\n}\n\nexport class SmartMessageTransactionDto {\n  transaction!: string;\n  message?: string;\n}\n\nexport class SubmitSmartMessageTransactionCommandDto {\n  readonly transaction!: string;\n  readonly actionHumanReadableId!: string;\n}\n","import type { SmartMessageContentDto } from './smart-message-spec.dto';\n\nexport class SmartMessageDto {\n  id!: string;\n  content!: SmartMessageContentDto;\n}\n"],"mappings":"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","names":["AddressType","decodeURLSafe","decodeURLSafe","nacl","nacl","nacl","BlockchainType","DappMessageActionType","createStorageKey","ThreadMemberScope","axios","MemberScopeDto","nacl","nacl","nacl","nacl","it","axios","axios","axios","axios","axios","axios","axios","axios","axios","axios","axios","axios","axios","axios","SmartMessageStateDto","ActionType"]}