import nacl, { SignKeyPair } from 'tweetnacl';

type AccountAddress = string;
declare abstract class PublicKey {
    abstract toString(): string;
    abstract toBytes(): Uint8Array;
    equals(other: PublicKey): boolean;
}
interface Token {
    rawValue: string;
    header: TokenHeader;
    body: TokenBody;
    signature: Uint8Array;
    base64Header: string;
    base64Body: string;
    base64Signature: string;
}
interface TokenHeader {
    alg: string;
    typ?: string;
}
interface TokenBody {
    sub: string;
    sub_jwk?: string;
    iat?: number;
    exp: number;
}
interface TokenSignerResult {
    payload: Uint8Array;
    signature: Uint8Array;
}
declare abstract class TokenSigner {
    abstract alg: string;
    abstract subject: AccountAddress;
    abstract subjectPublicKey?: PublicKey;
    abstract sign(payload: Uint8Array): Promise<TokenSignerResult>;
}

declare abstract class TokenStore {
    static createInMemory(): TokenStore;
    static createSessionStorage(): TokenStore;
    static createLocalStorage(): TokenStore;
    abstract get(subject: AccountAddress): string | null;
    abstract delete(subject: AccountAddress): void;
    abstract save(subject: AccountAddress, token: string): string;
}

declare class DialectSdkError extends Error {
    readonly type: string;
    readonly title: string;
    readonly msg?: string | undefined;
    readonly details?: any[] | undefined;
    constructor(type: string, title: string, msg?: string | undefined, details?: any[] | undefined);
}
declare class IllegalArgumentError extends DialectSdkError {
    constructor(title: string, msg?: string, details?: any);
}
declare class IllegalStateError extends DialectSdkError {
    constructor(title: string, msg?: string, details?: any);
}
declare class UnsupportedOperationError extends DialectSdkError {
    constructor(title: string, msg?: string, details?: any);
}
declare class UnknownError extends DialectSdkError {
    constructor(details?: any, msg?: string);
}
declare class BusinessConstraintViolationError extends DialectSdkError {
    constructor(msg?: string);
}
declare class ResourceAlreadyExistsError extends DialectSdkError {
    constructor(msg?: string);
}
declare class AuthenticationError extends DialectSdkError {
    constructor(msg?: string);
}
declare class AuthorizationError extends DialectSdkError {
    constructor(msg?: string);
}
declare class ResourceNotFoundError extends DialectSdkError {
    constructor(msg?: string);
}
declare abstract class IdentityError extends DialectSdkError {
}

declare class TokenParsingError extends DialectSdkError {
    constructor();
}
declare class TokenStructureValidationError extends DialectSdkError {
    constructor();
}
declare class TokenUnsupportedAlgError extends DialectSdkError {
    constructor();
}
declare abstract class TokenBodyParser {
    abstract parse(base64Body: string): TokenBody;
}
declare class TokenHeaderParser {
    parse(token: string): TokenHeader;
}
declare class TokenParser {
    private readonly bodyParser;
    private readonly tokenHeaderParser;
    constructor(bodyParser: TokenBodyParser);
    parse(token: string): Token;
    parseHeader(token: string): TokenHeader;
    private parseBody;
}

declare abstract class TokenValidator {
    isValid(token: Token): boolean;
    abstract canValidate(tokenHeader: TokenHeader): boolean;
    abstract isSignatureValid(token: Token): boolean;
    protected performExtraValidation(token: Token): boolean;
    private isExpired;
}

declare abstract class TokenGenerator {
    protected readonly signer: TokenSigner;
    constructor(signer: TokenSigner);
    abstract generate(ttlSeconds: number): Promise<Token>;
    protected header(): TokenHeader;
    protected body(ttlSeconds: number): TokenBody;
    protected sign(base64Header: string, base64Body: string, signer: TokenSigner): Promise<{
        signedPayload: Uint8Array;
        signature: Uint8Array;
        base64Signature: string;
    }>;
}

declare class Authenticator {
    readonly parser: TokenParser;
    readonly validator: TokenValidator;
    constructor(parser: TokenParser, validator: TokenValidator);
    authenticate(token: string): Token | null;
}
declare abstract class AuthenticationFacadeFactory {
    abstract get(): AuthenticationFacade;
}
declare class AuthenticationFacade {
    readonly tokenSigner: TokenSigner;
    readonly tokenGenerator: TokenGenerator;
    readonly authenticator: Authenticator;
    constructor(tokenSigner: TokenSigner, tokenGenerator: TokenGenerator, authenticator: Authenticator);
    type(): string;
    subject(): AccountAddress;
    generateToken(ttlSeconds: number): Promise<Token>;
    parseToken(token: string): Token;
    canValidate(tokenHeader: TokenHeader): boolean;
    isValid(token: Token): boolean;
}

interface DataServiceWalletsApiV1 {
    upsertWallet(wallet: {
        publicKey: string;
    }, token: Token): Promise<WalletDto>;
}
declare class DataServiceWalletsApiClientV1 implements DataServiceWalletsApiV1 {
    private readonly baseUrl;
    constructor(baseUrl: string);
    upsertWallet(wallet: {
        publicKey: string;
    }, token: Token): Promise<WalletDto>;
}

declare enum SmartMessageStateDto {
    Created = "CREATED",
    ReadyForExecution = "READY_FOR_EXECUTION",
    Executing = "EXECUTING",
    Succeeded = "SUCCEEDED",
    Failed = "FAILED",
    Canceled = "CANCELED"
}
declare enum ActionType {
    SignTransaction = "SIGN_TRANSACTION",
    OpenLink = "OPEN_LINK",
    Cancel = "CANCEL"
}
declare class SmartMessageButtonLayoutElementDto {
    type: 'button';
    text: string;
    action: SmartMessageSpecActionDto;
}
declare class SmartMessageLabelLayoutElementDto {
    type: 'label';
    text: string;
}
declare class SmartMessageSpecOpenLinkActionDto {
    type: ActionType.OpenLink;
    link: string;
}
declare class SmartMessageSpecSignTransactionActionDto {
    humanReadableId: string;
    type: ActionType.SignTransaction;
}
declare class SmartMessageSpecCancelActionDto {
    humanReadableId: string;
    type: ActionType.Cancel;
}
type SmartMessageSpecActionDto = SmartMessageSpecOpenLinkActionDto | SmartMessageSpecSignTransactionActionDto | SmartMessageSpecCancelActionDto;
type SmartMessageLayoutElementDto = SmartMessageButtonLayoutElementDto | SmartMessageLabelLayoutElementDto;
declare class SmartMessageLayoutDto {
    icon: string | null;
    description: string | null;
    header: string | null;
    subheader: string | null;
    elements: SmartMessageLayoutElementDto[][];
}
declare class SmartMessageContentDto {
    state: SmartMessageStateDto;
    layout: SmartMessageLayoutDto;
}
declare class SmartMessagePreviewParamsDto {
    state: SmartMessageStateDto;
}
declare class SmartMessageSystemParamsDto {
    state: SmartMessageStateDto;
    workflowStateHumanReadableId: string;
    createdByWalletAddress: string;
    principalWalletAddress: string;
    updatedByWalletAddress: string;
}
declare class CreateSmartMessageTransactionCommandDto {
    account: string;
    actionHumanReadableId: string;
}
declare class SmartMessageTransactionDto {
    transaction: string;
    message?: string;
}
declare class SubmitSmartMessageTransactionCommandDto {
    readonly transaction: string;
    readonly actionHumanReadableId: string;
}

declare class SmartMessageDto$1 {
    id: string;
    content: SmartMessageContentDto;
}

interface Messaging {
    type: string;
    findAll(): Promise<Thread[]>;
    create(command: CreateThreadCommand): Promise<Thread>;
    find(query: FindThreadQuery): Promise<Thread | null>;
    findSummary(query: FindThreadByOtherMemberQuery): Promise<ThreadSummary | null>;
    findSummaryAll(): Promise<ThreadsGeneralSummary | null>;
}
interface ThreadsGeneralSummary {
    unreadMessagesCount: number;
}
interface ThreadSummary {
    id: ThreadId;
    me: ThreadMemberSummary;
}
interface ThreadMemberSummary {
    address: AccountAddress;
    hasUnreadMessages: boolean;
    unreadMessagesCount: number;
}
interface SendMessageCommand$1 {
    text: string;
    deduplicationId?: string;
}
interface MessageAction {
    label: string;
    url: string;
}
interface MessageMetadata {
    title?: string;
    actions?: MessageAction[];
    smartMessage?: SmartMessageDto$1;
    notificationTypeId?: string;
    notificationTypeHumanReadableId?: string;
}
interface ThreadMessage {
    id: string;
    text: string;
    timestamp: Date;
    author: ThreadMember;
    metadata?: MessageMetadata;
    deduplicationId?: string;
}
interface CreateThreadCommand {
    me: Omit<ThreadMember, 'address' | 'lastReadMessageTimestamp'>;
    otherMembers: Omit<ThreadMember, 'lastReadMessageTimestamp'>[];
    encrypted: boolean;
    type?: string;
}
interface AddMembersCommand$1 {
    members: Omit<ThreadMember, 'lastReadMessageTimestamp'>[];
}
type FindThreadQuery = FindThreadByIdQuery | FindThreadByOtherMemberQuery;
interface FindThreadByIdQuery {
    id: ThreadId;
}
interface FindThreadByOtherMemberQuery {
    otherMembers: AccountAddress[];
}
interface FindThreadSummaryByMembers {
    me: AccountAddress;
    otherMembers: AccountAddress[];
}
interface ThreadIdProps {
    address: AccountAddress;
    type?: string;
}
declare class ThreadId {
    readonly address: AccountAddress;
    readonly type?: string;
    constructor({ address, type }: ThreadIdProps);
    equals(other: ThreadId): boolean;
    toString(): string;
}
interface Thread {
    id: ThreadId;
    me: ThreadMember;
    otherMembers: ThreadMember[];
    encryptionEnabled: boolean;
    canBeDecrypted: boolean;
    type: string;
    updatedAt: Date;
    lastMessage: ThreadMessage | null;
    name?: string;
    messages(): Promise<ThreadMessage[]>;
    send(command: SendMessageCommand$1): Promise<void>;
    delete(): Promise<void>;
    markAsRead(): Promise<void>;
    addMembers(command: AddMembersCommand$1): Promise<void>;
    removeMember(address: AccountAddress): Promise<void>;
    rename(name: string): Promise<void>;
}
interface ThreadMember {
    address: AccountAddress;
    scopes: ThreadMemberScope[];
}
declare enum ThreadMemberScope {
    WRITE = "WRITE",
    ADMIN = "ADMIN"
}

interface Wallets {
    readonly address: AccountAddress;
    readonly addresses: WalletAddresses;
    readonly dappAddresses: WalletDappAddresses;
    readonly messages: WalletMessages;
    readonly notificationSubscriptions: WalletNotificationSubscriptions;
    readonly pushNotificationSubscriptions: WalletPushNotificationSubscriptions;
}
interface Wallet {
    readonly address: AccountAddress;
}
interface WalletAddresses {
    create(command: CreateAddressCommand): Promise<Address>;
    update(command: PartialUpdateAddressCommand): Promise<Address>;
    delete(command: DeleteAddressCommand): Promise<void>;
    find(query: FindAddressQuery): Promise<Address | null>;
    findAll(): Promise<Address[]>;
    verify(command: VerifyAddressCommand): Promise<Address>;
    resendVerificationCode(command: ResendVerificationCodeCommand): Promise<void>;
}
interface CreateAddressCommand {
    readonly value: string;
    readonly type: AddressType;
}
interface PartialUpdateAddressCommand {
    readonly addressId: string;
    readonly value?: string;
}
interface FindAddressQuery {
    readonly addressId: string;
}
interface DeleteAddressCommand {
    readonly addressId: string;
}
interface VerifyAddressCommand {
    readonly addressId: string;
    readonly code: string;
}
interface ResendVerificationCodeCommand {
    readonly addressId: string;
}
interface WalletDappAddresses {
    create(command: CreateDappAddressCommand): Promise<DappAddress>;
    update(command: PartialUpdateDappAddressCommand): Promise<DappAddress>;
    delete(command: DeleteDappAddressCommand): Promise<void>;
    find(query: FindDappAddressQuery): Promise<DappAddress | null>;
    findAll(query?: FindDappAddressesQuery$1): Promise<DappAddress[]>;
}
interface CreateDappAddressCommand {
    readonly dappAccountAddress: AccountAddress;
    readonly addressId: string;
    readonly enabled: boolean;
}
interface PartialUpdateDappAddressCommand {
    readonly dappAddressId: string;
    readonly enabled?: boolean;
}
interface FindDappAddressQuery {
    readonly dappAddressId: string;
}
interface FindDappAddressesQuery$1 {
    readonly addressIds?: string[];
    readonly dappAccountAddress?: AccountAddress;
}
interface DeleteDappAddressCommand {
    readonly dappAddressId: string;
}
interface FindDappMessagesSummaryQuery {
    readonly dappVerified?: boolean;
}
interface WalletMessages {
    findAllFromDapps(query?: FindDappMessageQuery): Promise<DappMessage[]>;
    dappMessagesSummary(query?: FindDappMessagesSummaryQuery): Promise<ThreadsGeneralSummary>;
    markAllDappMessagesAsRead(command?: MarkDappMessagesAsReadCommand): Promise<void>;
}
interface DappMessage {
    id: string;
    text: string;
    timestamp: Date;
    author: AccountAddress;
    metadata?: Pick<MessageMetadata, 'title' | 'actions'>;
}
interface FindDappMessageQuery {
    readonly skip?: number;
    readonly take?: number;
    readonly dappVerified?: boolean;
}
interface MarkDappMessagesAsReadCommand {
    readonly dappVerified?: boolean;
}
interface WalletNotificationSubscriptions {
    findAll(query: FindNotificationSubscriptionQuery): Promise<WalletNotificationSubscription[]>;
    upsert(command: UpsertNotificationSubscriptionCommand): Promise<WalletNotificationSubscription>;
}
interface WalletPushNotificationSubscriptions {
    delete(physicalId: string): Promise<void>;
    upsert(command: UpsertPushNotificationSubscriptionCommand): Promise<WalletPushNotificationSubscription>;
    get(physicalId: string): Promise<WalletPushNotificationSubscription>;
}
interface FindNotificationSubscriptionQuery {
    readonly dappAccountAddress: AccountAddress;
}
interface WalletNotificationSubscription {
    notificationType: NotificationType;
    subscription: NotificationSubscription;
}
interface WalletPushNotificationSubscription {
    walletAddress: string;
    physicalId: string;
    token: string;
}
declare class NotificationSubscription {
    wallet: Wallet;
    config: NotificationConfig;
}
interface NotificationType {
    id: string;
    name: string;
    humanReadableId: string;
    trigger?: string;
    orderingPriority?: number;
    tags: string[];
    defaultConfig: NotificationConfig;
    dappId: string;
}
interface NotificationConfig {
    enabled: boolean;
}
interface UpsertNotificationSubscriptionCommand {
    readonly notificationTypeId: string;
    readonly config: NotificationConfig;
}
interface UpsertPushNotificationSubscriptionCommand {
    readonly physicalId: string;
    readonly token: string;
}

interface DiffeHellmanKeys {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}

declare abstract class EncryptionKeysStore {
    static createInMemory(): EncryptionKeysStore;
    static createSessionStorage(): EncryptionKeysStore;
    static createLocalStorage(): EncryptionKeysStore;
    abstract get(subject: AccountAddress): DiffeHellmanKeys | null;
    abstract save(subject: AccountAddress, keys: DiffeHellmanKeys): DiffeHellmanKeys;
}
declare function serializeDiffeHellmanKeys(keys: DiffeHellmanKeys): string;
declare function deserializeDiffeHellmanKeys(data: string): DiffeHellmanKeys;

interface Dapps {
    create(command: CreateDappCommand): Promise<Dapp>;
    patch(command: PatchDappCommand): Promise<Dapp>;
    find(query?: FindOneDappQuery): Promise<Dapp | null>;
    findAll(query?: FindDappQuery): Promise<ReadOnlyDapp[]>;
}
declare enum BlockchainType {
    SOLANA = "SOLANA",
    APTOS = "APTOS",
    EVM = "EVM"
}
interface Dapp {
    id: string;
    address: AccountAddress;
    name: string;
    description?: string;
    websiteUrl?: string;
    avatarUrl?: string;
    heroUrl?: string;
    verified: boolean;
    telegramUsername: string;
    blockchainType: BlockchainType;
    dappAddresses: DappAddresses;
    messages: DappMessages;
    notificationTypes: DappNotificationTypes;
    notificationSubscriptions: DappNotificationSubscriptions;
}
type ReadOnlyDapp = Omit<Dapp, 'dappAddresses' | 'messages' | 'notificationTypes' | 'notificationSubscriptions'>;
interface DappAddresses {
    findAll(): Promise<DappAddress[]>;
}
interface DappMessages {
    send(command: SendDappMessageCommand): Promise<void>;
}
interface CreateDappCommand {
    name: string;
    description?: string;
    websiteUrl?: string;
    avatarUrl?: string;
    heroUrl?: string;
    telegramBotConfiguration?: DappTelegramBotConfiguration;
    blockchainType: BlockchainType;
}
interface PatchDappCommand {
    name?: string;
    description?: string | null;
    websiteUrl?: string | null;
    avatarUrl?: string | null;
    heroUrl?: string | null;
}
interface DappTelegramBotConfiguration {
    token: string;
}
interface FindOneDappQuery {
    address?: AccountAddress;
}
interface FindDappQuery {
    verified?: boolean;
    blockchainType?: BlockchainType;
}
declare enum DappMessageActionType {
    LINK = "Link",
    SMART_MESSAGE = "SmartMessage"
}
interface DappMessageActionBase {
    type: DappMessageActionType;
}
interface DappMessageLinksAction extends DappMessageActionBase {
    type: DappMessageActionType.LINK;
    links: [DappMessageLinkAction$1];
}
interface DappMessageLinkAction$1 {
    label: string;
    url: string;
}
interface DappMessageSmartMessageAction extends DappMessageActionBase {
    type: DappMessageActionType.SMART_MESSAGE;
    smartMessage: SmartMessage;
}
interface SmartMessage {
    transactionServiceId: string;
    transactionParams: SmartMessageParams;
}
interface SmartMessageParams {
}
interface SendDappMessageCommandBase {
    message: string;
    title?: string;
    imageUrl?: string;
    notificationTypeId?: string;
    addressTypes?: AddressType[];
}
interface BroadcastDappMessageCommand extends SendDappMessageCommandBase {
    actionsV2?: DappMessageLinksAction;
}
interface UnicastDappMessageCommand extends SendDappMessageCommandBase {
    recipient: AccountAddress;
    actionsV2?: DappMessageLinksAction | DappMessageSmartMessageAction;
}
interface MulticastDappMessageCommand extends SendDappMessageCommandBase {
    recipients: AccountAddress[];
    actionsV2?: DappMessageLinksAction;
}
type SendDappMessageCommand = BroadcastDappMessageCommand | UnicastDappMessageCommand | MulticastDappMessageCommand;
interface DappNotificationTypes {
    create(command: CreateNotificationTypeCommand): Promise<NotificationType>;
    findAll(): Promise<NotificationType[]>;
    find(id: string): Promise<NotificationType>;
    patch(id: string, command: PatchNotificationTypeCommand): Promise<NotificationType>;
    delete(id: string): Promise<void>;
}
interface CreateNotificationTypeCommand {
    name: string;
    humanReadableId: string;
    trigger?: string;
    orderingPriority?: number;
    tags?: string[];
    defaultConfig: NotificationConfig;
}
interface PatchNotificationTypeCommand {
    name?: string;
    humanReadableId?: string;
    trigger?: string;
    orderingPriority?: number;
    tags?: string[];
    defaultConfig?: NotificationConfig;
}
interface DappNotificationSubscriptions {
    findAll(): Promise<DappNotificationSubscription[]>;
}
declare class DappNotificationSubscription {
    notificationType: NotificationType;
    subscriptions: NotificationSubscription[];
}

interface Identity {
    type: string;
    address: AccountAddress;
    name: string;
    additionals?: {
        avatarUrl?: string;
        link?: string;
        displayName?: string;
        [key: string]: any;
    };
}
declare abstract class IdentityResolver {
    abstract resolve(address: AccountAddress): Promise<Identity | null>;
    abstract resolveReverse(domainName: string): Promise<Identity | null>;
    abstract get type(): string;
}

declare abstract class EncryptionKeysProvider {
    static create(delegate: EncryptionKeysProvider, encryptionKeysStore?: EncryptionKeysStore): EncryptionKeysProvider;
    abstract isAvailable(): boolean;
    abstract getFailSafe(subject: AccountAddress): Promise<DiffeHellmanKeys | null>;
    abstract getFailFast(subject: AccountAddress): Promise<DiffeHellmanKeys>;
}

declare abstract class Dialect {
    static sdk<ChainSdk extends BlockchainSdk>(configProps: ConfigProps, blockchainSdkFactory: BlockchainSdkFactory<ChainSdk>): DialectSdk<ChainSdk>;
}
interface ConfigProps {
    environment?: Environment;
    dialectCloud?: DialectCloudConfigProps;
    encryptionKeysStore?: EncryptionKeysStoreType | EncryptionKeysStore;
    identity?: IdentityConfigProps;
}
interface BlockchainSdkFactory<ChainSdk extends BlockchainSdk> {
    create(config: Config): ChainSdk;
}
declare abstract class BlockchainSdk {
    readonly type: string;
    readonly info: BlockChainSdkInfo;
    readonly authenticationFacade: AuthenticationFacade;
    readonly encryptionKeysProvider: EncryptionKeysProvider;
    readonly messaging?: Messaging;
    readonly dappMessages?: DappMessages;
    readonly dappAddresses?: DappAddresses;
}
interface BlockChainSdkInfo {
    supportsOnChainMessaging: boolean;
}
declare abstract class DialectSdk<ChainSdk extends BlockchainSdk> {
    readonly info: DialectSdkInfo;
    readonly config: Config;
    readonly threads: Messaging;
    readonly dapps: Dapps;
    readonly wallet: Wallets;
    readonly identity: IdentityResolver;
    readonly tokenProvider: TokenProvider;
    readonly encryptionKeysProvider: EncryptionKeysProvider;
    readonly blockchainSdk: ChainSdk;
}
interface DialectSdkInfo {
    supportsEndToEndEncryption: boolean;
    hasValidAuthentication: boolean;
}
type Environment = 'production' | 'development' | 'local-development';
type TokenStoreType = 'in-memory' | 'session-storage' | 'local-storage';
type EncryptionKeysStoreType = 'in-memory' | 'session-storage' | 'local-storage';
type WalletCreation = 'none' | 'implicit';
interface DialectCloudConfigProps {
    environment?: DialectCloudEnvironment;
    url?: string;
    tokenStore?: TokenStoreType | TokenStore;
    tokenLifetimeMinutes?: number;
    walletCreation?: WalletCreation;
}
type DialectCloudEnvironment = 'production' | 'development' | 'local-development';
type IdentityResolveStrategy = 'first-found' | 'first-found-fast' | 'aggregate-sequential';
interface IdentityConfigProps {
    strategy?: IdentityResolveStrategy;
    resolvers?: IdentityResolver[];
}
interface Config extends ConfigProps {
    environment: Environment;
    dialectCloud: DialectCloudConfig;
    encryptionKeysStore: EncryptionKeysStore;
    identity: IdentityConfig;
}
interface DialectCloudConfig extends DialectCloudConfigProps {
    environment: DialectCloudEnvironment;
    url: string;
    tokenStore: TokenStore;
    tokenLifetimeMinutes: number;
    walletCreation: WalletCreation;
}
interface IdentityConfig extends IdentityConfigProps {
    strategy: IdentityResolveStrategy;
    resolvers: IdentityResolver[];
}

declare const DEFAULT_TOKEN_LIFETIME_SECONDS: number;
declare const MAX_TOKEN_LIFETIME_SECONDS: number;
declare abstract class TokenProvider {
    static create(authenticationFacade: AuthenticationFacade, dataServiceWalletsApiClientV1: DataServiceWalletsApiClientV1, ttlSeconds?: number, tokenStore?: TokenStore, walletCreation?: WalletCreation): TokenProvider;
    abstract get(): Promise<Token>;
}
declare class DefaultTokenProvider extends TokenProvider {
    private readonly ttlSeconds;
    private readonly tokenGenerator;
    constructor(ttlSeconds: number, tokenGenerator: TokenGenerator);
    get(): Promise<Token>;
}
declare class CachedTokenProvider extends TokenProvider {
    private readonly delegate;
    private readonly tokenStore;
    private readonly walletCreation;
    private readonly tokenParser;
    private readonly tokenValidator;
    private readonly subject;
    private readonly dataServiceWalletsApiClientV1;
    private readonly delegateGetPromises;
    constructor(delegate: TokenProvider, tokenStore: TokenStore, walletCreation: WalletCreation, tokenParser: TokenParser, tokenValidator: TokenValidator, subject: AccountAddress, dataServiceWalletsApiClientV1: DataServiceWalletsApiClientV1);
    get(): Promise<Token>;
    hasValidCachedToken(): boolean;
    private getCachedToken;
}

interface DataServiceDappsApi {
    create(command: Omit<CreateDappCommandDto, 'publicKey'>): Promise<DappDto>;
    patch(command: PatchDappCommandDto): Promise<DappDto>;
    findAll(query?: FindDappQueryDto): Promise<DappDto[]>;
    find(dappAddress?: string): Promise<DappDto>;
    findAllDappAddresses(): Promise<DappAddressDto[]>;
    unicast(command: UnicastDappMessageCommandDto): Promise<void>;
    multicast(command: MulticastDappMessageCommandDto): Promise<void>;
    broadcast(command: BroadcastDappMessageCommandDto): Promise<void>;
}
declare class DappDto {
    readonly id: string;
    readonly publicKey: string;
    readonly name: string;
    readonly description?: string;
    readonly websiteUrl?: string;
    readonly avatarUrl?: string;
    readonly heroUrl?: string;
    readonly telegramBotUserName: string;
    readonly verified: boolean;
    readonly blockchainType: BlockchainType;
}
declare class CreateDappCommandDto {
    readonly name: string;
    readonly publicKey: string;
    readonly description?: string;
    readonly websiteUrl?: string;
    readonly avatarUrl?: string;
    readonly heroUrl?: string;
    readonly telegramBotConfiguration?: DappTelegramBotConfigurationDto;
    readonly blockchainType?: string;
}
declare class PatchDappCommandDto {
    readonly name?: string;
    readonly description?: string | null;
    readonly websiteUrl?: string | null;
    readonly avatarUrl?: string | null;
    readonly heroUrl?: string | null;
}
declare class DappTelegramBotConfigurationDto {
    readonly token: string;
}
declare class DappAddressDto {
    readonly id: string;
    readonly enabled: boolean;
    readonly dapp: DappDto;
    readonly channelId?: string;
    readonly address: AddressDto;
}
declare class AddressDto {
    readonly id: string;
    readonly type: AddressTypeDto;
    readonly verified: boolean;
    readonly value: string;
    readonly wallet: WalletDto;
}
declare class WalletDto {
    readonly id: string;
    readonly publicKey: string;
}
declare enum AddressTypeDto {
    Email = "EMAIL",
    PhoneNumber = "PHONE_NUMBER",
    Telegram = "TELEGRAM",
    Wallet = "WALLET"
}
declare enum DappMessageActionTypeDto {
    LINK = "Link",
    SMART_MESSAGE = "SmartMessage"
}
interface DappMessageActionBaseDto {
    type: DappMessageActionTypeDto;
}
declare class DappMessageLinksActionDto implements DappMessageActionBaseDto {
    type: DappMessageActionTypeDto.LINK;
    links: DappMessageLinkAction[];
}
declare class DappMessageLinkAction {
    label: string;
    url: string;
}
declare class DappMessageSmartMessageActionDto implements DappMessageActionBaseDto {
    type: DappMessageActionTypeDto.SMART_MESSAGE;
    smartMessage: SmartMessageDto;
}
declare class SmartMessageDto {
    transactionServiceId: string;
    transactionParams: Record<string, any>;
}
declare class SendDappMessageCommandDto {
    title?: string;
    message: string;
    imageUrl?: string;
    notificationTypeId?: string;
    addressTypes?: AddressTypeDto[];
}
declare class UnicastDappMessageCommandDto extends SendDappMessageCommandDto {
    recipientPublicKey: string;
    actionsV2?: DappMessageLinksActionDto | DappMessageSmartMessageActionDto;
}
declare class MulticastDappMessageCommandDto extends SendDappMessageCommandDto {
    recipientPublicKeys: string[];
    actionsV2?: DappMessageLinksActionDto;
}
declare class BroadcastDappMessageCommandDto extends SendDappMessageCommandDto {
    actionsV2?: DappMessageLinksActionDto;
}
declare class FindDappQueryDto {
    verified?: boolean;
    blockchainType?: BlockchainType;
}

interface Address {
    id: string;
    type: AddressType;
    verified: boolean;
    value: string;
    wallet: Wallet;
}
declare enum AddressType {
    Email = "EMAIL",
    PhoneNumber = "PHONE_NUMBER",
    Telegram = "TELEGRAM",
    Wallet = "WALLET"
}
declare function toAddressTypeDto(type: AddressType): AddressTypeDto;
declare function toAddressType(type: AddressTypeDto): AddressType;
interface DappAddress {
    id: string;
    dappId: string;
    enabled: boolean;
    channelId?: string | null;
    address: Address;
}

declare class DefaultTokenGenerator extends TokenGenerator {
    generate(ttlSeconds: number): Promise<Token>;
}

declare class Ed25519TokenSigner implements TokenSigner {
    readonly keypair: SignKeyPair;
    readonly subjectPublicKey: PublicKey;
    readonly subject: AccountAddress;
    readonly alg = "ed25519";
    constructor(keypair?: SignKeyPair, subjectPublicKey?: PublicKey, subject?: AccountAddress);
    sign(payload: Uint8Array): Promise<TokenSignerResult>;
}

declare class Ed25519AuthenticationFacadeFactory extends AuthenticationFacadeFactory {
    private readonly tokenSigner;
    constructor(tokenSigner: Ed25519TokenSigner);
    get(): AuthenticationFacade;
    static createAuthenticator(): Authenticator;
}

declare class Ed25519TokenBodyParser extends TokenBodyParser {
    parse(base64Body: string): TokenBody;
}

declare function generateEd25519Keypair(): nacl.SignKeyPair;

type Ed25519PublicKeyInitData = string | Uint8Array;
declare class Ed25519PublicKey extends PublicKey {
    private readonly value;
    constructor(value: Ed25519PublicKeyInitData);
    toBytes(): Uint8Array;
    toString(): string;
}

declare abstract class MessagingError extends DialectSdkError {
}
declare class ThreadAlreadyExistsError extends MessagingError {
    constructor();
}

interface DataServiceDialectsApi {
    create(command: CreateDialectCommand): Promise<DialectAccountDto>;
    findAll(): Promise<DialectAccountDto[]>;
    find(dialectId: string): Promise<DialectAccountDto>;
    findByMembers(query: FindDialectByMembersQueryDto): Promise<DialectAccountDto>;
    delete(dialectId: string): Promise<void>;
    sendMessage(dialectId: string, command: SendMessageCommand): Promise<void>;
    getMessages(dialectId: string): Promise<MessagesDto>;
    findSummary(query: FindDialectByMembersQueryDto): Promise<DialectSummaryDto>;
    findSummaryAll(query: FindDialectsSummaryDto): Promise<DialectsSummaryDto>;
    patch(dialectId: string, command: PatchDialectCommand): Promise<DialectAccountDto>;
    addMembers(dialectId: string, members: AddMembersCommand): Promise<void>;
    removeMember(dialectId: string, memberAddress: string): Promise<void>;
    markAsRead(dialectId: string): Promise<void>;
}
interface CreateDialectCommand {
    readonly members: PostMemberDto[];
    readonly encrypted: boolean;
}
interface AddMembersCommand {
    readonly members: PostMemberDto[];
}
interface PostMemberDto {
    readonly address: string;
    readonly scopes: MemberScopeDto[];
}
interface DialectAccountDto {
    readonly id: string;
    readonly dialect: DialectDto;
}
interface DialectDto {
    readonly members: MemberDto[];
    readonly lastMessage?: MessageDto;
    readonly updatedAt: number;
    readonly encrypted: boolean;
    readonly groupName?: string;
}
interface MemberDto {
    readonly address: string;
    readonly scopes: MemberScopeDto[];
    readonly lastReadMessageTimestamp: number;
}
declare enum MemberScopeDto {
    ADMIN = "ADMIN",
    WRITE = "WRITE"
}
declare class MessageActionDto {
    label: string;
    url: string;
}
declare class MessageMetadataDto {
    title?: string;
    tags?: string[];
    actions?: MessageActionDto[];
    smartMessage?: SmartMessageDto$1;
    notificationTypeId?: string;
}
interface MessageDto {
    readonly id: string;
    readonly owner: string;
    readonly text: number[];
    readonly timestamp: number;
    readonly deduplicationId?: string;
    readonly metadata?: MessageMetadataDto;
}
interface MessagesDto {
    readonly messages: MessageDto[];
}
interface SendMessageCommand {
    readonly text: number[];
    readonly deduplicationId?: string;
}
interface PatchDialectCommand {
    readonly groupName: string;
}
interface DialectSummaryDto {
    readonly id: string;
    readonly memberSummaries: MemberSummaryDto[];
}
interface DialectsSummaryDto {
    readonly unreadMessagesCount: number;
}
interface MemberSummaryDto {
    readonly address: string;
    readonly hasUnreadMessages: boolean;
    readonly unreadMessagesCount: number;
}
interface FindDialectByMembersQueryDto {
    readonly memberAddresses: string[];
}
interface FindDialectsSummaryDto {
    readonly address: string;
}

interface TextSerde {
    serialize(text: string): Uint8Array;
    deserialize(bytes: Uint8Array): string;
}

declare class DataServiceMessaging implements Messaging {
    private readonly me;
    private readonly dataServiceDialectsApi;
    private readonly encryptionKeysProvider;
    readonly type = "dialect-cloud";
    constructor(me: AccountAddress, dataServiceDialectsApi: DataServiceDialectsApi, encryptionKeysProvider: EncryptionKeysProvider);
    create(command: CreateThreadCommand): Promise<Thread>;
    find(query: FindThreadQuery): Promise<Thread | null>;
    findAll(): Promise<Thread[]>;
    findSummary(query: FindThreadByOtherMemberQuery): Promise<ThreadSummary | null>;
    findSummaryAll(): Promise<ThreadsGeneralSummary>;
    private checkEncryptionSupported;
    private toDataServiceThread;
    private createTextSerde;
    private findInternal;
    private findById;
    private findByOtherMember;
}
declare class DataServiceThread implements Thread {
    private readonly dataServiceDialectsApi;
    private readonly textSerde;
    private readonly encryptionKeysProvider;
    private readonly address;
    readonly me: ThreadMember;
    readonly otherMembers: ThreadMember[];
    private readonly otherMembersPks;
    readonly encryptionEnabled: boolean;
    readonly canBeDecrypted: boolean;
    updatedAt: Date;
    lastMessage: ThreadMessage | null;
    name?: string | undefined;
    readonly type = "dialect-cloud";
    readonly id: ThreadId;
    constructor(dataServiceDialectsApi: DataServiceDialectsApi, textSerde: TextSerde, encryptionKeysProvider: EncryptionKeysProvider, address: AccountAddress, me: ThreadMember, otherMembers: ThreadMember[], otherMembersPks: Record<string, ThreadMember>, encryptionEnabled: boolean, canBeDecrypted: boolean, updatedAt: Date, lastMessage: ThreadMessage | null, name?: string | undefined);
    delete(): Promise<void>;
    messages(): Promise<ThreadMessage[]>;
    send(command: SendMessageCommand$1): Promise<void>;
    markAsRead(): Promise<void>;
    addMembers(command: AddMembersCommand$1): Promise<void>;
    removeMember(address: AccountAddress): Promise<void>;
    rename(name: string): Promise<void>;
    private encryptionEnabledButCannotBeUsed;
}

declare function bytesToBase64(bytes: Uint8Array): string;
declare function bytesFromBase64(base64: string): Uint8Array;
declare function jsonStringifyToBase64<T>(t: T): string;
declare function jsonParseFromBase64<T>(serialized: string): T;

declare const DIALECT_API_TYPE_DIALECT_CLOUD = "dialect-cloud";

declare class FirstFoundIdentityResolver extends IdentityResolver {
    private readonly resolvers;
    constructor(resolvers: IdentityResolver[]);
    get type(): string;
    resolve(address: AccountAddress): Promise<Identity | null>;
    resolveReverse(domainName: string): Promise<Identity | null>;
}
declare class FirstFoundFastIdentityResolver extends IdentityResolver {
    private readonly resolvers;
    constructor(resolvers: IdentityResolver[]);
    get type(): string;
    resolve(address: AccountAddress): Promise<Identity | null>;
    resolveReverse(domainName: string): Promise<Identity | null>;
}
declare class AggregateSequentialIdentityResolver extends IdentityResolver {
    private readonly resolvers;
    constructor(resolvers: IdentityResolver[]);
    get type(): string;
    resolve(address: AccountAddress): Promise<Identity | null>;
    resolveReverse(domainName: string): Promise<Identity | null>;
}

interface FindNotificationSubscriptionQueryDto {
    readonly dappPublicKey: string;
}
interface WalletNotificationSubscriptionDto {
    notificationType: NotificationTypeDto;
    subscription: NotificationSubscriptionDto;
}
declare class NotificationSubscriptionDto {
    wallet: WalletDto;
    config: NotificationConfigDto;
}
interface NotificationTypeDto {
    id: string;
    name: string;
    humanReadableId: string;
    trigger?: string;
    orderingPriority?: number;
    tags: string[];
    defaultConfig: NotificationConfigDto;
    dappId: string;
}
interface NotificationConfigDto {
    enabled: boolean;
}
interface UpsertNotificationSubscriptionCommandDto {
    readonly notificationTypeId: string;
    readonly config: NotificationConfigDto;
}
interface DataServiceWalletNotificationSubscriptionsApi {
    findAll(query: FindNotificationSubscriptionQueryDto): Promise<WalletNotificationSubscriptionDto[]>;
    upsert(command: UpsertNotificationSubscriptionCommandDto): Promise<WalletNotificationSubscriptionDto>;
}

type AddressTypeV0 = 'email' | 'sms' | 'telegram' | 'wallet';
interface CreateAddressCommandV0 {
    type: string;
    value: string;
    enabled: boolean;
}
interface DeleteAddressCommandV0 {
    id: string;
}
interface DappAddressDtoV0 {
    id: string;
    type: AddressTypeV0;
    verified: boolean;
    addressId: string;
    dapp: string;
    enabled: boolean;
    value: string;
}
interface DataServiceWalletsApiV0 {
    createDappAddress(command: CreateAddressCommandV0, dapp: string): Promise<DappAddressDtoV0>;
    deleteDappAddress(command: DeleteAddressCommandV0): Promise<void>;
    findAllDappAddresses(dappPublicKey: string): Promise<DappAddressDtoV0[]>;
}

interface DataServiceWalletDappAddressesApi {
    create(command: CreateDappAddressCommandDto): Promise<DappAddressDto>;
    patch(dappAddressId: string, command: PartialUpdateDappAddressCommandDto): Promise<DappAddressDto>;
    delete(dappAddressId: string): Promise<void>;
    find(dappAddressId: string): Promise<DappAddressDto>;
    findAll(query?: FindDappAddressesQuery): Promise<DappAddressDto[]>;
}
interface CreateDappAddressCommandDto {
    readonly dappPublicKey: string;
    readonly addressId: string;
    readonly enabled: boolean;
}
interface PartialUpdateDappAddressCommandDto {
    readonly enabled?: boolean;
}
interface FindDappAddressesQuery {
    readonly dappPublicKey?: string;
    readonly addressIds?: string[];
}

interface DataServiceWalletAddressesApi {
    create(command: CreateAddressCommandDto): Promise<AddressDto>;
    patch(addressId: string, command: PatchAddressCommandDto): Promise<AddressDto>;
    delete(addressId: string): Promise<void>;
    find(addressId: string): Promise<AddressDto>;
    findAll(): Promise<AddressDto[]>;
    verify(addressId: string, command: VerifyAddressCommandDto): Promise<AddressDto>;
    resendVerificationCode(addressId: string): Promise<void>;
}
interface CreateAddressCommandDto {
    readonly value: string;
    readonly type: AddressTypeDto;
}
interface PatchAddressCommandDto {
    readonly value?: string;
}
interface VerifyAddressCommandDto {
    readonly code: string;
}

interface DataServicePushNotificationSubscriptionsApi {
    delete(physicalId: string): Promise<void>;
    upsert(command: UpsertPushNotificationSubscriptionCommandDto): Promise<PushNotificationSubscriptionDto>;
    get(physicalId: string): Promise<PushNotificationSubscriptionDto>;
}
declare class PushNotificationSubscriptionDto {
    walletPublicKey: string;
    physicalId: string;
    token: string;
}
declare class UpsertPushNotificationSubscriptionCommandDto {
    physicalId: string;
    token: string;
}

interface DataServiceDappNotificationTypesApi {
    create(command: CreateNotificationTypeCommandDto): Promise<NotificationTypeDto>;
    findAll(): Promise<NotificationTypeDto[]>;
    find(id: string): Promise<NotificationTypeDto>;
    patch(id: string, command: PatchNotificationTypeCommandDto): Promise<NotificationTypeDto>;
    delete(id: string): Promise<void>;
}
interface PatchNotificationTypeCommandDto {
    name?: string;
    humanReadableId?: string;
    trigger?: string;
    orderingPriority?: number;
    tags?: string[];
    defaultConfig?: NotificationConfigDto;
}
interface CreateNotificationTypeCommandDto {
    name: string;
    humanReadableId: string;
    trigger?: string;
    orderingPriority?: number;
    tags?: string[];
    defaultConfig: NotificationConfigDto;
}

interface DataServiceWalletMessagesApi {
    findAllDappMessages(query?: FindWalletMessagesQueryDto): Promise<MessageDto[]>;
    dappMessagesSummary(query?: FindDappMessagesSummaryQueryDto): Promise<DialectsSummaryDto>;
    markAllDappMessagesAsRead(command?: MarkDappMessagesAsReadCommandDto): Promise<void>;
}
interface FindDappMessagesSummaryQueryDto {
    readonly dappVerified?: boolean;
}
interface FindWalletMessagesQueryDto {
    readonly skip?: number;
    readonly take?: number;
    readonly dappVerified?: boolean;
}
interface MarkDappMessagesAsReadCommandDto {
    readonly dappVerified?: boolean;
}

interface DataServiceDappNotificationSubscriptionsApi {
    findAll(): Promise<DappNotificationSubscriptionDto[]>;
}
declare class DappNotificationSubscriptionDto {
    notificationType: NotificationTypeDto;
    subscriptions: NotificationSubscriptionDto[];
}

declare type HealthCheckStatusDto = 'error' | 'ok' | 'shutting_down';
declare type HealthIndicatorStatusDto = 'up' | 'down';
declare type HealthIndicatorResultDto = {
    [key: string]: {
        status: HealthIndicatorStatusDto;
        [optionalKeys: string]: any;
    };
};
interface HealthCheckResultDto {
    readonly status: HealthCheckStatusDto;
    readonly info?: HealthIndicatorResultDto;
    readonly error?: HealthIndicatorResultDto;
    readonly details: HealthIndicatorResultDto;
}
interface DataServiceHealthApi {
    healthCheck(): Promise<HealthCheckResultDto>;
}

declare class DataServiceApi {
    readonly threads: DataServiceDialectsApi;
    readonly dapps: DataServiceDappsApi;
    readonly dappNotificationTypes: DataServiceDappNotificationTypesApi;
    readonly dappNotificationSubscriptions: DataServiceDappNotificationSubscriptionsApi;
    readonly walletsV0: DataServiceWalletsApiV0;
    readonly walletAddresses: DataServiceWalletAddressesApi;
    readonly walletDappAddresses: DataServiceWalletDappAddressesApi;
    readonly walletMessages: DataServiceWalletMessagesApi;
    readonly walletNotificationSubscriptions: DataServiceWalletNotificationSubscriptionsApi;
    readonly pushNotificationSubscriptions: DataServicePushNotificationSubscriptionsApi;
    readonly health: DataServiceHealthApi;
    constructor(threads: DataServiceDialectsApi, dapps: DataServiceDappsApi, dappNotificationTypes: DataServiceDappNotificationTypesApi, dappNotificationSubscriptions: DataServiceDappNotificationSubscriptionsApi, walletsV0: DataServiceWalletsApiV0, walletAddresses: DataServiceWalletAddressesApi, walletDappAddresses: DataServiceWalletDappAddressesApi, walletMessages: DataServiceWalletMessagesApi, walletNotificationSubscriptions: DataServiceWalletNotificationSubscriptionsApi, pushNotificationSubscriptions: DataServicePushNotificationSubscriptionsApi, health: DataServiceHealthApi);
}
type DataServiceApiClientError = NetworkError | DataServiceApiError;
declare class NetworkError {
}
declare class DataServiceApiError {
    readonly error: string;
    readonly statusCode: number;
    readonly message?: string | null | undefined;
    readonly requestId?: string | null | undefined;
    constructor(error: string, statusCode: number, message?: string | null | undefined, requestId?: string | null | undefined);
}
declare function createHeaders(token?: Token): {
    "x-request-id": string;
    "x-client-name": string;
    "x-client-version": string;
    Authorization?: string | undefined;
};
declare function withReThrowingDataServiceError<T>(fn: Promise<T>): Promise<T>;

declare class DataServiceApiFactory {
    static create(baseUrl: string, tokenProvider: TokenProvider): DataServiceApi;
}

var version = "1.9.4";

export { type AccountAddress, ActionType, type AddMembersCommand$1 as AddMembersCommand, type Address, AddressType, AggregateSequentialIdentityResolver, AuthenticationError, AuthenticationFacade, AuthenticationFacadeFactory, Authenticator, AuthorizationError, type BlockChainSdkInfo, BlockchainSdk, type BlockchainSdkFactory, BlockchainType, type BroadcastDappMessageCommand, BusinessConstraintViolationError, CachedTokenProvider, type Config, type ConfigProps, type CreateAddressCommand, type CreateDappAddressCommand, type CreateDappCommand, type CreateNotificationTypeCommand, CreateSmartMessageTransactionCommandDto, type CreateThreadCommand, DEFAULT_TOKEN_LIFETIME_SECONDS, DIALECT_API_TYPE_DIALECT_CLOUD, type Dapp, type DappAddress, type DappAddresses, type DappMessage, DappMessageActionType, type DappMessageLinkAction$1 as DappMessageLinkAction, type DappMessageLinksAction, type DappMessageSmartMessageAction, type DappMessages, DappNotificationSubscription, type DappNotificationSubscriptions, type DappNotificationTypes, type DappTelegramBotConfiguration, type Dapps, DataServiceApi, type DataServiceApiClientError, DataServiceApiError, DataServiceApiFactory, DataServiceMessaging, DataServiceThread, DataServiceWalletsApiClientV1, type DataServiceWalletsApiV1, DefaultTokenGenerator, DefaultTokenProvider, type DeleteAddressCommand, type DeleteDappAddressCommand, Dialect, type DialectCloudConfig, type DialectCloudConfigProps, type DialectCloudEnvironment, DialectSdk, DialectSdkError, type DialectSdkInfo, type DiffeHellmanKeys, Ed25519AuthenticationFacadeFactory, Ed25519PublicKey, type Ed25519PublicKeyInitData, Ed25519TokenBodyParser, Ed25519TokenSigner, EncryptionKeysProvider, EncryptionKeysStore, type EncryptionKeysStoreType, type Environment, type FindAddressQuery, type FindDappAddressQuery, type FindDappAddressesQuery$1 as FindDappAddressesQuery, type FindDappMessageQuery, type FindDappMessagesSummaryQuery, type FindDappQuery, type FindNotificationSubscriptionQuery, type FindOneDappQuery, type FindThreadByIdQuery, type FindThreadByOtherMemberQuery, type FindThreadQuery, type FindThreadSummaryByMembers, FirstFoundFastIdentityResolver, FirstFoundIdentityResolver, type Identity, type IdentityConfig, type IdentityConfigProps, IdentityError, IdentityResolver, IllegalArgumentError, IllegalStateError, MAX_TOKEN_LIFETIME_SECONDS, type MarkDappMessagesAsReadCommand, type MessageAction, type MessageMetadata, type Messaging, MessagingError, type MulticastDappMessageCommand, NetworkError, type NotificationConfig, NotificationSubscription, type NotificationType, type PartialUpdateAddressCommand, type PartialUpdateDappAddressCommand, type PatchDappCommand, type PatchNotificationTypeCommand, PublicKey, type ReadOnlyDapp, type ResendVerificationCodeCommand, ResourceAlreadyExistsError, ResourceNotFoundError, version as SDK_VERSION, type SendDappMessageCommand, type SendDappMessageCommandBase, type SendMessageCommand$1 as SendMessageCommand, type SmartMessage, SmartMessageButtonLayoutElementDto, SmartMessageContentDto, SmartMessageDto$1 as SmartMessageDto, SmartMessageLabelLayoutElementDto, SmartMessageLayoutDto, type SmartMessageLayoutElementDto, type SmartMessageParams, SmartMessagePreviewParamsDto, type SmartMessageSpecActionDto, SmartMessageSpecCancelActionDto, SmartMessageSpecOpenLinkActionDto, SmartMessageSpecSignTransactionActionDto, SmartMessageStateDto, SmartMessageSystemParamsDto, SmartMessageTransactionDto, SubmitSmartMessageTransactionCommandDto, type Thread, ThreadAlreadyExistsError, ThreadId, type ThreadIdProps, type ThreadMember, ThreadMemberScope, type ThreadMemberSummary, type ThreadMessage, type ThreadSummary, type ThreadsGeneralSummary, type Token, type TokenBody, TokenBodyParser, TokenGenerator, type TokenHeader, TokenHeaderParser, TokenParser, TokenParsingError, TokenProvider, TokenSigner, type TokenSignerResult, TokenStore, type TokenStoreType, TokenStructureValidationError, TokenUnsupportedAlgError, TokenValidator, type UnicastDappMessageCommand, UnknownError, UnsupportedOperationError, type UpsertNotificationSubscriptionCommand, type UpsertPushNotificationSubscriptionCommand, type VerifyAddressCommand, type Wallet, type WalletAddresses, type WalletCreation, type WalletDappAddresses, type WalletMessages, type WalletNotificationSubscription, type WalletNotificationSubscriptions, type WalletPushNotificationSubscription, type WalletPushNotificationSubscriptions, type Wallets, bytesFromBase64, bytesToBase64, createHeaders, deserializeDiffeHellmanKeys, generateEd25519Keypair, jsonParseFromBase64, jsonStringifyToBase64, serializeDiffeHellmanKeys, toAddressType, toAddressTypeDto, withReThrowingDataServiceError };
