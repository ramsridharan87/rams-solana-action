"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ActionType: () => ActionType,
  AddressType: () => AddressType,
  AggregateSequentialIdentityResolver: () => AggregateSequentialIdentityResolver,
  AuthenticationError: () => AuthenticationError,
  AuthenticationFacade: () => AuthenticationFacade,
  AuthenticationFacadeFactory: () => AuthenticationFacadeFactory,
  Authenticator: () => Authenticator,
  AuthorizationError: () => AuthorizationError,
  BlockchainSdk: () => BlockchainSdk,
  BlockchainType: () => BlockchainType,
  BusinessConstraintViolationError: () => BusinessConstraintViolationError,
  CachedTokenProvider: () => CachedTokenProvider,
  CreateSmartMessageTransactionCommandDto: () => CreateSmartMessageTransactionCommandDto,
  DEFAULT_TOKEN_LIFETIME_SECONDS: () => DEFAULT_TOKEN_LIFETIME_SECONDS,
  DIALECT_API_TYPE_DIALECT_CLOUD: () => DIALECT_API_TYPE_DIALECT_CLOUD,
  DappMessageActionType: () => DappMessageActionType,
  DappNotificationSubscription: () => DappNotificationSubscription,
  DataServiceApi: () => DataServiceApi,
  DataServiceApiError: () => DataServiceApiError,
  DataServiceApiFactory: () => DataServiceApiFactory,
  DataServiceMessaging: () => DataServiceMessaging,
  DataServiceThread: () => DataServiceThread,
  DataServiceWalletsApiClientV1: () => DataServiceWalletsApiClientV1,
  DefaultTokenGenerator: () => DefaultTokenGenerator,
  DefaultTokenProvider: () => DefaultTokenProvider,
  Dialect: () => Dialect,
  DialectSdk: () => DialectSdk,
  DialectSdkError: () => DialectSdkError,
  Ed25519AuthenticationFacadeFactory: () => Ed25519AuthenticationFacadeFactory,
  Ed25519PublicKey: () => Ed25519PublicKey,
  Ed25519TokenBodyParser: () => Ed25519TokenBodyParser,
  Ed25519TokenSigner: () => Ed25519TokenSigner,
  EncryptionKeysProvider: () => EncryptionKeysProvider,
  EncryptionKeysStore: () => EncryptionKeysStore,
  FirstFoundFastIdentityResolver: () => FirstFoundFastIdentityResolver,
  FirstFoundIdentityResolver: () => FirstFoundIdentityResolver,
  IdentityError: () => IdentityError,
  IdentityResolver: () => IdentityResolver,
  IllegalArgumentError: () => IllegalArgumentError,
  IllegalStateError: () => IllegalStateError,
  MAX_TOKEN_LIFETIME_SECONDS: () => MAX_TOKEN_LIFETIME_SECONDS,
  MessagingError: () => MessagingError,
  NetworkError: () => NetworkError,
  NotificationSubscription: () => NotificationSubscription,
  PublicKey: () => PublicKey,
  ResourceAlreadyExistsError: () => ResourceAlreadyExistsError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  SDK_VERSION: () => version,
  SmartMessageButtonLayoutElementDto: () => SmartMessageButtonLayoutElementDto,
  SmartMessageContentDto: () => SmartMessageContentDto,
  SmartMessageDto: () => SmartMessageDto,
  SmartMessageLabelLayoutElementDto: () => SmartMessageLabelLayoutElementDto,
  SmartMessageLayoutDto: () => SmartMessageLayoutDto,
  SmartMessagePreviewParamsDto: () => SmartMessagePreviewParamsDto,
  SmartMessageSpecCancelActionDto: () => SmartMessageSpecCancelActionDto,
  SmartMessageSpecOpenLinkActionDto: () => SmartMessageSpecOpenLinkActionDto,
  SmartMessageSpecSignTransactionActionDto: () => SmartMessageSpecSignTransactionActionDto,
  SmartMessageStateDto: () => SmartMessageStateDto,
  SmartMessageSystemParamsDto: () => SmartMessageSystemParamsDto,
  SmartMessageTransactionDto: () => SmartMessageTransactionDto,
  SubmitSmartMessageTransactionCommandDto: () => SubmitSmartMessageTransactionCommandDto,
  ThreadAlreadyExistsError: () => ThreadAlreadyExistsError,
  ThreadId: () => ThreadId,
  ThreadMemberScope: () => ThreadMemberScope,
  TokenBodyParser: () => TokenBodyParser,
  TokenGenerator: () => TokenGenerator,
  TokenHeaderParser: () => TokenHeaderParser,
  TokenParser: () => TokenParser,
  TokenParsingError: () => TokenParsingError,
  TokenProvider: () => TokenProvider,
  TokenSigner: () => TokenSigner,
  TokenStore: () => TokenStore,
  TokenStructureValidationError: () => TokenStructureValidationError,
  TokenUnsupportedAlgError: () => TokenUnsupportedAlgError,
  TokenValidator: () => TokenValidator,
  UnknownError: () => UnknownError,
  UnsupportedOperationError: () => UnsupportedOperationError,
  bytesFromBase64: () => bytesFromBase64,
  bytesToBase64: () => bytesToBase64,
  createHeaders: () => createHeaders,
  deserializeDiffeHellmanKeys: () => deserializeDiffeHellmanKeys,
  generateEd25519Keypair: () => generateEd25519Keypair,
  jsonParseFromBase64: () => jsonParseFromBase64,
  jsonStringifyToBase64: () => jsonStringifyToBase64,
  serializeDiffeHellmanKeys: () => serializeDiffeHellmanKeys,
  toAddressType: () => toAddressType,
  toAddressTypeDto: () => toAddressTypeDto,
  withReThrowingDataServiceError: () => withReThrowingDataServiceError
});
module.exports = __toCommonJS(src_exports);

// src/dialect-cloud-api/data-service-api.ts
var import_nanoid = require("nanoid");

// package.json
var version = "1.9.4";

// src/dialect-cloud-api/data-service-api.ts
var DataServiceApi = class {
  constructor(threads, dapps, dappNotificationTypes, dappNotificationSubscriptions, walletsV0, walletAddresses, walletDappAddresses, walletMessages, walletNotificationSubscriptions, pushNotificationSubscriptions, health) {
    this.threads = threads;
    this.dapps = dapps;
    this.dappNotificationTypes = dappNotificationTypes;
    this.dappNotificationSubscriptions = dappNotificationSubscriptions;
    this.walletsV0 = walletsV0;
    this.walletAddresses = walletAddresses;
    this.walletDappAddresses = walletDappAddresses;
    this.walletMessages = walletMessages;
    this.walletNotificationSubscriptions = walletNotificationSubscriptions;
    this.pushNotificationSubscriptions = pushNotificationSubscriptions;
    this.health = health;
  }
};
var NetworkError = class {
};
var DataServiceApiError = class {
  constructor(error, statusCode, message, requestId) {
    this.error = error;
    this.statusCode = statusCode;
    this.message = message;
    this.requestId = requestId;
  }
};
var XRequestIdHeader = "x-request-id";
var XClientNameHeader = "x-client-name";
var XClientVersionHeader = "x-client-version";
function createHeaders(token) {
  return {
    ...token && {
      Authorization: `Bearer ${token.rawValue}`
    },
    [XRequestIdHeader]: (0, import_nanoid.nanoid)(),
    [XClientNameHeader]: "dialect-sdk",
    [XClientVersionHeader]: version
  };
}
async function withReThrowingDataServiceError(fn) {
  try {
    return await fn;
  } catch (e) {
    console.error(e);
    const err = e;
    if (!err.response) {
      throw new NetworkError();
    }
    const data = err.response.data;
    const requestId = (err.config.headers && err.config.headers[XRequestIdHeader]) ?? null;
    throw new DataServiceApiError(
      err.response.statusText,
      Number(err.response.status),
      data.message,
      requestId
    );
  }
}

// src/dialect-cloud-api/data-service-dapps-api.ts
var import_axios = __toESM(require("axios"), 1);
var DataServiceDappsApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async create(command) {
    const token = await this.tokenProvider.get();
    const fullCommand = {
      ...command,
      publicKey: token.body.sub
    };
    return withReThrowingDataServiceError(
      import_axios.default.post(`${this.baseUrl}/api/v1/dapps`, fullCommand, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async patch(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.patch(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async findAllDappAddresses() {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.get(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/dappAddresses`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async find(dappAddress) {
    const token = await this.tokenProvider.get();
    const dappAddressToFind = dappAddress || token.body.sub;
    return withReThrowingDataServiceError(
      import_axios.default.get(`${this.baseUrl}/api/v1/dapps/${dappAddressToFind}`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async broadcast(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.post(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/broadcast`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async multicast(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.post(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/multicast`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async unicast(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.post(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/messages/unicast`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async findAll(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios.default.get(`${this.baseUrl}/api/v1/dapps`, {
        headers: createHeaders(token),
        params: query
      }).then((it) => it.data)
    );
  }
};

// src/sdk/errors.ts
var DialectSdkError = class extends Error {
  constructor(type, title, msg, details) {
    super(msg);
    this.type = type;
    this.title = title;
    this.msg = msg;
    this.details = details;
    this.msg = msg;
    this.type = type;
    this.title = title;
    this.details = details;
  }
};
var IllegalArgumentError = class _IllegalArgumentError extends DialectSdkError {
  constructor(title, msg, details) {
    super(_IllegalArgumentError.name, title, msg, details);
  }
};
var IllegalStateError = class _IllegalStateError extends DialectSdkError {
  constructor(title, msg, details) {
    super(_IllegalStateError.name, title, msg, details);
  }
};
var UnsupportedOperationError = class _UnsupportedOperationError extends DialectSdkError {
  constructor(title, msg, details) {
    super(_UnsupportedOperationError.name, title, msg, details);
  }
};
var UnknownError = class _UnknownError extends DialectSdkError {
  constructor(details, msg) {
    super(
      _UnknownError.name,
      "Error",
      msg ?? "Something went wrong. Please try again later.",
      details
    );
  }
};
var BusinessConstraintViolationError = class _BusinessConstraintViolationError extends DialectSdkError {
  constructor(msg) {
    super(_BusinessConstraintViolationError.name, "Error", msg);
  }
};
var ResourceAlreadyExistsError = class _ResourceAlreadyExistsError extends DialectSdkError {
  constructor(msg) {
    super(_ResourceAlreadyExistsError.name, "Error", msg);
  }
};
var AuthenticationError = class _AuthenticationError extends DialectSdkError {
  constructor(msg) {
    super(_AuthenticationError.name, "Error", msg);
  }
};
var AuthorizationError = class _AuthorizationError extends DialectSdkError {
  constructor(msg) {
    super(_AuthorizationError.name, "Error", msg);
  }
};
var ResourceNotFoundError = class _ResourceNotFoundError extends DialectSdkError {
  constructor(msg) {
    super(_ResourceNotFoundError.name, "Error", msg);
  }
};
var IdentityError = class extends DialectSdkError {
};

// src/address/addresses.interface.ts
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2["Email"] = "EMAIL";
  AddressType2["PhoneNumber"] = "PHONE_NUMBER";
  AddressType2["Telegram"] = "TELEGRAM";
  AddressType2["Wallet"] = "WALLET";
  return AddressType2;
})(AddressType || {});
var addressTypeToAddressTypeDto = {
  ["EMAIL" /* Email */]: "EMAIL" /* Email */,
  ["PHONE_NUMBER" /* PhoneNumber */]: "PHONE_NUMBER" /* PhoneNumber */,
  ["TELEGRAM" /* Telegram */]: "TELEGRAM" /* Telegram */,
  ["WALLET" /* Wallet */]: "WALLET" /* Wallet */
};
function toAddressTypeDto(type) {
  const addressTypeDto = addressTypeToAddressTypeDto[type];
  if (!addressTypeDto) {
    throw new IllegalArgumentError(`Unknown address type ${type}`);
  }
  return addressTypeDto;
}
var addressTypeDtoToAddressType = {
  ["EMAIL" /* Email */]: "EMAIL" /* Email */,
  ["PHONE_NUMBER" /* PhoneNumber */]: "PHONE_NUMBER" /* PhoneNumber */,
  ["TELEGRAM" /* Telegram */]: "TELEGRAM" /* Telegram */,
  ["WALLET" /* Wallet */]: "WALLET" /* Wallet */
};
function toAddressType(type) {
  const addressType = addressTypeDtoToAddressType[type];
  if (!addressType) {
    throw new IllegalArgumentError(`Unknown address type ${type}`);
  }
  return addressType;
}

// src/auth/auth.interface.ts
var PublicKey = class {
  equals(other) {
    return this.toString() === other.toString();
  }
};
var TokenSigner = class {
};

// src/auth/authentication-facade.ts
var Authenticator = class {
  constructor(parser, validator) {
    this.parser = parser;
    this.validator = validator;
  }
  authenticate(token) {
    const header = this.parser.parseHeader(token);
    if (!this.validator.canValidate(header)) {
      return null;
    }
    const parsedToken = this.parser.parse(token);
    const isValid = this.validator.isValid(parsedToken);
    if (!isValid) {
      return null;
    }
    return parsedToken;
  }
};
var AuthenticationFacadeFactory = class {
};
var AuthenticationFacade = class {
  constructor(tokenSigner, tokenGenerator, authenticator) {
    this.tokenSigner = tokenSigner;
    this.tokenGenerator = tokenGenerator;
    this.authenticator = authenticator;
  }
  type() {
    return this.tokenSigner.alg;
  }
  subject() {
    return this.tokenSigner.subject;
  }
  generateToken(ttlSeconds) {
    return this.tokenGenerator.generate(ttlSeconds);
  }
  parseToken(token) {
    return this.authenticator.parser.parse(token);
  }
  canValidate(tokenHeader) {
    return this.authenticator.validator.canValidate(tokenHeader);
  }
  isValid(token) {
    return this.authenticator.validator.isValid(token);
  }
};

// src/auth/token-store.ts
var TokenStore = class {
  static createInMemory() {
    return new InMemoryTokenStore();
  }
  static createSessionStorage() {
    return new SessionStorageTokenStore();
  }
  static createLocalStorage() {
    return new LocalStorageTokenStore();
  }
};
var InMemoryTokenStore = class extends TokenStore {
  constructor() {
    super(...arguments);
    this.tokens = {};
  }
  get(subject) {
    return this.tokens[subject.toString()] ?? null;
  }
  save(subject, token) {
    this.tokens[subject.toString()] = token;
    return token;
  }
  delete(subject) {
    delete this.tokens[subject.toString()];
  }
};
var SessionStorageTokenStore = class extends TokenStore {
  get(subject) {
    const key = createStorageKey(subject.toString());
    return sessionStorage.getItem(key);
  }
  delete(subject) {
    const key = createStorageKey(subject.toString());
    sessionStorage.removeItem(key);
  }
  save(subject, token) {
    sessionStorage.setItem(createStorageKey(subject.toString()), token);
    return token;
  }
};
var LocalStorageTokenStore = class extends TokenStore {
  get(subject) {
    const key = createStorageKey(subject.toString());
    return localStorage.getItem(key);
  }
  save(subject, token) {
    localStorage.setItem(createStorageKey(subject.toString()), token);
    return token;
  }
  delete(subject) {
    localStorage.removeItem(createStorageKey(subject.toString()));
  }
};
var storageTokenKeyPrefix = "dialect-auth-token";
function createStorageKey(subject) {
  return `${storageTokenKeyPrefix}-${subject}`;
}

// src/auth/token-provider.ts
var DEFAULT_TOKEN_LIFETIME_SECONDS = 24 * 60 * 60;
var MAX_TOKEN_LIFETIME_SECONDS = 3 * 30 * 24 * 60 * 60;
var TokenProvider = class {
  static create(authenticationFacade, dataServiceWalletsApiClientV1, ttlSeconds = DEFAULT_TOKEN_LIFETIME_SECONDS, tokenStore = TokenStore.createInMemory(), walletCreation = "implicit") {
    const defaultTokenProvider = new DefaultTokenProvider(
      ttlSeconds,
      authenticationFacade.tokenGenerator
    );
    return new CachedTokenProvider(
      defaultTokenProvider,
      tokenStore,
      walletCreation,
      authenticationFacade.authenticator.parser,
      authenticationFacade.authenticator.validator,
      authenticationFacade.subject(),
      dataServiceWalletsApiClientV1
    );
  }
};
var DefaultTokenProvider = class extends TokenProvider {
  constructor(ttlSeconds, tokenGenerator) {
    if (ttlSeconds > MAX_TOKEN_LIFETIME_SECONDS) {
      throw new IllegalArgumentError(
        `Token TTL ${ttlSeconds} must be <= max ${MAX_TOKEN_LIFETIME_SECONDS}`
      );
    }
    super();
    this.ttlSeconds = ttlSeconds;
    this.tokenGenerator = tokenGenerator;
  }
  get() {
    return this.tokenGenerator.generate(this.ttlSeconds);
  }
};
var CachedTokenProvider = class extends TokenProvider {
  constructor(delegate, tokenStore, walletCreation, tokenParser, tokenValidator, subject, dataServiceWalletsApiClientV1) {
    super();
    this.delegate = delegate;
    this.tokenStore = tokenStore;
    this.walletCreation = walletCreation;
    this.tokenParser = tokenParser;
    this.tokenValidator = tokenValidator;
    this.subject = subject;
    this.dataServiceWalletsApiClientV1 = dataServiceWalletsApiClientV1;
    this.delegateGetPromises = {};
  }
  async get() {
    const existingToken = this.getCachedToken();
    const subject = this.subject.toString();
    if (existingToken && this.tokenValidator.isValid(existingToken)) {
      return existingToken;
    }
    const existingDelegatePromise = this.delegateGetPromises[subject];
    if (existingDelegatePromise) {
      return existingDelegatePromise;
    }
    const delegatePromise = this.delegate.get().then(async (it) => {
      this.tokenStore.save(this.subject, it.rawValue);
      delete this.delegateGetPromises[subject];
      const wallet = {
        publicKey: this.subject
      };
      if (this.walletCreation === "implicit") {
        await this.dataServiceWalletsApiClientV1.upsertWallet(wallet, it);
      }
      return it;
    });
    delegatePromise.catch((it) => {
      delete this.delegateGetPromises[subject];
    });
    this.delegateGetPromises[subject] = delegatePromise;
    return delegatePromise;
  }
  hasValidCachedToken() {
    const cachedToken = this.getCachedToken();
    if (!cachedToken) {
      return false;
    }
    return this.tokenValidator.isValid(cachedToken);
  }
  getCachedToken() {
    const rawToken = this.tokenStore.get(this.subject);
    if (!rawToken) {
      return null;
    }
    try {
      return this.tokenParser.parse(rawToken);
    } catch (e) {
      this.tokenStore.delete(this.subject);
      return null;
    }
  }
};

// src/auth/token-parser.ts
var import_base642 = require("@stablelib/base64");

// src/utils/bytes-utils.ts
var import_base64 = require("@stablelib/base64");
function bytesToBase64(bytes) {
  return (0, import_base64.encodeURLSafe)(bytes).replace(/=/g, "");
}
function bytesFromBase64(base64) {
  return (0, import_base64.decodeURLSafe)(base64);
}
function jsonStringifyToBase64(t) {
  const json = JSON.stringify(t);
  const byteArray = new TextEncoder().encode(json);
  return bytesToBase64(byteArray);
}
function jsonParseFromBase64(serialized) {
  const byteArray = (0, import_base64.decodeURLSafe)(serialized);
  const json = new TextDecoder().decode(byteArray);
  return JSON.parse(json);
}

// src/auth/token-parser.ts
var TokenParsingError = class _TokenParsingError extends DialectSdkError {
  constructor() {
    super(_TokenParsingError.name, "Unable to parse jwt token");
  }
};
var TokenStructureValidationError = class _TokenStructureValidationError extends DialectSdkError {
  constructor() {
    super(_TokenStructureValidationError.name, "Invalid jwt token");
  }
};
var TokenUnsupportedAlgError = class _TokenUnsupportedAlgError extends DialectSdkError {
  constructor() {
    super(_TokenUnsupportedAlgError.name, "Jwt token alg unsupported");
  }
};
var TokenBodyParser = class {
};
var TokenHeaderParser = class {
  parse(token) {
    const parts = token.split(".");
    const header = parts[0];
    if (!header) {
      throw new TokenParsingError();
    }
    return jsonParseFromBase64(header);
  }
};
var TokenParser = class {
  constructor(bodyParser) {
    this.bodyParser = bodyParser;
    this.tokenHeaderParser = new TokenHeaderParser();
  }
  parse(token) {
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new TokenParsingError();
    }
    const [base64Header, base64Body, base64Signature] = parts;
    if (!base64Header || !base64Body || !base64Signature) {
      throw new TokenParsingError();
    }
    try {
      const header = this.parseHeader(token);
      const body = this.parseBody(base64Body);
      const signature = (0, import_base642.decodeURLSafe)(base64Signature);
      return {
        base64Header,
        base64Body,
        base64Signature,
        rawValue: token,
        header,
        signature,
        body
      };
    } catch (e) {
      console.error(e);
      throw new TokenParsingError();
    }
  }
  parseHeader(token) {
    return this.tokenHeaderParser.parse(token);
  }
  parseBody(base64Body) {
    const body = this.bodyParser.parse(base64Body);
    if (!body.sub || !body.exp) {
      throw new TokenStructureValidationError();
    }
    return body;
  }
};

// src/auth/token-validator.ts
var TokenValidator = class {
  isValid(token) {
    if (!this.canValidate(token.header)) {
      return false;
    }
    if (!this.isSignatureValid(token)) {
      return false;
    }
    if (this.isExpired(token)) {
      return false;
    }
    return this.performExtraValidation(token);
  }
  performExtraValidation(token) {
    return true;
  }
  isExpired(token) {
    const nowUtcSeconds = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    const delta = 10;
    return nowUtcSeconds + delta > token.body.exp;
  }
};

// src/auth/token-generator.ts
var TokenGenerator = class {
  constructor(signer) {
    this.signer = signer;
  }
  header() {
    return {
      alg: this.signer.alg,
      typ: "JWT"
    };
  }
  body(ttlSeconds) {
    const nowUtcSeconds = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    const body = {
      sub: this.signer.subject,
      sub_jwk: this.signer.subjectPublicKey?.toString(),
      iat: Math.round(nowUtcSeconds),
      exp: Math.round(nowUtcSeconds + ttlSeconds)
    };
    return body;
  }
  async sign(base64Header, base64Body, signer) {
    const signingPayload = new TextEncoder().encode(
      base64Header + "." + base64Body
    );
    const { payload: signedPayload, signature } = await signer.sign(
      signingPayload
    );
    const base64Signature = bytesToBase64(signature);
    return { signedPayload, signature, base64Signature };
  }
};

// src/auth/default-token-generator.ts
var DefaultTokenGenerator = class extends TokenGenerator {
  async generate(ttlSeconds) {
    const header = this.header();
    const base64Header = jsonStringifyToBase64(header);
    const body = this.body(ttlSeconds);
    const base64Body = jsonStringifyToBase64(body);
    const { signature, base64Signature } = await this.sign(
      base64Header,
      base64Body,
      this.signer
    );
    const rawValue = `${base64Header}.${base64Body}.${base64Signature}`;
    return {
      rawValue,
      body,
      header,
      signature,
      base64Signature,
      base64Body,
      base64Header
    };
  }
};

// src/auth/ed25519/ed25519-token-body-parser.ts
var Ed25519TokenBodyParser = class extends TokenBodyParser {
  parse(base64Body) {
    return jsonParseFromBase64(base64Body);
  }
};

// src/auth/ed25519/ed25519-token-validator.ts
var import_tweetnacl = __toESM(require("tweetnacl"), 1);

// src/auth/ed25519/ed25519-public-key.ts
var import_bs58 = __toESM(require("bs58"), 1);
var Ed25519PublicKey = class extends PublicKey {
  constructor(value) {
    super();
    if (typeof value === "string" && value.startsWith("0x")) {
      const enc = new TextEncoder();
      this.value = enc.encode(value);
    } else if (typeof value === "string") {
      this.value = import_bs58.default.decode(value);
    } else {
      this.value = value;
    }
  }
  toBytes() {
    return this.value;
  }
  toString() {
    return import_bs58.default.encode(this.value);
  }
};

// src/auth/ed25519/ed25519-token-validator.ts
var Ed25519TokenValidator = class extends TokenValidator {
  canValidate(tokenHeader) {
    return tokenHeader.alg === "ed25519";
  }
  isSignatureValid(token) {
    const signedPayload = token.base64Header + "." + token.base64Body;
    const signingPayload = new TextEncoder().encode(signedPayload);
    return import_tweetnacl.default.sign.detached.verify(
      signingPayload,
      token.signature,
      new Ed25519PublicKey(token.body.sub_jwk ?? token.body.sub).toBytes()
    );
  }
};

// src/auth/ed25519/ed25519-authentication-facade-factory.ts
var Ed25519AuthenticationFacadeFactory = class _Ed25519AuthenticationFacadeFactory extends AuthenticationFacadeFactory {
  constructor(tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }
  get() {
    return new AuthenticationFacade(
      this.tokenSigner,
      new DefaultTokenGenerator(this.tokenSigner),
      _Ed25519AuthenticationFacadeFactory.createAuthenticator()
    );
  }
  static createAuthenticator() {
    return new Authenticator(
      new TokenParser(new Ed25519TokenBodyParser()),
      new Ed25519TokenValidator()
    );
  }
};

// src/auth/ed25519/ed25519-token-signer.ts
var import_tweetnacl3 = __toESM(require("tweetnacl"), 1);

// src/auth/ed25519/utils.ts
var import_tweetnacl2 = __toESM(require("tweetnacl"), 1);
function generateEd25519Keypair() {
  return import_tweetnacl2.default.sign.keyPair.fromSeed(Uint8Array.from(import_tweetnacl2.default.randomBytes(32)));
}

// src/auth/ed25519/ed25519-token-signer.ts
var Ed25519TokenSigner = class {
  constructor(keypair = generateEd25519Keypair(), subjectPublicKey = new Ed25519PublicKey(
    keypair.publicKey
  ), subject = new Ed25519PublicKey(
    keypair.publicKey
  ).toString()) {
    this.keypair = keypair;
    this.subjectPublicKey = subjectPublicKey;
    this.subject = subject;
    this.alg = "ed25519";
  }
  async sign(payload) {
    const signature = import_tweetnacl3.default.sign.detached(payload, this.keypair.secretKey);
    return {
      signature,
      payload
    };
  }
};

// src/dapp/dapp.interface.ts
var BlockchainType = /* @__PURE__ */ ((BlockchainType2) => {
  BlockchainType2["SOLANA"] = "SOLANA";
  BlockchainType2["APTOS"] = "APTOS";
  BlockchainType2["EVM"] = "EVM";
  return BlockchainType2;
})(BlockchainType || {});
var DappMessageActionType = /* @__PURE__ */ ((DappMessageActionType2) => {
  DappMessageActionType2["LINK"] = "Link";
  DappMessageActionType2["SMART_MESSAGE"] = "SmartMessage";
  return DappMessageActionType2;
})(DappMessageActionType || {});
var DappNotificationSubscription = class {
};

// src/encryption/encryption-keys-store.ts
var EncryptionKeysStore = class {
  static createInMemory() {
    return new InmemoryEncryptionKeysStore();
  }
  static createSessionStorage() {
    return new SessionStorageEncryptionKeysStore();
  }
  static createLocalStorage() {
    return new LocalStorageEncryptionKeysStore();
  }
};
var InmemoryEncryptionKeysStore = class extends EncryptionKeysStore {
  constructor() {
    super(...arguments);
    this.keys = {};
  }
  get(subject) {
    return this.keys[subject.toString()] ?? null;
  }
  save(subject, keys) {
    this.keys[subject.toString()] = keys;
    return keys;
  }
};
var SessionStorageEncryptionKeysStore = class extends EncryptionKeysStore {
  get(subject) {
    const key = createStorageKey2(subject.toString());
    try {
      const keys = sessionStorage.getItem(key);
      if (!keys) {
        return null;
      }
      return deserializeDiffeHellmanKeys(keys);
    } catch {
      sessionStorage.removeItem(key);
      return null;
    }
  }
  save(subject, keys) {
    sessionStorage.setItem(
      createStorageKey2(subject.toString()),
      serializeDiffeHellmanKeys(keys)
    );
    return keys;
  }
};
var LocalStorageEncryptionKeysStore = class extends EncryptionKeysStore {
  get(subject) {
    const key = createStorageKey2(subject.toString());
    try {
      const keys = localStorage.getItem(key);
      if (!keys) {
        return null;
      }
      return deserializeDiffeHellmanKeys(keys);
    } catch {
      localStorage.removeItem(key);
      return null;
    }
  }
  save(subject, keys) {
    localStorage.setItem(
      createStorageKey2(subject.toString()),
      serializeDiffeHellmanKeys(keys)
    );
    return keys;
  }
};
var storageEncryptionKeysPrefix = "dialect-encryption-keys";
function createStorageKey2(subject) {
  return `${storageEncryptionKeysPrefix}-${subject}`;
}
function serializeDiffeHellmanKeys(keys) {
  const toSerialize = {
    version: 1,
    keys: {
      publicKey: Array.from(keys.publicKey),
      secretKey: Array.from(keys.secretKey)
    }
  };
  return JSON.stringify(toSerialize);
}
function deserializeDiffeHellmanKeys(data) {
  const deserialized = JSON.parse(data);
  return {
    publicKey: Uint8Array.from(deserialized.keys.publicKey),
    secretKey: Uint8Array.from(deserialized.keys.secretKey)
  };
}

// src/encryption/encryption-keys-provider.ts
var EncryptionKeysProvider = class {
  static create(delegate, encryptionKeysStore = EncryptionKeysStore.createInMemory()) {
    return new CachedEncryptionKeysProvider(delegate, encryptionKeysStore);
  }
};
var CachedEncryptionKeysProvider = class extends EncryptionKeysProvider {
  constructor(delegate, encryptionKeysStore) {
    super();
    this.delegate = delegate;
    this.encryptionKeysStore = encryptionKeysStore;
    this.delegateGetPromises = {};
  }
  isAvailable() {
    return this.delegate.isAvailable();
  }
  async getFailSafe(subject) {
    const existingKeys = this.encryptionKeysStore.get(subject);
    if (existingKeys) {
      delete this.delegateGetPromises[subject.toString()];
      return existingKeys;
    }
    const existingDelegatePromise = this.delegateGetPromises[subject.toString()];
    if (existingDelegatePromise) {
      return existingDelegatePromise;
    }
    const delegatePromise = this.delegate.getFailSafe(subject).then((it) => it && this.encryptionKeysStore.save(subject, it));
    delegatePromise.catch(() => {
      delete this.delegateGetPromises[subject.toString()];
    });
    this.delegateGetPromises[subject.toString()] = delegatePromise;
    return delegatePromise;
  }
  async getFailFast(subject) {
    return this.getFailSafe(subject).then((keys) => {
      if (!keys) {
        throw new UnsupportedOperationError(
          "Encryption not supported",
          "Wallet does not support encryption, please use wallet-adapter that supports diffieHellman() operation."
        );
      }
      return keys;
    });
  }
};

// src/messaging/messaging.interface.ts
var ThreadId = class {
  constructor({ address, type }) {
    this.address = address;
    this.type = type;
  }
  equals(other) {
    return this.address == other.address && this.type === other.type;
  }
  toString() {
    return this.type ? this.type.toString() + ":" + this.address.toString() : this.address.toString();
  }
};
var ThreadMemberScope = /* @__PURE__ */ ((ThreadMemberScope2) => {
  ThreadMemberScope2["WRITE"] = "WRITE";
  ThreadMemberScope2["ADMIN"] = "ADMIN";
  return ThreadMemberScope2;
})(ThreadMemberScope || {});

// src/messaging/errors.ts
var MessagingError = class extends DialectSdkError {
};
var ThreadAlreadyExistsError = class _ThreadAlreadyExistsError extends MessagingError {
  constructor() {
    super(
      _ThreadAlreadyExistsError.name,
      "Error",
      "You already have chat with this address"
    );
  }
};

// src/dialect-cloud-api/data-service-dialects-api.ts
var import_axios2 = __toESM(require("axios"), 1);
var DataServiceDialectsApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async markAsRead(dialectId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.post(
        `${this.baseUrl}/api/v2/dialects/${dialectId}/markAsRead`,
        {},
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async create(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.post(`${this.baseUrl}/api/v2/dialects`, command, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async findAll() {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.get(`${this.baseUrl}/api/v2/dialects`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async find(id) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.get(`${this.baseUrl}/api/v2/dialects/${id}`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async findByMembers(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.get(
        `${this.baseUrl}/api/v2/dialects/search/byMembers`,
        {
          headers: createHeaders(token),
          params: query
        }
      ).then((it) => it.data)
    );
  }
  async delete(id) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.delete(`${this.baseUrl}/api/v2/dialects/${id}`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async patch(id, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.patch(
        `${this.baseUrl}/api/v2/dialects/${id}`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async sendMessage(id, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.post(`${this.baseUrl}/api/v2/dialects/${id}/messages`, command, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async getMessages(id) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios2.default.get(`${this.baseUrl}/api/v2/dialects/${id}/messages`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  findSummary(query) {
    return withReThrowingDataServiceError(
      import_axios2.default.get(`${this.baseUrl}/api/v2/dialects/summary`, {
        headers: createHeaders(),
        ...query && { params: query }
      }).then((it) => it.data)
    );
  }
  findSummaryAll(query) {
    return withReThrowingDataServiceError(
      import_axios2.default.get(
        `${this.baseUrl}/api/v2/dialects/summary/all`,
        {
          headers: createHeaders(),
          params: query
        }
      ).then((it) => it.data)
    );
  }
  async addMembers(dialectId, members) {
    const token = await this.tokenProvider.get();
    await withReThrowingDataServiceError(
      import_axios2.default.post(
        `${this.baseUrl}/api/v2/dialects/${dialectId}/members`,
        members,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async removeMember(dialectId, memberAddress) {
    const token = await this.tokenProvider.get();
    await withReThrowingDataServiceError(
      import_axios2.default.delete(
        `${this.baseUrl}/api/v2/dialects/${dialectId}/members/${memberAddress}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};
var MemberScopeDto = /* @__PURE__ */ ((MemberScopeDto2) => {
  MemberScopeDto2["ADMIN"] = "ADMIN";
  MemberScopeDto2["WRITE"] = "WRITE";
  return MemberScopeDto2;
})(MemberScopeDto || {});

// src/internal/errors.ts
var DialectCloudError = class extends DialectSdkError {
};
var DialectCloudUnreachableError = class _DialectCloudUnreachableError extends DialectCloudError {
  constructor(details) {
    super(
      _DialectCloudUnreachableError.name,
      "Lost connection to Dialect Cloud",
      "Having problems reaching Dialect Cloud. Please try again later.",
      details
    );
  }
};

// src/dialect-cloud-api/data-service-errors.ts
async function withErrorParsing(promise, onResourceAlreadyExists = (e) => new ResourceAlreadyExistsError(createMessage(e))) {
  try {
    return await promise;
  } catch (e) {
    if (e instanceof NetworkError) {
      throw new DialectCloudUnreachableError([e]);
    }
    if (e instanceof DataServiceApiError) {
      if (e.statusCode === 400) {
        console.error(e);
        throw new IllegalArgumentError(createMessage(e));
      }
      if (e.statusCode === 401) {
        throw new AuthenticationError(createMessage(e));
      }
      if (e.statusCode === 403) {
        throw new AuthorizationError(createMessage(e));
      }
      if (e.statusCode === 404) {
        throw new ResourceNotFoundError(createMessage(e));
      }
      if (e.statusCode === 409) {
        throw onResourceAlreadyExists(e);
      }
      if (e.statusCode === 422) {
        throw new BusinessConstraintViolationError(createMessage(e));
      }
      console.error(e);
      throw new UnknownError([e], createMessage(e));
    }
    console.error(e);
    throw new UnknownError([e]);
  }
}
function createMessage(e) {
  return `${e.message ?? e.error}`;
}

// src/messaging/nonce-generator.ts
var import_tweetnacl4 = __toESM(require("tweetnacl"), 1);
var NONCE_SIZE_BYTES = 24;
function generateRandomNonceWithPrefix(memberId) {
  return new Uint8Array([memberId, ...import_tweetnacl4.default.randomBytes(NONCE_SIZE_BYTES - 1)]);
}

// src/messaging/ecdh-encryption.ts
var import_ed2curve = __toESM(require("ed2curve"), 1);
var import_tweetnacl5 = __toESM(require("tweetnacl"), 1);
var IncorrectPublicKeyFormatError = class extends Error {
  constructor() {
    super("IncorrectPublicKeyFormatError");
  }
};
var AuthenticationFailedError = class extends Error {
  constructor() {
    super("Authentication failed during decryption attempt");
  }
};
function ed25519PublicKeyToCurve25519(key) {
  const curve25519PublicKey = import_ed2curve.default.convertPublicKey(key);
  if (!curve25519PublicKey) {
    throw new IncorrectPublicKeyFormatError();
  }
  return curve25519PublicKey;
}
function ecdhEncrypt(payload, { secretKey, publicKey }, otherPartyPublicKey, nonce) {
  return import_tweetnacl5.default.box(
    payload,
    nonce,
    ed25519PublicKeyToCurve25519(otherPartyPublicKey),
    secretKey
  );
}
function ecdhDecrypt(payload, { secretKey, publicKey }, otherPartyPublicKey, nonce) {
  const decrypted = import_tweetnacl5.default.box.open(
    payload,
    nonce,
    ed25519PublicKeyToCurve25519(otherPartyPublicKey),
    secretKey
  );
  if (!decrypted) {
    throw new AuthenticationFailedError();
  }
  return decrypted;
}

// src/messaging/text-serde.ts
var EncryptedTextSerde = class {
  constructor(encryptionProps, members) {
    this.encryptionProps = encryptionProps;
    this.members = members;
    this.unencryptedTextSerde = new UnencryptedTextSerde();
  }
  deserialize(bytes) {
    const encryptionNonce = bytes.slice(0, NONCE_SIZE_BYTES);
    const encryptedText = bytes.slice(NONCE_SIZE_BYTES, bytes.length);
    const otherMember = this.findOtherMember(
      new Ed25519PublicKey(this.encryptionProps.ed25519PublicKey)
    );
    const encodedText = ecdhDecrypt(
      encryptedText,
      this.encryptionProps.diffieHellmanKeyPair,
      otherMember.toBytes(),
      encryptionNonce
    );
    return this.unencryptedTextSerde.deserialize(encodedText);
  }
  serialize(text) {
    const publicKey = new Ed25519PublicKey(
      this.encryptionProps.ed25519PublicKey
    );
    const senderMemberIdx = this.findMemberIdx(publicKey);
    const textBytes = this.unencryptedTextSerde.serialize(text);
    const otherMember = this.findOtherMember(publicKey);
    const encryptionNonce = generateRandomNonceWithPrefix(senderMemberIdx);
    const encryptedText = ecdhEncrypt(
      textBytes,
      this.encryptionProps.diffieHellmanKeyPair,
      otherMember.toBytes(),
      encryptionNonce
    );
    return new Uint8Array([...encryptionNonce, ...encryptedText]);
  }
  findMemberIdx(member) {
    const memberIdx = this.members.findIndex((it) => it.equals(member));
    if (memberIdx === -1) {
      throw new Error("Expected to have other member");
    }
    return memberIdx;
  }
  findOtherMember(member) {
    const otherMember = this.members.find((it) => !it.equals(member));
    if (!otherMember) {
      throw new Error("Expected to have other member");
    }
    return otherMember;
  }
};
var UnencryptedTextSerde = class {
  deserialize(bytes) {
    return new TextDecoder().decode(bytes);
  }
  serialize(text) {
    return new TextEncoder().encode(text);
  }
};

// src/sdk/constants.ts
var DIALECT_API_TYPE_DIALECT_CLOUD = "dialect-cloud";

// src/internal/messaging/data-service-messaging.ts
var DataServiceMessaging = class {
  constructor(me, dataServiceDialectsApi, encryptionKeysProvider) {
    this.me = me;
    this.dataServiceDialectsApi = dataServiceDialectsApi;
    this.encryptionKeysProvider = encryptionKeysProvider;
    this.type = DIALECT_API_TYPE_DIALECT_CLOUD;
  }
  async create(command) {
    const otherMembers = requireAtLeastOneMember(command.otherMembers);
    if (command.encrypted && otherMembers.length >= 2) {
      throw new UnsupportedOperationError(
        "Unsupported operation",
        "Encryption not supported in group chats"
      );
    }
    command.encrypted && await this.checkEncryptionSupported();
    const dialectAccountDto = await withErrorParsing(
      this.dataServiceDialectsApi.create({
        encrypted: command.encrypted,
        members: [
          {
            address: this.me,
            scopes: toDataServiceScopes(command.me.scopes)
          },
          ...otherMembers.map((e) => ({
            address: e.address,
            scopes: toDataServiceScopes(e.scopes)
          }))
        ]
      }),
      () => new ThreadAlreadyExistsError()
    );
    return this.toDataServiceThread(dialectAccountDto);
  }
  async find(query) {
    const dialectAccountDto = await this.findInternal(query);
    return dialectAccountDto && this.toDataServiceThread(dialectAccountDto);
  }
  async findAll() {
    const dialectAccountDtos = await withErrorParsing(
      this.dataServiceDialectsApi.findAll()
    );
    return Promise.all(
      dialectAccountDtos.map((it) => this.toDataServiceThread(it))
    );
  }
  async findSummary(query) {
    try {
      const dialectSummaryDto = await withErrorParsing(
        this.dataServiceDialectsApi.findSummary({
          memberAddresses: [
            this.me.toString(),
            ...query.otherMembers.map((it) => it.toString())
          ]
        })
      );
      const meMember = dialectSummaryDto.memberSummaries.find(
        (it) => it.address === this.me
      );
      if (!meMember) {
        throw new IllegalStateError(
          `Cannot resolve member from given list: ${dialectSummaryDto.memberSummaries.map(
            (it) => it.address
          )} and provided member public key ${this.me.toString()}`
        );
      }
      const meMemberSummary = {
        address: meMember.address,
        hasUnreadMessages: meMember.hasUnreadMessages,
        unreadMessagesCount: meMember.unreadMessagesCount
      };
      return {
        id: new ThreadId({
          address: dialectSummaryDto.id,
          type: this.type
        }),
        me: meMemberSummary
      };
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
  async findSummaryAll() {
    return await withErrorParsing(
      this.dataServiceDialectsApi.findSummaryAll({
        address: this.me
      })
    );
  }
  checkEncryptionSupported() {
    return this.encryptionKeysProvider.getFailFast(this.me);
  }
  async toDataServiceThread(dialectAccountDto) {
    const { id, dialect } = dialectAccountDto;
    const meMember = findMember(this.me, dialect);
    const otherMembers = findOtherMembers(this.me, dialect);
    if (!meMember || !otherMembers.length) {
      throw new IllegalStateError(
        `Cannot resolve members from given list: ${dialect.members.map(
          (it) => it.address
        )} and wallet public key ${this.me.toString()}`
      );
    }
    const { serde, canBeDecrypted } = await this.createTextSerde(dialect);
    const otherThreadMembers = otherMembers.map((member) => ({
      address: member.address,
      scopes: fromDataServiceScopes(member.scopes)
      // lastReadMessageTimestamp: new Date(), // TODO: implement
    }));
    const otherMembersPks = Object.fromEntries(
      otherThreadMembers.map((member) => [member.address.toString(), member])
    );
    const thisThreadMember = {
      address: meMember.address,
      scopes: fromDataServiceScopes(meMember.scopes)
      // lastReadMessageTimestamp: new Date(), // TODO: implement
    };
    const lastMessage = dialect.lastMessage ?? null;
    let lastThreadMessage = null;
    if (lastMessage != null) {
      lastThreadMessage = {
        id: lastMessage.id,
        text: serde.deserialize(new Uint8Array(lastMessage.text)),
        timestamp: new Date(lastMessage.timestamp),
        author: lastMessage.owner === this.me ? thisThreadMember : otherMembersPks[lastMessage.owner],
        deduplicationId: lastMessage.deduplicationId,
        metadata: lastMessage.metadata
      };
    }
    return new DataServiceThread(
      this.dataServiceDialectsApi,
      serde,
      this.encryptionKeysProvider,
      id,
      thisThreadMember,
      otherThreadMembers,
      otherMembersPks,
      dialect.encrypted,
      canBeDecrypted,
      new Date(dialect.updatedAt),
      lastThreadMessage,
      dialect.groupName
    );
  }
  async createTextSerde(dialect) {
    if (!dialect.encrypted) {
      return {
        serde: new UnencryptedTextSerde(),
        canBeDecrypted: true
      };
    }
    const diffieHellmanKeyPair = await this.encryptionKeysProvider.getFailSafe(
      this.me
    );
    const encryptionProps = diffieHellmanKeyPair && {
      diffieHellmanKeyPair,
      ed25519PublicKey: new Ed25519PublicKey(this.me).toBytes()
    };
    if (!encryptionProps) {
      return {
        serde: new UnencryptedTextSerde(),
        canBeDecrypted: false
      };
    }
    return {
      serde: new EncryptedTextSerde(
        encryptionProps,
        dialect.members.map((it) => new Ed25519PublicKey(it.address))
      ),
      canBeDecrypted: true
    };
  }
  findInternal(query) {
    if ("id" in query) {
      return this.findById(query);
    }
    return this.findByOtherMember(query);
  }
  async findById(query) {
    try {
      return await withErrorParsing(
        this.dataServiceDialectsApi.find(query.id.address.toString())
      );
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
  async findByOtherMember(query) {
    const otherMembers = requireAtLeastOneMember(query.otherMembers);
    try {
      return await withErrorParsing(
        this.dataServiceDialectsApi.findByMembers({
          memberAddresses: otherMembers.map((member) => member.toString())
        })
      );
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
};
var DataServiceThread = class {
  constructor(dataServiceDialectsApi, textSerde, encryptionKeysProvider, address, me, otherMembers, otherMembersPks, encryptionEnabled, canBeDecrypted, updatedAt, lastMessage, name) {
    this.dataServiceDialectsApi = dataServiceDialectsApi;
    this.textSerde = textSerde;
    this.encryptionKeysProvider = encryptionKeysProvider;
    this.address = address;
    this.me = me;
    this.otherMembers = otherMembers;
    this.otherMembersPks = otherMembersPks;
    this.encryptionEnabled = encryptionEnabled;
    this.canBeDecrypted = canBeDecrypted;
    this.updatedAt = updatedAt;
    this.lastMessage = lastMessage;
    this.name = name;
    this.type = DIALECT_API_TYPE_DIALECT_CLOUD;
    this.id = new ThreadId({
      type: this.type,
      address
    });
  }
  async delete() {
    await withErrorParsing(
      this.dataServiceDialectsApi.delete(this.address.toString())
    );
  }
  async messages() {
    const { dialect } = await withErrorParsing(
      this.dataServiceDialectsApi.find(this.address.toString())
    );
    this.updatedAt = new Date(dialect.updatedAt);
    if (this.encryptionEnabledButCannotBeUsed()) {
      return [];
    }
    const { messages } = await withErrorParsing(
      this.dataServiceDialectsApi.getMessages(this.address.toString())
    );
    const threadMessages = messages.map((it) => ({
      id: it.id,
      author: it.owner === this.me.address.toString() ? this.me : this.otherMembersPks[it.owner],
      timestamp: new Date(it.timestamp),
      text: this.textSerde.deserialize(new Uint8Array(it.text)),
      deduplicationId: it.deduplicationId,
      metadata: it.metadata
    }));
    this.lastMessage = threadMessages[0] ?? null;
    return threadMessages;
  }
  async send(command) {
    if (this.encryptionEnabledButCannotBeUsed()) {
      throw new UnsupportedOperationError(
        "Encryption not supported",
        "Please use encryption keys provider that supports encryption."
      );
    }
    await withErrorParsing(
      this.dataServiceDialectsApi.sendMessage(this.address.toString(), {
        text: Array.from(this.textSerde.serialize(command.text)),
        deduplicationId: command.deduplicationId
      })
    );
  }
  async markAsRead() {
    await withErrorParsing(
      this.dataServiceDialectsApi.markAsRead(this.id.address.toString())
    );
  }
  async addMembers(command) {
    const members = requireAtLeastOneMember(command.members);
    await withErrorParsing(
      this.dataServiceDialectsApi.addMembers(this.id.address.toString(), {
        members: members.map((e) => ({
          address: e.address,
          scopes: toDataServiceScopes(e.scopes)
        }))
      }),
      () => new ThreadAlreadyExistsError()
    );
  }
  async removeMember(address) {
    await withErrorParsing(
      this.dataServiceDialectsApi.removeMember(
        this.id.address.toString(),
        address
      ),
      () => new ThreadAlreadyExistsError()
    );
  }
  async rename(name) {
    await withErrorParsing(
      this.dataServiceDialectsApi.patch(this.id.address.toString(), {
        groupName: name
      })
    );
  }
  encryptionEnabledButCannotBeUsed() {
    return this.encryptionEnabled && !this.canBeDecrypted;
  }
};
function fromDataServiceScopes(scopes) {
  return scopes.map((it) => ThreadMemberScope[it]);
}
function toDataServiceScopes(scopes) {
  return scopes.map((it) => MemberScopeDto[it]);
}
function findMember(memberPk, dialect) {
  return dialect.members.find((it) => memberPk === it.address) ?? null;
}
function findOtherMembers(memberPk, dialect) {
  return dialect.members.filter((it) => memberPk !== it.address);
}
function requireAtLeastOneMember(members) {
  if (members.length < 1) {
    throw new UnsupportedOperationError(
      "Unsupported operation",
      "At least one member should be specified"
    );
  }
  return members;
}

// src/internal/dapp/data-service-dapp-messages.ts
var DataServiceDappMessages = class {
  constructor(api) {
    this.api = api;
  }
  async send(command) {
    if (command.addressTypes?.length === 0) {
      return;
    }
    if ("recipient" in command) {
      return this.unicast(command);
    }
    if ("recipients" in command) {
      return this.multicast(command);
    }
    return this.broadcast(command);
  }
  async unicast(command) {
    const actionsV2Dto = this.getActionsV2DtoForUnicast(command.actionsV2);
    return withErrorParsing(
      this.api.unicast({
        message: command.message,
        title: command.title,
        imageUrl: command.imageUrl,
        notificationTypeId: command.notificationTypeId,
        recipientPublicKey: command.recipient.toString(),
        addressTypes: command?.addressTypes?.map(
          (addr) => toAddressTypeDto(addr)
        ),
        actionsV2: actionsV2Dto
      })
    );
  }
  getActionsV2DtoForUnicast(actions) {
    if (!actions?.type) {
      return;
    }
    if (actions.type === "Link" /* LINK */) {
      return {
        type: "Link" /* LINK */,
        links: actions.links.map((link) => ({
          label: link.label,
          url: link.url
        }))
      };
    }
    if (actions.type === "SmartMessage" /* SMART_MESSAGE */) {
      return {
        type: "SmartMessage" /* SMART_MESSAGE */,
        smartMessage: {
          transactionServiceId: actions.smartMessage.transactionServiceId,
          transactionParams: actions.smartMessage.transactionParams
        }
      };
    }
  }
  async multicast(command) {
    if (command.recipients.length === 0) {
      return;
    }
    return withErrorParsing(
      this.api.multicast({
        message: command.message,
        title: command.title,
        imageUrl: command.imageUrl,
        actionsV2: this.getActionsV2DtoForLinks(command.actionsV2),
        notificationTypeId: command.notificationTypeId,
        recipientPublicKeys: command.recipients.map((it) => it.toString()),
        addressTypes: command?.addressTypes?.map(
          (addr) => toAddressTypeDto(addr)
        )
      })
    );
  }
  async broadcast(command) {
    return withErrorParsing(
      this.api.broadcast({
        message: command.message,
        title: command.title,
        imageUrl: command.imageUrl,
        actionsV2: this.getActionsV2DtoForLinks(command.actionsV2),
        notificationTypeId: command.notificationTypeId,
        addressTypes: command?.addressTypes?.map(
          (addr) => toAddressTypeDto(addr)
        )
      })
    );
  }
  getActionsV2DtoForLinks(actions) {
    if (!actions?.type) {
      return;
    }
    return {
      type: "Link" /* LINK */,
      links: actions.links.map((link) => ({
        label: link.label,
        url: link.url
      }))
    };
  }
};

// src/internal/dapp/data-service-dapp-notification-subscriptions.ts
var DataServiceDappNotificationSubscriptions = class {
  constructor(api) {
    this.api = api;
  }
  async findAll() {
    const dtos = await withErrorParsing(this.api.findAll());
    return dtos.map((it) => ({
      ...it,
      subscriptions: it.subscriptions.map((it2) => ({
        ...it2,
        wallet: {
          ...it2.wallet,
          address: it2.wallet.publicKey
        }
      }))
    }));
  }
};

// src/internal/dapp/dapp-messages-facade.ts
var DappMessagesFacade = class {
  constructor(dappMessageBackends) {
    this.dappMessageBackends = dappMessageBackends;
    if (dappMessageBackends.length < 1) {
      throw new IllegalArgumentError(
        "Expected to have at least one dapp message backend."
      );
    }
  }
  async send(command) {
    const allSettled = await Promise.allSettled(
      this.dappMessageBackends.map((it) => it.send(command))
    );
    const errors = allSettled.filter((it) => it.status === "rejected").map((it) => it).map((it) => it.reason);
    if (errors.length > 0) {
      console.error(
        `Error during sending dapp messages: ${errors.map(
          (it) => JSON.stringify(it)
        )}`
      );
    }
    const fulfilled = allSettled.filter((it) => it.status === "fulfilled");
    if (errors.length > 0 && fulfilled.length === 0) {
      const error = {
        ...errors[0],
        details: errors
      };
      throw error;
    }
  }
};

// src/internal/dapp/dapp.ts
var DappsImpl = class {
  constructor(dappAddresses, dappMessages, notificationTypes, notificationSubscriptions, dappsApi) {
    this.dappAddresses = dappAddresses;
    this.dappMessages = dappMessages;
    this.notificationTypes = notificationTypes;
    this.notificationSubscriptions = notificationSubscriptions;
    this.dappsApi = dappsApi;
  }
  async find(query) {
    try {
      const dappDto = await withErrorParsing(
        this.dappsApi.find(query?.address)
      );
      return this.toDapp(dappDto);
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
  toDapp(dappDto) {
    return new DappImpl(
      dappDto.id,
      dappDto.publicKey,
      dappDto.name,
      dappDto.verified,
      dappDto.telegramBotUserName,
      dappDto.blockchainType,
      this.dappAddresses,
      this.dappMessages,
      this.notificationTypes,
      this.notificationSubscriptions,
      dappDto.description,
      dappDto.websiteUrl,
      dappDto.avatarUrl,
      dappDto.heroUrl
    );
  }
  async findAll(query) {
    const dappDtos = await withErrorParsing(this.dappsApi.findAll(query));
    return dappDtos.map((it) => ({
      id: it.id,
      address: it.publicKey,
      name: it.name,
      description: it.description,
      websiteUrl: it.websiteUrl,
      avatarUrl: it.avatarUrl,
      heroUrl: it.heroUrl,
      verified: it.verified,
      telegramUsername: it.telegramBotUserName,
      blockchainType: it.blockchainType
    }));
  }
  async create(command) {
    const dappDto = await withErrorParsing(
      this.dappsApi.create({
        name: command.name,
        description: command.description,
        websiteUrl: command.websiteUrl,
        avatarUrl: command.avatarUrl,
        heroUrl: command.heroUrl,
        telegramBotConfiguration: command.telegramBotConfiguration,
        blockchainType: command.blockchainType
      })
    );
    return this.toDapp(dappDto);
  }
  async patch(command) {
    const dappDto = await withErrorParsing(
      this.dappsApi.patch({
        name: command.name,
        description: command.description,
        websiteUrl: command.websiteUrl,
        avatarUrl: command.avatarUrl,
        heroUrl: command.heroUrl
      })
    );
    return this.toDapp(dappDto);
  }
};
var DappImpl = class {
  constructor(id, address, name, verified, telegramUsername, blockchainType, dappAddresses, messages, notificationTypes, notificationSubscriptions, description, websiteUrl, avatarUrl, heroUrl) {
    this.id = id;
    this.address = address;
    this.name = name;
    this.verified = verified;
    this.telegramUsername = telegramUsername;
    this.blockchainType = blockchainType;
    this.dappAddresses = dappAddresses;
    this.messages = messages;
    this.notificationTypes = notificationTypes;
    this.notificationSubscriptions = notificationSubscriptions;
    this.description = description;
    this.websiteUrl = websiteUrl;
    this.avatarUrl = avatarUrl;
    this.heroUrl = heroUrl;
  }
};

// src/utils/collection-utils.ts
function groupBy(arr, key) {
  return arr.reduce((groups, item) => {
    (groups[key(item)] ||= []).push(item);
    return groups;
  }, {});
}

// src/internal/dapp/dapp-addresses-facade.ts
var DappAddressesFacade = class _DappAddressesFacade {
  constructor(dappAddressesBackends) {
    this.dappAddressesBackends = dappAddressesBackends;
    if (dappAddressesBackends.length < 1) {
      throw new IllegalArgumentError(
        "Expected to have at least one dapp addresses backend."
      );
    }
  }
  static dedupleWalletAddresses(walletAddresses) {
    const walletPublicKeyToWalletAddresses = groupBy(
      walletAddresses,
      (it) => it.address.wallet.address.toString()
    );
    const deduplicatedWalletAddresses = Object.entries(
      walletPublicKeyToWalletAddresses
    ).map(
      ([walletPublicKey, walletDappAddresses]) => walletDappAddresses.reduce((prev, curr) => ({
        id: prev.id,
        enabled: prev.enabled && curr.enabled,
        dappId: prev.dappId,
        address: {
          id: prev.id,
          value: walletPublicKey,
          verified: true,
          type: prev.address.type,
          wallet: {
            address: walletPublicKey
          }
        }
      }))
    );
    return deduplicatedWalletAddresses;
  }
  async findAll() {
    const allSettled = await Promise.allSettled(
      this.dappAddressesBackends.map((it) => it.findAll())
    );
    const errors = allSettled.filter((it) => it.status === "rejected").map((it) => it).map((it) => it.reason);
    if (errors.length > 0) {
      console.error(
        `Error during finding dapp addresses: ${errors.map(
          (it) => JSON.stringify(it)
        )}`
      );
    }
    const fulfilled = allSettled.filter((it) => it.status === "fulfilled");
    if (errors.length > 0 && fulfilled.length === 0) {
      const error = {
        ...errors[0],
        details: errors
      };
      throw error;
    }
    const allDappAddresses = fulfilled.map((it) => it).map((it) => it.value).flat();
    const walletAddresses = allDappAddresses.filter(
      (it) => it.address.type === "WALLET" /* Wallet */
    );
    const deduplicatedWalletAddresses = _DappAddressesFacade.dedupleWalletAddresses(walletAddresses);
    const nonWalletAddresses = allDappAddresses.filter(
      (it) => it.address.type !== "WALLET" /* Wallet */
    );
    return Promise.resolve([
      ...nonWalletAddresses,
      ...deduplicatedWalletAddresses
    ]);
  }
};

// src/identity/identity.interface.ts
var IdentityResolver = class {
};

// src/internal/identity/identity-resolvers.ts
var FirstFoundIdentityResolver = class extends IdentityResolver {
  constructor(resolvers) {
    super();
    this.resolvers = resolvers;
  }
  get type() {
    return "DIALECT_FIRST_FOUND_IDENTITY_RESOLVER";
  }
  async resolve(address) {
    if (!this.resolvers.length) {
      return null;
    }
    for await (const resolver of this.resolvers) {
      try {
        const identity = await resolver.resolve(address);
        if (identity) {
          return identity;
        }
      } catch (e) {
        console.error(
          `error resolving identity at ${resolver.type} for account address ${address}`,
          e
        );
      }
    }
    return null;
  }
  async resolveReverse(domainName) {
    if (!this.resolvers.length) {
      return null;
    }
    for await (const resolver of this.resolvers) {
      try {
        const reverseIdentity = await resolver.resolveReverse(domainName);
        if (reverseIdentity) {
          return reverseIdentity;
        }
      } catch (e) {
        console.error(
          `error resolving identity at ${resolver.type} for name ${domainName}`,
          e
        );
      }
    }
    return null;
  }
};
var FirstFoundFastIdentityResolver = class extends IdentityResolver {
  constructor(resolvers) {
    super();
    this.resolvers = resolvers;
  }
  get type() {
    return "DIALECT_FIRST_FOUND_FAST_IDENTITY_RESOLVER";
  }
  async resolve(address) {
    if (!this.resolvers.length) {
      return null;
    }
    try {
      const any = await Promise.any(
        this.resolvers.map((it) => it.resolve(address))
      );
      return any;
    } catch (e) {
      console.error(
        `error resolving identity for account address ${address.toString()}`,
        e
      );
    }
    return null;
  }
  async resolveReverse(domainName) {
    if (!this.resolvers.length) {
      return null;
    }
    try {
      const any = await Promise.any(
        this.resolvers.map((it) => it.resolveReverse(domainName))
      );
      return any;
    } catch (e) {
      console.error(`error resolving identity for name ${domainName}`, e);
    }
    return null;
  }
};
var AggregateSequentialIdentityResolver = class extends IdentityResolver {
  constructor(resolvers) {
    super();
    this.resolvers = resolvers;
  }
  get type() {
    return "DIALECT_AGGREGATED_SEQUENTIAL_IDENTITY_RESOLVER";
  }
  async resolve(address) {
    if (!this.resolvers.length) {
      return null;
    }
    try {
      const allSettled = await Promise.allSettled(
        this.resolvers.map((it) => it.resolve(address))
      );
      const resolved = allSettled.filter(
        (it) => it.status === "fulfilled" && it.value !== null
      );
      const aggregated = resolved.map((it) => it).map((it) => it.value).reduce(
        (prev, curr) => {
          return {
            ...curr,
            ...prev,
            additionals: { ...curr.additionals, ...prev.additionals }
          };
        },
        {
          type: this.type,
          address
        }
      );
      if (!aggregated || !aggregated.name) {
        return null;
      }
      return aggregated;
    } catch (e) {
      console.error(
        `error resolving identity for account address ${address.toString()}`,
        e
      );
    }
    return null;
  }
  async resolveReverse(domainName) {
    if (!this.resolvers.length) {
      return null;
    }
    try {
      const allSettled = await Promise.allSettled(
        this.resolvers.map((it) => it.resolveReverse(domainName))
      );
      const resolved = allSettled.filter((it) => it.status === "fulfilled");
      const aggregated = resolved.map((it) => it).map((it) => it.value).reduce(
        (prev, curr) => {
          return { ...curr, ...prev };
        },
        {
          type: "DIALECT_AGGREGATED_IDENTITY",
          name: domainName
        }
      );
      if (!aggregated || !aggregated.address) {
        return null;
      }
      return aggregated;
    } catch (e) {
      console.error(`error resolving identity for name ${domainName}`, e);
    }
    return null;
  }
};

// src/internal/dapp/data-service-dapp-addresses.ts
var DataServiceDappAddresses = class {
  constructor(dataServiceDappsApi) {
    this.dataServiceDappsApi = dataServiceDappsApi;
  }
  async findAll() {
    const dappAddressesDtos = await withErrorParsing(
      this.dataServiceDappsApi.findAllDappAddresses()
    );
    return dappAddressesDtos.map((it) => toDappAddress(it));
  }
};
function toDappAddress(dto) {
  const dapp = {
    id: dto.id,
    enabled: dto.enabled,
    channelId: dto.channelId,
    dappId: dto.dapp.id,
    address: {
      id: dto.address.id,
      type: toAddressType(dto.address.type),
      value: dto.address.value,
      verified: dto.address.verified,
      wallet: {
        address: dto.address.wallet.publicKey
      }
    }
  };
  return dapp;
}

// src/internal/wallet/data-service-wallets.ts
var DataServiceWallets = class {
  constructor(address, dataServiceWalletAddressesApi, dataServiceWalletDappAddressesApi, dataServiceWalletMessagesApi, dataServiceWalletNotificationSubscriptionsApi, dataServicePushWalletNotificationSubscriptionsApi) {
    this.address = address;
    this.dataServiceWalletAddressesApi = dataServiceWalletAddressesApi;
    this.dataServiceWalletDappAddressesApi = dataServiceWalletDappAddressesApi;
    this.dataServiceWalletMessagesApi = dataServiceWalletMessagesApi;
    this.dataServiceWalletNotificationSubscriptionsApi = dataServiceWalletNotificationSubscriptionsApi;
    this.dataServicePushWalletNotificationSubscriptionsApi = dataServicePushWalletNotificationSubscriptionsApi;
    this.addresses = new DataServiceWalletAddresses(
      dataServiceWalletAddressesApi
    );
    this.dappAddresses = new DataServiceWalletDappAddresses(
      dataServiceWalletDappAddressesApi
    );
    this.messages = new DataServiceWalletMessages(dataServiceWalletMessagesApi);
    this.notificationSubscriptions = new DataServiceWalletNotificationSubscriptions(
      dataServiceWalletNotificationSubscriptionsApi
    );
    this.pushNotificationSubscriptions = new DataServiceWalletPushNotificationSubscriptions(
      dataServicePushWalletNotificationSubscriptionsApi
    );
  }
};
var DataServiceWalletAddresses = class {
  constructor(api) {
    this.api = api;
  }
  async create(command) {
    const created = await withErrorParsing(
      this.api.create({
        value: command.value,
        type: toAddressTypeDto(command.type)
      })
    );
    return toAddress(created);
  }
  async delete(command) {
    return withErrorParsing(this.api.delete(command.addressId));
  }
  async find(query) {
    try {
      const addressDto = await withErrorParsing(this.api.find(query.addressId));
      return toAddress(addressDto);
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
  async findAll() {
    const addressDtos = await withErrorParsing(this.api.findAll());
    return addressDtos.map((it) => toAddress(it));
  }
  resendVerificationCode(command) {
    return withErrorParsing(this.api.resendVerificationCode(command.addressId));
  }
  async update(command) {
    const patched = await withErrorParsing(
      this.api.patch(command.addressId, {
        value: command.value
      })
    );
    return toAddress(patched);
  }
  async verify(command) {
    const verified = await withErrorParsing(
      this.api.verify(command.addressId, {
        code: command.code
      })
    );
    return toAddress(verified);
  }
};
var DataServiceWalletDappAddresses = class {
  constructor(api) {
    this.api = api;
  }
  async create(command) {
    const created = await withErrorParsing(
      this.api.create({
        addressId: command.addressId,
        dappPublicKey: command.dappAccountAddress.toString(),
        enabled: command.enabled
      })
    );
    return toDappAddress(created);
  }
  delete(command) {
    return withErrorParsing(this.api.delete(command.dappAddressId));
  }
  async find(query) {
    try {
      const found = await withErrorParsing(this.api.find(query.dappAddressId));
      return toDappAddress(found);
    } catch (e) {
      const err = e;
      if (err instanceof ResourceNotFoundError)
        return null;
      throw e;
    }
  }
  async findAll(query) {
    const found = await withErrorParsing(
      this.api.findAll(
        query && {
          addressIds: query.addressIds,
          dappPublicKey: query.dappAccountAddress?.toString()
        }
      )
    );
    return found.map((it) => toDappAddress(it));
  }
  async update(command) {
    const found = await withErrorParsing(
      this.api.patch(command.dappAddressId, {
        enabled: command.enabled
      })
    );
    return toDappAddress(found);
  }
};
var DataServiceWalletMessages = class {
  constructor(api) {
    this.api = api;
    this.textSerde = new UnencryptedTextSerde();
  }
  async findAllFromDapps(query) {
    const dappMessages = await withErrorParsing(
      this.api.findAllDappMessages({
        skip: query?.skip,
        take: query?.take,
        dappVerified: query?.dappVerified
      })
    );
    return dappMessages.map((it) => ({
      author: it.owner,
      timestamp: new Date(it.timestamp),
      text: this.textSerde.deserialize(new Uint8Array(it.text)),
      id: it.id,
      metadata: it.metadata
    }));
  }
  async dappMessagesSummary(query) {
    const summaryDto = await withErrorParsing(
      this.api.dappMessagesSummary({
        dappVerified: query?.dappVerified
      })
    );
    return {
      unreadMessagesCount: summaryDto.unreadMessagesCount
    };
  }
  async markAllDappMessagesAsRead(command) {
    await withErrorParsing(
      this.api.markAllDappMessagesAsRead({
        dappVerified: command?.dappVerified
      })
    );
  }
};
function toAddress(addressDto) {
  return {
    id: addressDto.id,
    value: addressDto.value,
    verified: addressDto.verified,
    type: toAddressType(addressDto.type),
    wallet: {
      address: addressDto.wallet.publicKey
    }
  };
}
var DataServiceWalletNotificationSubscriptions = class {
  constructor(api) {
    this.api = api;
  }
  async findAll(query) {
    const dtos = await withErrorParsing(
      this.api.findAll({
        dappPublicKey: query?.dappAccountAddress?.toString()
      })
    );
    return dtos.map(fromNotificationSubscriptionDto);
  }
  async upsert(command) {
    const dto = await withErrorParsing(this.api.upsert(command));
    return fromNotificationSubscriptionDto(dto);
  }
};
function fromNotificationSubscriptionDto(dto) {
  return {
    notificationType: dto.notificationType,
    subscription: {
      wallet: {
        address: dto.subscription.wallet.publicKey
      },
      config: dto.subscription.config
    }
  };
}
var DataServiceWalletPushNotificationSubscriptions = class {
  constructor(api) {
    this.api = api;
  }
  async delete(physicalId) {
    await withErrorParsing(this.api.delete(physicalId));
  }
  async upsert(command) {
    const dto = await this.api.upsert(command);
    return {
      ...dto,
      walletAddress: dto.walletPublicKey
    };
  }
  async get(physicalId) {
    const dto = await this.api.get(physicalId);
    return {
      ...dto,
      walletAddress: dto.walletPublicKey
    };
  }
};

// src/internal/messaging/messaging-facade.ts
var MessagingFacade = class {
  constructor(delegates) {
    this.delegates = delegates;
    this.type = "messaging-facade";
    if (delegates.length < 1) {
      throw new IllegalArgumentError(
        "Expected to have at least on messaging backend."
      );
    }
  }
  create(command) {
    const messaging = this.getPreferableMessaging(command.type);
    return messaging.create(command);
  }
  async find(query) {
    if ("id" in query && query.id.type) {
      const messaging = this.lookUpMessagingBackend(query.id.type);
      return messaging.find(query);
    }
    for (const messaging of this.delegates) {
      try {
        const thread = await messaging.find(query);
        if (thread) {
          return thread;
        }
      } catch (e) {
        console.error(e);
      }
    }
    return null;
  }
  async findAll() {
    const allSettled = await Promise.allSettled(
      this.delegates.map((messaging) => messaging.findAll())
    );
    const errors = allSettled.filter((it) => it.status === "rejected").map((it) => it).map((it) => it.reason);
    if (errors.length > 0) {
      console.error(
        `Error during finding dialects: ${errors.map(
          (it) => JSON.stringify(it)
        )}`
      );
    }
    const fulfilled = allSettled.filter((it) => it.status === "fulfilled");
    if (errors.length > 0 && fulfilled.length === 0) {
      const error = {
        ...errors[0],
        details: errors
      };
      throw error;
    }
    return fulfilled.map((it) => it).map((it) => it.value).flat().sort((t1, t2) => t2.updatedAt.getTime() - t1.updatedAt.getTime());
  }
  async findSummary(query) {
    for (const messaging of this.delegates) {
      try {
        const thread = await messaging.findSummary(query);
        if (thread) {
          return thread;
        }
      } catch (e) {
        console.error(e);
      }
    }
    return null;
  }
  async findSummaryAll() {
    for (const messaging of this.delegates) {
      try {
        const summary = await messaging.findSummaryAll();
        if (summary) {
          return summary;
        }
      } catch (e) {
        console.error(e);
      }
    }
    return null;
  }
  getPreferableMessaging(type) {
    if (type) {
      return this.lookUpMessagingBackend(type);
    }
    return this.getFirstAccordingToPriority();
  }
  lookUpMessagingBackend(type) {
    const messagingBackend = this.delegates.find(({ type: t }) => type === t);
    if (!messagingBackend) {
      throw new IllegalArgumentError(
        `Backend ${type} is not configured in sdk.`
      );
    }
    return messagingBackend;
  }
  getFirstAccordingToPriority() {
    const messaging = this.delegates[0];
    if (!messaging) {
      throw new IllegalStateError("Should not happen.");
    }
    return messaging;
  }
};

// src/internal/dapp/data-service-dapp-notification-types.ts
var DataServiceDappNotificationTypes = class {
  constructor(api) {
    this.api = api;
  }
  async create(command) {
    const dto = await withErrorParsing(this.api.create(command));
    return {
      ...dto
    };
  }
  async delete(id) {
    await withErrorParsing(this.api.delete(id));
  }
  async find(id) {
    const dto = await withErrorParsing(this.api.find(id));
    return {
      ...dto
    };
  }
  async findAll() {
    const dtos = await withErrorParsing(this.api.findAll());
    return dtos.map((it) => ({
      ...it
    }));
  }
  async patch(id, command) {
    const dto = await withErrorParsing(this.api.patch(id, command));
    return {
      ...dto
    };
  }
};

// src/dialect-cloud-api/data-service-wallet-notification-subscriptions-api.ts
var import_axios3 = __toESM(require("axios"), 1);
var DataServiceWalletNotificationSubscriptionsApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async findAll(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios3.default.get(
        `${this.baseUrl}/api/v1/wallets/me/notificationSubscriptions`,
        {
          headers: createHeaders(token),
          params: query
        }
      ).then((it) => it.data)
    );
  }
  async upsert(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios3.default.post(
        `${this.baseUrl}/api/v1/wallets/me/notificationSubscriptions`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-wallets-api.v0.ts
var import_axios4 = __toESM(require("axios"), 1);
var DataServiceWalletsApiClientV0 = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async createDappAddress(command, dapp) {
    const token = await this.tokenProvider.get();
    const headers = createHeaders(token);
    return withReThrowingDataServiceError(
      import_axios4.default.post(
        `${this.baseUrl}/v0/wallets/${token.body.sub}/dapps/${dapp}/addresses`,
        command,
        {
          headers
        }
      ).then((it) => it.data)
    );
  }
  async deleteDappAddress(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios4.default.delete(
        `${this.baseUrl}/v0/wallets/${token.body.sub}/addresses/${command.id}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async findAllDappAddresses(dapp) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios4.default.get(
        `${this.baseUrl}/v0/wallets/${token.body.sub}/dapps/${dapp}/addresses`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-wallet-dapp-addresses-api.ts
var import_axios5 = __toESM(require("axios"), 1);
var DataServiceWalletDappAddressesApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async create(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios5.default.post(
        `${this.baseUrl}/api/v1/wallets/me/dappAddresses`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async delete(dappAddressId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios5.default.delete(
        `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async find(dappAddressId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios5.default.get(
        `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async findAll(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios5.default.get(
        `${this.baseUrl}/api/v1/wallets/me/dappAddresses`,
        {
          headers: createHeaders(token),
          ...query && { params: query }
        }
      ).then((it) => it.data)
    );
  }
  async patch(dappAddressId, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios5.default.patch(
        `${this.baseUrl}/api/v1/wallets/me/dappAddresses/${dappAddressId}`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-wallet-addresses-api.ts
var import_axios6 = __toESM(require("axios"), 1);
var DataServiceWalletAddressesApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async create(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.post(
        `${this.baseUrl}/api/v1/wallets/me/addresses`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async patch(addressId, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.patch(
        `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async delete(addressId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.delete(
        `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async find(addressId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.get(
        `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async findAll() {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.get(`${this.baseUrl}/api/v1/wallets/me/addresses`, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
  async resendVerificationCode(addressId) {
    const token = await this.tokenProvider.get();
    return await withReThrowingDataServiceError(
      import_axios6.default.post(
        `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}/resendVerificationCode`,
        {},
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async verify(addressId, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios6.default.post(
        `${this.baseUrl}/api/v1/wallets/me/addresses/${addressId}/verify`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-push-notification-subscriptions-api.ts
var import_axios7 = __toESM(require("axios"), 1);
var DataServicePushNotificationSubscriptionsApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async get(physicalId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios7.default.get(
        `${this.baseUrl}/api/v1/pushNotificationSubscriptions/${physicalId}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async delete(physicalId) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios7.default.delete(
        `${this.baseUrl}/api/v1/pushNotificationSubscriptions/${physicalId}`,
        {
          headers: createHeaders(token)
        }
      )
    );
  }
  async upsert(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios7.default.post(
        `${this.baseUrl}/api/v1/pushNotificationSubscriptions`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-api-factory.ts
var import_nanoid2 = require("nanoid");

// src/dialect-cloud-api/data-service-dapp-notification-types-api.ts
var import_axios8 = __toESM(require("axios"), 1);
var DataServiceDappNotificationTypesApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async create(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios8.default.post(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async delete(id) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios8.default.delete(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,
        {
          headers: createHeaders(token)
        }
      ).then()
    );
  }
  async find(id) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios8.default.get(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async findAll() {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios8.default.get(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
  async patch(id, command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios8.default.patch(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationTypes/${id}`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-wallet-messages-api.ts
var import_axios9 = __toESM(require("axios"), 1);
var DataServiceWalletMessagesApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async findAllDappMessages(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios9.default.get(`${this.baseUrl}/api/v1/wallets/me/dappMessages`, {
        headers: createHeaders(token),
        ...query && { params: query }
      }).then((it) => it.data)
    );
  }
  async dappMessagesSummary(query) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios9.default.get(
        `${this.baseUrl}/api/v1/wallets/me/dappMessages/summary`,
        {
          headers: createHeaders(token),
          ...query && { params: query }
        }
      ).then((it) => it.data)
    );
  }
  async markAllDappMessagesAsRead(command) {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios9.default.post(
        `${this.baseUrl}/api/v1/wallets/me/dappMessages/markAsRead`,
        command,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-dapp-notification-subscriptions-api.ts
var import_axios10 = __toESM(require("axios"), 1);
var DataServiceDappNotificationSubscriptionsApiClient = class {
  constructor(baseUrl, tokenProvider) {
    this.baseUrl = baseUrl;
    this.tokenProvider = tokenProvider;
  }
  async findAll() {
    const token = await this.tokenProvider.get();
    return withReThrowingDataServiceError(
      import_axios10.default.get(
        `${this.baseUrl}/api/v1/dapps/${token.body.sub}/notificationSubscriptions`,
        {
          headers: createHeaders(token)
        }
      ).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-health-api.ts
var import_axios11 = __toESM(require("axios"), 1);
var DataServiceHealthApiClient = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  healthCheck() {
    return withReThrowingDataServiceError(
      import_axios11.default.get(`${this.baseUrl}/api/v1/health`).then((it) => it.data)
    );
  }
};

// src/dialect-cloud-api/data-service-api-factory.ts
var DataServiceApiFactory = class {
  static create(baseUrl, tokenProvider) {
    const dialectsApi = new DataServiceDialectsApiClient(
      baseUrl,
      tokenProvider
    );
    const dappsApiClient = new DataServiceDappsApiClient(
      baseUrl,
      tokenProvider
    );
    const dappNotificationTypes = new DataServiceDappNotificationTypesApiClient(
      baseUrl,
      tokenProvider
    );
    const dappNotificationSubscriptions = new DataServiceDappNotificationSubscriptionsApiClient(
      baseUrl,
      tokenProvider
    );
    const walletsApiV0 = new DataServiceWalletsApiClientV0(
      baseUrl,
      tokenProvider
    );
    const walletAddressesApi = new DataServiceWalletAddressesApiClient(
      baseUrl,
      tokenProvider
    );
    const walletDappAddressesApi = new DataServiceWalletDappAddressesApiClient(
      baseUrl,
      tokenProvider
    );
    const walletDappMessagesApi = new DataServiceWalletMessagesApiClient(
      baseUrl,
      tokenProvider
    );
    const walletNotificationSubscriptions = new DataServiceWalletNotificationSubscriptionsApiClient(
      baseUrl,
      tokenProvider
    );
    const pushNotificationSubscriptions = new DataServicePushNotificationSubscriptionsApiClient(
      baseUrl,
      tokenProvider
    );
    const health = new DataServiceHealthApiClient(baseUrl);
    return new DataServiceApi(
      dialectsApi,
      dappsApiClient,
      dappNotificationTypes,
      dappNotificationSubscriptions,
      walletsApiV0,
      walletAddressesApi,
      walletDappAddressesApi,
      walletDappMessagesApi,
      walletNotificationSubscriptions,
      pushNotificationSubscriptions,
      health
    );
  }
};

// src/dialect-cloud-api/data-service-wallets-api.v1.ts
var import_axios12 = __toESM(require("axios"), 1);
var DataServiceWalletsApiClientV1 = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  async upsertWallet(wallet, token) {
    return withReThrowingDataServiceError(
      import_axios12.default.post(`${this.baseUrl}/api/v1/wallets/me/`, wallet, {
        headers: createHeaders(token)
      }).then((it) => it.data)
    );
  }
};

// src/internal/sdk/sdk-factory.ts
var InternalDialectSdk = class {
  constructor(config, threads, dapps, wallet, identity, tokenProvider, encryptionKeysProvider, blockchainSdk) {
    this.config = config;
    this.threads = threads;
    this.dapps = dapps;
    this.wallet = wallet;
    this.identity = identity;
    this.tokenProvider = tokenProvider;
    this.encryptionKeysProvider = encryptionKeysProvider;
    this.blockchainSdk = blockchainSdk;
  }
  get info() {
    return {
      supportsEndToEndEncryption: this.encryptionKeysProvider.isAvailable(),
      hasValidAuthentication: this.tokenProvider.hasValidCachedToken()
    };
  }
};
var DialectSdkFactory = class _DialectSdkFactory {
  constructor(config, blockchainFactory) {
    this.config = config;
    this.blockchainFactory = blockchainFactory;
  }
  static logConfiguration(config) {
    if (config.environment !== "production") {
      console.log(
        `Initializing Dialect SDK using configuration:
  Dialect cloud settings:
    URL: ${config.dialectCloud.url}
  `
      );
    }
  }
  create() {
    const config = this.initializeConfig();
    _DialectSdkFactory.logConfiguration(config);
    const blockchainSdk = this.blockchainFactory.create(config);
    const tokenProvider = this.initializeTokenProvider(config, blockchainSdk);
    const dataServiceApi = this.initializeDataServiceApi(
      config.dialectCloud,
      tokenProvider
    );
    const messaging = this.initializeMessagingApi(
      dataServiceApi,
      blockchainSdk
    );
    const dapps = this.initializeDappApi(dataServiceApi, blockchainSdk);
    const wallet = new DataServiceWallets(
      blockchainSdk.authenticationFacade.subject(),
      dataServiceApi.walletAddresses,
      dataServiceApi.walletDappAddresses,
      dataServiceApi.walletMessages,
      dataServiceApi.walletNotificationSubscriptions,
      dataServiceApi.pushNotificationSubscriptions
    );
    const identity = this.createIdentityResolver(config.identity);
    return new InternalDialectSdk(
      config,
      messaging,
      dapps,
      wallet,
      identity,
      tokenProvider,
      blockchainSdk.encryptionKeysProvider,
      blockchainSdk
    );
  }
  initializeTokenProvider(config, { authenticationFacade }) {
    const defaultTokenProvider = new DefaultTokenProvider(
      config.dialectCloud.tokenLifetimeMinutes * 60,
      authenticationFacade.tokenGenerator
    );
    const dataServiceWalletsApiV1 = new DataServiceWalletsApiClientV1(
      config.dialectCloud.url
    );
    return new CachedTokenProvider(
      defaultTokenProvider,
      config.dialectCloud.tokenStore,
      config.dialectCloud.walletCreation,
      authenticationFacade.authenticator.parser,
      authenticationFacade.authenticator.validator,
      authenticationFacade.subject(),
      dataServiceWalletsApiV1
    );
  }
  initializeDataServiceApi(config, tokenProvider) {
    return DataServiceApiFactory.create(config.url, tokenProvider);
  }
  initializeMessagingApi(dataServiceApi, blockchainSdk) {
    const messagings = [];
    const dataServiceMessaging = new DataServiceMessaging(
      blockchainSdk.authenticationFacade.subject(),
      dataServiceApi.threads,
      blockchainSdk.encryptionKeysProvider
    );
    messagings.push(dataServiceMessaging);
    if (blockchainSdk.messaging) {
      messagings.push(blockchainSdk.messaging);
    }
    return new MessagingFacade(messagings);
  }
  initializeDappApi(dataServiceApi, blockchainSdk) {
    const dappAddresses = this.createDappAddresses(
      dataServiceApi,
      blockchainSdk
    );
    const dappNotificationTypes = new DataServiceDappNotificationTypes(
      dataServiceApi.dappNotificationTypes
    );
    const dappNotificationSubscriptions = new DataServiceDappNotificationSubscriptions(
      dataServiceApi.dappNotificationSubscriptions
    );
    const dappMessages = this.createDappMessages(dataServiceApi, blockchainSdk);
    return new DappsImpl(
      dappAddresses,
      dappMessages,
      dappNotificationTypes,
      dappNotificationSubscriptions,
      dataServiceApi.dapps
    );
  }
  createDappAddresses(dataServiceApi, blockchainSdk) {
    const dappAddresses = [];
    const dataServiceDappAddresses = new DataServiceDappAddresses(
      dataServiceApi.dapps
    );
    dappAddresses.push(dataServiceDappAddresses);
    if (blockchainSdk.dappAddresses) {
      dappAddresses.push(blockchainSdk.dappAddresses);
    }
    return new DappAddressesFacade(dappAddresses);
  }
  createDappMessages(dataServiceApi, blockchainSdk) {
    const dappMessages = [];
    const dataServiceDappMessages = new DataServiceDappMessages(
      dataServiceApi.dapps
    );
    dappMessages.push(dataServiceDappMessages);
    if (blockchainSdk.dappMessages) {
      dappMessages.push(blockchainSdk.dappMessages);
    }
    return new DappMessagesFacade(dappMessages);
  }
  createIdentityResolver(config) {
    if (config.strategy === "first-found") {
      return new FirstFoundIdentityResolver(config.resolvers);
    }
    if (config.strategy === "first-found-fast") {
      return new FirstFoundFastIdentityResolver(config.resolvers);
    }
    if (config.strategy === "aggregate-sequential") {
      return new AggregateSequentialIdentityResolver(config.resolvers);
    }
    throw new IllegalArgumentError(
      `Unknown identity strategy ${config.strategy}`
    );
  }
  initializeConfig() {
    const environment = this.config.environment ?? "production";
    const encryptionKeysStore = this.createEncryptionKeysStore();
    const identity = this.createIdentityConfig();
    return {
      environment,
      dialectCloud: this.initializeDialectCloudConfig(),
      encryptionKeysStore,
      identity
    };
  }
  createEncryptionKeysStore() {
    const encryptionKeysStoreConfig = this.config.encryptionKeysStore;
    if (encryptionKeysStoreConfig && encryptionKeysStoreConfig instanceof EncryptionKeysStore) {
      return encryptionKeysStoreConfig;
    }
    if (encryptionKeysStoreConfig === "in-memory") {
      return EncryptionKeysStore.createInMemory();
    }
    if (encryptionKeysStoreConfig === "session-storage") {
      return EncryptionKeysStore.createSessionStorage();
    }
    if (encryptionKeysStoreConfig === "local-storage") {
      return EncryptionKeysStore.createLocalStorage();
    }
    return EncryptionKeysStore.createInMemory();
  }
  initializeDialectCloudConfig() {
    const baseConfig = {
      environment: "production",
      url: "https://dialectapi.to",
      tokenStore: this.createTokenStore(),
      tokenLifetimeMinutes: this.createTokenLifetime(),
      walletCreation: "implicit"
    };
    const environment = this.config.environment;
    if (environment) {
      baseConfig.environment = environment;
    }
    if (environment === "production") {
      baseConfig.url = "https://dialectapi.to";
    }
    if (environment === "development") {
      baseConfig.url = "https://dev.dialectapi.to";
    }
    if (environment === "local-development") {
      baseConfig.url = "http://localhost:8080";
    }
    const dialectCloudEnvironment = this.config.dialectCloud?.environment;
    if (dialectCloudEnvironment) {
      baseConfig.environment = dialectCloudEnvironment;
    }
    if (dialectCloudEnvironment === "production") {
      baseConfig.url = "https://dialectapi.to";
    }
    if (dialectCloudEnvironment === "development") {
      baseConfig.url = "https://dev.dialectapi.to";
    }
    if (dialectCloudEnvironment === "local-development") {
      baseConfig.url = "http://localhost:8080";
    }
    if (this.config.dialectCloud?.url) {
      baseConfig.url = this.config.dialectCloud.url;
    }
    if (this.config.dialectCloud?.walletCreation) {
      baseConfig.walletCreation = this.config.dialectCloud.walletCreation;
    }
    return baseConfig;
  }
  createTokenLifetime() {
    return this.config.dialectCloud?.tokenLifetimeMinutes ?? DEFAULT_TOKEN_LIFETIME_SECONDS / 60;
  }
  createTokenStore() {
    const tokenStoreConfig = this.config.dialectCloud?.tokenStore;
    if (tokenStoreConfig && tokenStoreConfig instanceof TokenStore) {
      return tokenStoreConfig;
    }
    if (tokenStoreConfig === "in-memory") {
      return TokenStore.createInMemory();
    }
    if (tokenStoreConfig === "session-storage") {
      return TokenStore.createSessionStorage();
    }
    if (tokenStoreConfig === "local-storage") {
      return TokenStore.createLocalStorage();
    }
    return TokenStore.createInMemory();
  }
  createIdentityConfig() {
    const identityConfig = {
      strategy: "first-found",
      resolvers: []
    };
    if (!this.config.identity) {
      return identityConfig;
    }
    if (this.config.identity.strategy) {
      identityConfig.strategy = this.config.identity.strategy;
    }
    if (this.config.identity.resolvers) {
      identityConfig.resolvers = this.config.identity.resolvers;
    }
    return identityConfig;
  }
};

// src/sdk/sdk.interface.ts
var Dialect = class {
  static sdk(configProps, blockchainSdkFactory) {
    return new DialectSdkFactory(configProps, blockchainSdkFactory).create();
  }
};
var BlockchainSdk = class {
};
var DialectSdk = class {
};

// src/wallet/wallet.interface.ts
var NotificationSubscription = class {
};

// src/dialect-cloud-api/smart-message-spec.dto.ts
var SmartMessageStateDto = /* @__PURE__ */ ((SmartMessageStateDto2) => {
  SmartMessageStateDto2["Created"] = "CREATED";
  SmartMessageStateDto2["ReadyForExecution"] = "READY_FOR_EXECUTION";
  SmartMessageStateDto2["Executing"] = "EXECUTING";
  SmartMessageStateDto2["Succeeded"] = "SUCCEEDED";
  SmartMessageStateDto2["Failed"] = "FAILED";
  SmartMessageStateDto2["Canceled"] = "CANCELED";
  return SmartMessageStateDto2;
})(SmartMessageStateDto || {});
var ActionType = /* @__PURE__ */ ((ActionType2) => {
  ActionType2["SignTransaction"] = "SIGN_TRANSACTION";
  ActionType2["OpenLink"] = "OPEN_LINK";
  ActionType2["Cancel"] = "CANCEL";
  return ActionType2;
})(ActionType || {});
var SmartMessageButtonLayoutElementDto = class {
};
var SmartMessageLabelLayoutElementDto = class {
};
var SmartMessageSpecOpenLinkActionDto = class {
};
var SmartMessageSpecSignTransactionActionDto = class {
};
var SmartMessageSpecCancelActionDto = class {
};
var SmartMessageLayoutDto = class {
};
var SmartMessageContentDto = class {
};
var SmartMessagePreviewParamsDto = class {
};
var SmartMessageSystemParamsDto = class {
};
var CreateSmartMessageTransactionCommandDto = class {
};
var SmartMessageTransactionDto = class {
};
var SubmitSmartMessageTransactionCommandDto = class {
};

// src/dialect-cloud-api/smart-message.dto.ts
var SmartMessageDto = class {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ActionType,
  AddressType,
  AggregateSequentialIdentityResolver,
  AuthenticationError,
  AuthenticationFacade,
  AuthenticationFacadeFactory,
  Authenticator,
  AuthorizationError,
  BlockchainSdk,
  BlockchainType,
  BusinessConstraintViolationError,
  CachedTokenProvider,
  CreateSmartMessageTransactionCommandDto,
  DEFAULT_TOKEN_LIFETIME_SECONDS,
  DIALECT_API_TYPE_DIALECT_CLOUD,
  DappMessageActionType,
  DappNotificationSubscription,
  DataServiceApi,
  DataServiceApiError,
  DataServiceApiFactory,
  DataServiceMessaging,
  DataServiceThread,
  DataServiceWalletsApiClientV1,
  DefaultTokenGenerator,
  DefaultTokenProvider,
  Dialect,
  DialectSdk,
  DialectSdkError,
  Ed25519AuthenticationFacadeFactory,
  Ed25519PublicKey,
  Ed25519TokenBodyParser,
  Ed25519TokenSigner,
  EncryptionKeysProvider,
  EncryptionKeysStore,
  FirstFoundFastIdentityResolver,
  FirstFoundIdentityResolver,
  IdentityError,
  IdentityResolver,
  IllegalArgumentError,
  IllegalStateError,
  MAX_TOKEN_LIFETIME_SECONDS,
  MessagingError,
  NetworkError,
  NotificationSubscription,
  PublicKey,
  ResourceAlreadyExistsError,
  ResourceNotFoundError,
  SDK_VERSION,
  SmartMessageButtonLayoutElementDto,
  SmartMessageContentDto,
  SmartMessageDto,
  SmartMessageLabelLayoutElementDto,
  SmartMessageLayoutDto,
  SmartMessagePreviewParamsDto,
  SmartMessageSpecCancelActionDto,
  SmartMessageSpecOpenLinkActionDto,
  SmartMessageSpecSignTransactionActionDto,
  SmartMessageStateDto,
  SmartMessageSystemParamsDto,
  SmartMessageTransactionDto,
  SubmitSmartMessageTransactionCommandDto,
  ThreadAlreadyExistsError,
  ThreadId,
  ThreadMemberScope,
  TokenBodyParser,
  TokenGenerator,
  TokenHeaderParser,
  TokenParser,
  TokenParsingError,
  TokenProvider,
  TokenSigner,
  TokenStore,
  TokenStructureValidationError,
  TokenUnsupportedAlgError,
  TokenValidator,
  UnknownError,
  UnsupportedOperationError,
  bytesFromBase64,
  bytesToBase64,
  createHeaders,
  deserializeDiffeHellmanKeys,
  generateEd25519Keypair,
  jsonParseFromBase64,
  jsonStringifyToBase64,
  serializeDiffeHellmanKeys,
  toAddressType,
  toAddressTypeDto,
  withReThrowingDataServiceError
});
//# sourceMappingURL=index.cjs.map